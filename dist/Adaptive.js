/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "vue":
/*!**********************!*\
  !*** external "Vue" ***!
  \**********************/
/***/ ((module) => {

module.exports = Vue;

/***/ }),

/***/ "./node_modules/@knighttower/js-utility-functions/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@knighttower/js-utility-functions/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DomObserver: () => (/* reexport safe */ _src_DomObserver_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   ElementHelper: () => (/* reexport safe */ _src_ElementHelper_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   PowerHelper: () => (/* reexport safe */ _src_PowerHelpers_js__WEBPACK_IMPORTED_MODULE_2__.PowerHelper),
/* harmony export */   ProxyHelper: () => (/* reexport safe */ _src_ProxyHelper_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   UrlHelper: () => (/* reexport safe */ _src_UrlHelper_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   Utility: () => (/* reexport safe */ _src_Utility_js__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   addQuotes: () => (/* reexport safe */ _src_PowerHelpers_js__WEBPACK_IMPORTED_MODULE_2__.addQuotes),
/* harmony export */   cleanStr: () => (/* reexport safe */ _src_PowerHelpers_js__WEBPACK_IMPORTED_MODULE_2__.cleanStr),
/* harmony export */   convertKeysToSymbols: () => (/* reexport safe */ _src_PowerHelpers_js__WEBPACK_IMPORTED_MODULE_2__.convertKeysToSymbols),
/* harmony export */   convertToBool: () => (/* reexport safe */ _src_Utility_js__WEBPACK_IMPORTED_MODULE_5__.convertToBool),
/* harmony export */   convertToNumber: () => (/* reexport safe */ _src_Utility_js__WEBPACK_IMPORTED_MODULE_5__.convertToNumber),
/* harmony export */   currencyToDecimal: () => (/* reexport safe */ _src_Utility_js__WEBPACK_IMPORTED_MODULE_5__.currencyToDecimal),
/* harmony export */   dateFormat: () => (/* reexport safe */ _src_Utility_js__WEBPACK_IMPORTED_MODULE_5__.dateFormat),
/* harmony export */   decimalToCurrency: () => (/* reexport safe */ _src_Utility_js__WEBPACK_IMPORTED_MODULE_5__.decimalToCurrency),
/* harmony export */   emptyOrValue: () => (/* reexport safe */ _src_Utility_js__WEBPACK_IMPORTED_MODULE_5__.emptyOrValue),
/* harmony export */   findAndReplaceInArray: () => (/* reexport safe */ _src_PowerHelpers_js__WEBPACK_IMPORTED_MODULE_2__.findAndReplaceInArray),
/* harmony export */   findNested: () => (/* reexport safe */ _src_PowerHelpers_js__WEBPACK_IMPORTED_MODULE_2__.findNested),
/* harmony export */   fixQuotes: () => (/* reexport safe */ _src_PowerHelpers_js__WEBPACK_IMPORTED_MODULE_2__.fixQuotes),
/* harmony export */   formatPhoneNumber: () => (/* reexport safe */ _src_Utility_js__WEBPACK_IMPORTED_MODULE_5__.formatPhoneNumber),
/* harmony export */   getArrObjFromString: () => (/* reexport safe */ _src_PowerHelpers_js__WEBPACK_IMPORTED_MODULE_2__.getArrObjFromString),
/* harmony export */   getChunks: () => (/* reexport safe */ _src_PowerHelpers_js__WEBPACK_IMPORTED_MODULE_2__.getChunks),
/* harmony export */   getDirectivesFromString: () => (/* reexport safe */ _src_PowerHelpers_js__WEBPACK_IMPORTED_MODULE_2__.getDirectivesFromString),
/* harmony export */   getDynamicId: () => (/* reexport safe */ _src_Utility_js__WEBPACK_IMPORTED_MODULE_5__.getDynamicId),
/* harmony export */   getGoogleMapsAddress: () => (/* reexport safe */ _src_Utility_js__WEBPACK_IMPORTED_MODULE_5__.getGoogleMapsAddress),
/* harmony export */   getMatchBlock: () => (/* reexport safe */ _src_PowerHelpers_js__WEBPACK_IMPORTED_MODULE_2__.getMatchBlock),
/* harmony export */   getMatchInBetween: () => (/* reexport safe */ _src_PowerHelpers_js__WEBPACK_IMPORTED_MODULE_2__.getMatchInBetween),
/* harmony export */   getRandomId: () => (/* reexport safe */ _src_Utility_js__WEBPACK_IMPORTED_MODULE_5__.getRandomId),
/* harmony export */   includes: () => (/* reexport safe */ _src_Utility_js__WEBPACK_IMPORTED_MODULE_5__.includes),
/* harmony export */   instanceOf: () => (/* reexport safe */ _src_Utility_js__WEBPACK_IMPORTED_MODULE_5__.instanceOf),
/* harmony export */   isEmpty: () => (/* reexport safe */ _src_Utility_js__WEBPACK_IMPORTED_MODULE_5__.isEmpty),
/* harmony export */   isNumber: () => (/* reexport safe */ _src_Utility_js__WEBPACK_IMPORTED_MODULE_5__.isNumber),
/* harmony export */   openGoogleMapsAddress: () => (/* reexport safe */ _src_Utility_js__WEBPACK_IMPORTED_MODULE_5__.openGoogleMapsAddress),
/* harmony export */   powerHelper: () => (/* reexport safe */ _src_PowerHelpers_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   proxyObject: () => (/* reexport safe */ _src_Utility_js__WEBPACK_IMPORTED_MODULE_5__.proxyObject),
/* harmony export */   removeQuotes: () => (/* reexport safe */ _src_PowerHelpers_js__WEBPACK_IMPORTED_MODULE_2__.removeQuotes),
/* harmony export */   selectElement: () => (/* reexport safe */ _src_Utility_js__WEBPACK_IMPORTED_MODULE_5__.selectElement),
/* harmony export */   setExpString: () => (/* reexport safe */ _src_PowerHelpers_js__WEBPACK_IMPORTED_MODULE_2__.setExpString),
/* harmony export */   setLookUpExp: () => (/* reexport safe */ _src_PowerHelpers_js__WEBPACK_IMPORTED_MODULE_2__.setLookUpExp),
/* harmony export */   setWildCardString: () => (/* reexport safe */ _src_PowerHelpers_js__WEBPACK_IMPORTED_MODULE_2__.setWildCardString),
/* harmony export */   startAndEndWith: () => (/* reexport safe */ _src_PowerHelpers_js__WEBPACK_IMPORTED_MODULE_2__.startAndEndWith),
/* harmony export */   toCurrency: () => (/* reexport safe */ _src_Utility_js__WEBPACK_IMPORTED_MODULE_5__.toCurrency),
/* harmony export */   toDollarString: () => (/* reexport safe */ _src_Utility_js__WEBPACK_IMPORTED_MODULE_5__.toDollarString),
/* harmony export */   typeOf: () => (/* reexport safe */ _src_Utility_js__WEBPACK_IMPORTED_MODULE_5__.typeOf),
/* harmony export */   utility: () => (/* reexport safe */ _src_Utility_js__WEBPACK_IMPORTED_MODULE_5__.utility),
/* harmony export */   utils: () => (/* reexport safe */ _src_Utility_js__WEBPACK_IMPORTED_MODULE_5__.utils),
/* harmony export */   validateEmail: () => (/* reexport safe */ _src_Utility_js__WEBPACK_IMPORTED_MODULE_5__.validateEmail),
/* harmony export */   validatePhone: () => (/* reexport safe */ _src_Utility_js__WEBPACK_IMPORTED_MODULE_5__.validatePhone),
/* harmony export */   wildCardStringSearch: () => (/* reexport safe */ _src_PowerHelpers_js__WEBPACK_IMPORTED_MODULE_2__.wildCardStringSearch)
/* harmony export */ });
/* harmony import */ var _src_DomObserver_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/DomObserver.js */ "./node_modules/@knighttower/js-utility-functions/src/DomObserver.js");
/* harmony import */ var _src_ElementHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/ElementHelper.js */ "./node_modules/@knighttower/js-utility-functions/src/ElementHelper.js");
/* harmony import */ var _src_PowerHelpers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/PowerHelpers.js */ "./node_modules/@knighttower/js-utility-functions/src/PowerHelpers.js");
/* harmony import */ var _src_ProxyHelper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/ProxyHelper.js */ "./node_modules/@knighttower/js-utility-functions/src/ProxyHelper.js");
/* harmony import */ var _src_UrlHelper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/UrlHelper.js */ "./node_modules/@knighttower/js-utility-functions/src/UrlHelper.js");
/* harmony import */ var _src_Utility_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/Utility.js */ "./node_modules/@knighttower/js-utility-functions/src/Utility.js");
// Default Module from: DomObserver

// Default Module from: ElementHelper

// Single Modules and Aliases from: PowerHelpers

// Default Module from: PowerHelpers

// Default Module from: ProxyHelper

// Default Module from: UrlHelper

// Single Modules and Aliases from: Utility

// Default Module from: Utility





/***/ }),

/***/ "./node_modules/@knighttower/js-utility-functions/src/DomObserver.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@knighttower/js-utility-functions/src/DomObserver.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// Author Knighttower
// MIT License
// [2022] [Knighttower] https://github.com/knighttower
/**
 * @module DomObserver
 * Detect DOM changes
 * @name DomObserver
 * @param {window} selector
 * @param {Function}
 * @return DomObserver
 * @example DomObserver.addOnNodeChange('elementIdentifier', () => { console.log('Node changed') })
 * @example DomObserver.removeOnNodeChange('elementIdentifier')
 */
/**
 * Holds memory of registered functions
 * @private
 */
const executeOnNodeChanged = {};
/**
 * When node change
 * @param {String} id
 * @param {Function} callback Callback when any node changes/ add/deleted/modified
 * @return {Void}
 */
const addOnNodeChange = (id, callback) => {
    if (callback) {
        executeOnNodeChanged[id] = callback;
    }
};
/**
 * Remove from node change
 * @param {String} id
 * @return {Void}
 */
const removeOnNodeChange = (id) => {
    if (id) {
        delete executeOnNodeChanged[id];
    }
};
/**
 * Deep cleanup
 * @return {Void}
 */
const cleanup = () => {
    Object.keys(executeOnNodeChanged).forEach((key) => delete executeOnNodeChanged[key]);
};
/**
 * Observer
 * @private
 * @return {MutationObserver}
 */
(() => {
    if (typeof window !== 'undefined') {
        const callback = (mutationList) => {
            for (const mutation of mutationList) {
                if (mutation.type === 'childList') {
                    for (const id in executeOnNodeChanged) {
                        executeOnNodeChanged[id]();
                    }
                }
            }
        };
        const config = {
            childList: true,
            subtree: true,
        };
        const observer = new MutationObserver(callback);
        observer.observe(document.body, config);
    }
})();
const DomObserver = {
    executeOnNodeChanged,
    addOnNodeChange,
    removeOnNodeChange,
    cleanup,
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DomObserver);


/***/ }),

/***/ "./node_modules/@knighttower/js-utility-functions/src/ElementHelper.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@knighttower/js-utility-functions/src/ElementHelper.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _DomObserver_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DomObserver.js */ "./node_modules/@knighttower/js-utility-functions/src/DomObserver.js");
// Author Knighttower
// MIT License
// Copyright (c) [2022] [Knighttower] https://github.com/knighttower



/**
 * @class Adds some extra functionality to interact with a DOM element
 * @param {String|Object} selector Class or ID or DOM element
 * @param {String} scope The scope to search in, window, document, dom element. Defaults to document
 * @return {Object}
 * @example new ElementHelper('elementSelector')
 * @example new ElementHelper('elementSelector', domElement|window|document)
 *
 */
class ElementHelper {
    /**
     * Constructor
     * @param {String|Object} selector
     * @return {Object}
     */
    constructor(selector, scope = document) {
        this.selector = selector;
        if (typeof selector === 'object') {
            this.domElement = selector;
        } else if (String(selector).includes('//')) {
            this.domElement = this.getElementByXpath(selector);
        } else {
            this.domElement = scope.querySelector(selector);
        }
    }

    // =========================================
    // --> Public
    // --------------------------

    /**
     * Check if the element exists or is visible. It will keep querying
     * @return {Boolean}
     */
    isInDom() {
        return Boolean(this.domElement?.outerHTML);
    }

    /**
     * Wait for element exists or is visible. It will keep querying
     * @function whenInDom
     * @return {Promise}
     */
    whenInDom() {
        let $this = this;
        let callbackId = Date.now() + Math.floor(Math.random() * 1000);

        return new Promise(function (resolveThis) {
            if (!$this.isInDom()) {
                _DomObserver_js__WEBPACK_IMPORTED_MODULE_0__["default"].addOnNodeChange(callbackId, () => {
                    let element = new ElementHelper($this.selector);
                    if (element.isInDom()) {
                        $this = element;
                        resolveThis($this);
                        _DomObserver_js__WEBPACK_IMPORTED_MODULE_0__["default"].removeOnNodeChange(callbackId);
                    }
                });
            } else {
                resolveThis($this);
            }
        });
    }

    /**
     * Find element by Xpath string
     * @param {String} xpath
     * @example getElementByXpath("//html[1]/body[1]/div[1]")
     * @return {Object} DOM element
     */
    getElementByXpath(xpath) {
        return document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
    }

    /**
     * Get the element xpath string
     * @author Based on https://stackoverflow.com/questions/2631820/how-do-i-ensure-saved-click-coordinates-can-be-reload-to-the-same-place-even-if/2631931#2631931
     * @return {String}
     */
    getXpathTo() {
        let element = this.domElement;

        if (element.id) {
            return `//*[@id='${element.id}']`;
        }
        if (element === document.body) {
            return '//' + element.tagName;
        }

        let ix = 0;
        let siblings = element.parentNode.childNodes;
        for (let i = 0; i < siblings.length; i++) {
            let sibling = siblings[i];
            if (sibling === element) {
                return (
                    new ElementHelper(element.parentNode).getXpathTo() + '/' + element.tagName + '[' + (ix + 1) + ']'
                );
            }
            if (sibling.nodeType === 1 && sibling.tagName === element.tagName) {
                ix++;
            }
        }
    }

    /**
     * Get the element attribute, but parse it if it is an object or array
     * @param {String} attr Atrribute name
     * @return {String|Array|Object|Null}
     */
    getAttribute(attr) {
        return this.domElement.getAttribute(attr) || null;
    }

    /**
     * Create a unique has for the element derived from its xpath
     * @author Based on https://www.geeksforgeeks.org/how-to-create-hash-from-string-in-javascript/
     * @return {String}
     */
    getHash() {
        let string = String(this.getXpathTo());
        let hash = 0;

        if (string.length === 0) {
            return hash;
        }

        for (let i = 0; i < string.length; i++) {
            let char = string.charCodeAt(i);
            hash = (hash << 5) - hash + char;
            hash = hash & hash;
        }

        return hash;
    }
}

/**
 * Future
 * @private
 * @todo enhance to extend the prototype like https://stackoverflow.com/questions/779880/in-javascript-can-you-extend-the-dom
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ElementHelper);


/***/ }),

/***/ "./node_modules/@knighttower/js-utility-functions/src/PowerHelpers.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@knighttower/js-utility-functions/src/PowerHelpers.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PowerHelper: () => (/* binding */ powerHelper),
/* harmony export */   addQuotes: () => (/* binding */ addQuotes),
/* harmony export */   cleanStr: () => (/* binding */ cleanStr),
/* harmony export */   convertKeysToSymbols: () => (/* binding */ convertKeysToSymbols),
/* harmony export */   "default": () => (/* binding */ powerHelper),
/* harmony export */   findAndReplaceInArray: () => (/* binding */ findAndReplaceInArray),
/* harmony export */   findNested: () => (/* binding */ findNested),
/* harmony export */   fixQuotes: () => (/* binding */ fixQuotes),
/* harmony export */   getArrObjFromString: () => (/* binding */ getArrObjFromString),
/* harmony export */   getChunks: () => (/* binding */ getChunks),
/* harmony export */   getDirectivesFromString: () => (/* binding */ getDirectivesFromString),
/* harmony export */   getMatchBlock: () => (/* binding */ getMatchBlock),
/* harmony export */   getMatchInBetween: () => (/* binding */ getMatchInBetween),
/* harmony export */   powerHelper: () => (/* binding */ powerHelper),
/* harmony export */   removeQuotes: () => (/* binding */ removeQuotes),
/* harmony export */   setExpString: () => (/* binding */ setExpString),
/* harmony export */   setLookUpExp: () => (/* binding */ setLookUpExp),
/* harmony export */   setWildCardString: () => (/* binding */ setWildCardString),
/* harmony export */   startAndEndWith: () => (/* binding */ startAndEndWith),
/* harmony export */   wildCardStringSearch: () => (/* binding */ wildCardStringSearch)
/* harmony export */ });
/* harmony import */ var _Utility_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utility.js */ "./node_modules/@knighttower/js-utility-functions/src/Utility.js");
// Author Knighttower
// MIT License
// Copyright (c) [2022] [Knighttower] https://github.com/knighttower



// @private
function _removeBrackets(strExp) {
    const regex = /^(\[|\{)(.*?)(\]|\})$/; // Match brackets at start and end
    const match = strExp.match(regex);

    if (match) {
        return match[2].trim(); // Extract and trim the content between brackets
    }

    return strExp; // Return the original string if no brackets found at start and end
}

/**
 * Add quotes to a string
 * @function addQuotes
 * @param {String} str
 * @return {String}
 * @example addQuotes('hello') // "hello"
 */
function addQuotes(str, q = '"') {
    return `${q}${str}${q}`;
}

/**
 * Clean a string from delimeters or just trimmed if no delimeters given
 * @funtion cleanStr
 * @param {String} str - String to use
 * @param {String|Regex} p1 - Delimeter 1
 * @param {String|Regex} p2 - Delimeter 2
 * @return {String|void}
 * @example cleanStr('hello world', 'h', 'd') // 'ello worl'
 * @example cleanStr('  hello world  ') // 'hello world'
 * @example cleanStr('hello world', 'hello') // 'world'
 * @example cleanStr('Hello World. Sunshine is here!', '\..*!') // Hello World
 * @example cleanStr('Hello World. Sunshine is here!', /Hello/g) // ' World. Sunshine is here!'
 * @example cleanStr('Hello World. Sunshine is here!', /Hello/g, /Sunshine/g) // ' World.  is here!'
 */
function cleanStr(str, ...args) {
    if (!str) {
        return;
    }
    if (typeof str !== 'string') {
        return str;
    }

    return args
        .reduce((accStr, arg) => {
            const regex = arg instanceof RegExp ? arg : new RegExp(setExpString(arg));
            return accStr.replace(regex, '');
        }, str)
        .trim();
}

/**
 * convert all keys from an object to symbols
 * @function convertKeysToSymbols
 * @param {object} obj - The object to convert
 * @return {object} - The object with all keys converted to symbols
 * @example convertKeysToSymbols({a: 1, b: 2}) // returns {Symbol(a): 1, Symbol(b): 2, keyToSymbolMap: {a: Symbol(a), b: Symbol(b)}
 */
function convertKeysToSymbols(obj) {
    if ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.emptyOrValue)(obj, null) === null) {
        return {};
    }
    const newObj = {};
    const keyToSymbolMap = {};
    for (const key in obj) {
        const symbolKey = Symbol(key);
        newObj[symbolKey] = obj[key];
        keyToSymbolMap[key] = symbolKey;
    }
    newObj.keyToSymbolMap = keyToSymbolMap;
    return newObj;
}

/**
 * Recursively will loop in array to find the desired target
 * @function findAndReplaceInArray
 * @param {Array} arr
 * @param {String} find The target (needle)
 * @param {Array|Object|String} value Replacer
 * @return {Null|Array}
 * @example findAndReplaceInArray([1,2,3,4,5], 3, 'three') // [1,2,'three',4,5]
 */
function findAndReplaceInArray(arr, find, value) {
    let replaced = false;

    const result = arr.map((prop) => {
        if (Array.isArray(prop)) {
            const replacedArray = findAndReplaceInArray(prop, find, value);
            if (replacedArray) {
                replaced = true;
                return replacedArray;
            }
            return prop;
        }
        if (prop === find) {
            replaced = true;
            if (Array.isArray(value)) {
                return value.map((p) => (Array.isArray(p) ? p : p.trim()));
            }
            return value;
        }
        return prop;
    });

    return replaced ? result : null;
}

/**
 * Find the last instance of nested pattern with delimeters
 * @function findNested
 * @param {string} str
 * @param {string} start - Delimeter 1
 * @param {string} end - Delimeter 2
 * @return {string|null}
 * @example findNested('[[]hello [world]]', '[', ']') // [world]
 */
function findNested(str, start = '[', end = ']') {
    if (typeof str !== 'string') {
        return str;
    }
    // Find the last index of '['
    const lastIndex = str.lastIndexOf(start);
    // If '[' is not found, return null or some default value
    if (lastIndex === -1) {
        return null;
    }

    // Extract the substring starting from the last '[' to the end
    const substring = str.substring(lastIndex);
    // Find the index of the first ']' in the substring
    const endIndex = substring.indexOf(end);
    // If ']' is not found, return null or some default value
    if (endIndex === -1) {
        return null;
    }
    // Extract and return the content between the last '[' and the next ']', including them
    return substring.substring(0, endIndex + 1);
}

/**
 * Fix quotes from a string
 * @function fixQuotes
 * @param {String} str
 * @return {String} q quote type
 * @return {String}
 * @example fixQuotes("'hello'") // "hello"
 * @example fixQuotes('"hello"') // "hello"
 */
function fixQuotes(str, q = '"') {
    if (typeof str !== 'string') {
        return str;
    }
    return str.replace(/`|'|"/g, q);
}

/**
 * Converts strings formats into objects or arrays
 * Note: quoted strings are not supported, use getDirectiveFromString instead
 * @param {string} strExp
 * @return {object|array|string}
 * @example getArrObjFromString('[[value,value],value]') // [['value', 'value'], 'value']
 * @example getArrObjFromString('[[value,value],value, { y: hello }, hello]') // [['value', 'value'], 'value', { y: 'hello' }, 'hello']
 * @example getArrObjFromString('{ y: hello, x: world, z: [value,value]}') // { y: 'hello', x: 'world', z: ['value', 'value'] }
 */
function getArrObjFromString(strExp) {
    // alredy typeof object or array just return it
    if ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.typeOf)(strExp, 'object') || (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.typeOf)(strExp, 'array')) {
        return strExp;
    }
    const isObject = startAndEndWith(strExp, '{', '}');
    const isArray = startAndEndWith(strExp, '[', ']');
    // If it is other type of string, return it
    if (!isObject && !isArray) {
        return strExp;
    }

    const newCollection = isObject ? {} : [];
    const nestedElements = {};

    //remove the brackets
    let newStrExp = _removeBrackets(strExp);

    const loopNested = (objects = false) => {
        // ignore eslint comment
        // eslint-disable-next-line no-constant-condition
        while (true) {
            //find any nested arrays or objects
            let matched = objects ? findNested(newStrExp, '{', '}') : findNested(newStrExp);

            if (!matched) {
                break;
            }

            //replace the nested array or object with a marker so that we can safely split the string
            let marker = `__${(0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.getRandomId)()}__`;
            nestedElements[marker] = matched;

            newStrExp = newStrExp.replace(matched, marker);
        }
    };

    loopNested();
    loopNested(true);

    getChunks(newStrExp).forEach((chunk, index) => {
        const isObjectKey = chunk.includes(':') && isObject;
        const chunkParts = isObjectKey ? getChunks(chunk, ':') : [];
        const chunkKey = removeQuotes((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.emptyOrValue)(chunkParts[0], index));
        chunk = isObjectKey ? chunkParts[1] : chunk;
        if (chunk in nestedElements) {
            chunk = getArrObjFromString(nestedElements[chunk]);
        }
        chunk = (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.convertToNumber)(removeQuotes(chunk));
        // set back in the collection either as an object or array
        isObject ? (newCollection[chunkKey] = chunk) : newCollection.push(chunk);
    });
    // uncomment to debug
    // console.log('___ log ___', newCollection);
    return newCollection;
}

/**
 * handles the following patterns to get an object from string attributes
 * // Matches the JSON objects as string: {'directive':{key:value}} OR {key:value}
 * // Matches the Array as string: [value, value] OR ['value','value']
 * // Matches a multi-array string like [[value,value]],value]
 * // Matches object-style strings: directive.tablet(...values) OR directive[expression](...values)
 * // Matches string ID or class: literals Id(#) or class (.). Note that in Vue it needs to be in quotes attr="'#theId'"
 * // Mathes simple directive function style: directive(#idOr.Class)
 * Note: all the above with the exception of the Id/class will be converted into actual objects
 */
/**
 * Converts strings formats into objects
 * @function getDirectivesFromString
 * @param {String|Array|Object} stringDirective
 * @return {object|null|void}
 * @example getDirectivesFromString('directive.tablet(...values)') // {directive: {tablet: 'values'}}
 * @example getDirectivesFromString('[[value,value],value]') // {directive: 'values', directive2: 'values'}
 * @example getDirectivesFromString('directive.tablet|mobile(...values)') // {directive: {tablet: 'values', mobile: 'values'}}
 * @example getDirectivesFromString('directive.tablet(...values)') // {directive: {tablet: 'values'}}
 */
function getDirectivesFromString(stringDirective) {
    const str = stringDirective;
    if (!(0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.emptyOrValue)(str)) {
        return null;
    }

    const results = (type = null, results = null) => {
        return {
            type: type,
            directive: results,
        };
    };
    const matchArrayTypes = /^\[((.|\n)*?)\]$/gm;
    // comment eslint to ignore
    // eslint-disable-next-line no-useless-escape
    const matchObjectTypes = /^\{((.|\n)*?)\:((.|\n)*?)\}/gm;
    // eslint-disable-next-line no-useless-escape
    const matchFunctionString = /^([a-zA-Z]+)(\()(\.|\#)(.*)(\))/g;
    const regexDotObjectString = /([a-zA-Z]+)\.(.*?)\(((.|\n)*?)\)/gm;
    const regexExObjectString = /([a-zA-Z]+)\[((.|\n)*?)\]\(((.|\n)*?)\)/gm;
    let type = typeof str;

    if (type === 'object' || type === 'array') {
        return results(type, str);
    } else {
        switch (true) {
            case !!str.match(matchArrayTypes):
                // Matches the Array as string: [value, value] OR ['value','value']
                // regexArrayLike = /^\[((.|\n)*?)\]$/gm;
                // Matches a multi-array string like [[value,value]],value]
                // regexMultiArrayString = /\[(\n|)(((.|\[)*)?)\](\,\n|)(((.|\])*)?)(\n|)\]/gm;

                type = 'array';
                break;
            case !!str.match(matchObjectTypes):
                // Matches the JSON objects as string: {'directive':{key:value}} OR {key:value}
                // regexObjectLike = /^\{((.|\n)*?)\:((.|\n)*?)\}/gm;
                type = 'object';
                break;
            case !!str.match(matchFunctionString):
                // Mathes simple directive function style: directive(#idOr.Class)
                // regexFunctionString
                // eslint-disable-next-line
                const directive = str.split('(')[0].trim();
                return results('idOrClassWithDirective', { [directive]: getMatchInBetween(str, '(', ')') });
            case !!str.match(regexDotObjectString):
                // Matches object-style strings: directive.tablet(...values) OR directive[expression](...values)
                // OR directive.breakdown|breakdown2(...values) OR directive.tablet(...values)&&directive.mobile(...values)
                type = 'dotObject';
                break;
            case !!str.match(regexExObjectString):
                type = 'dotObject';
                break;

            default:
                return results('string', str);
        }
    }

    if (type === 'array' || type === 'object') {
        let strQ = fixQuotes(str);
        try {
            return results(type, JSON.parse(strQ));
        } catch (error) {
            // uncomment to debug
            // console.log('___ parse error ___', error);
        }

        return results(type, getArrObjFromString(strQ));
    }

    if (type === 'dotObject') {
        let values, breakDownId, directive;
        const setObject = {};

        getChunks(str, '&&').forEach((command) => {
            if (command.match(regexExObjectString)) {
                // Matches object-style strings: directive[expression](...values)
                values = getMatchInBetween(command, '](', ')');
                breakDownId = getMatchInBetween(command, '[', ']');
                directive = command.split('[')[0].trim();
            } else {
                // Matches object-style strings: directive.tablet(...values)
                values = getMatchInBetween(command, '(', ')');
                command = command.replace(getMatchBlock(command, '(', ')'), '');
                [directive, breakDownId] = getChunks(command, '.');
            }

            values = getArrObjFromString(values);

            if (!setObject[directive]) {
                setObject[directive] = {};
            }

            getChunks(breakDownId, '|').forEach((id) => {
                setObject[directive][id] = values;
            });
        });

        return results('dotObject', setObject);
    }
}

/**
 * Find math by delimeters returns raw matches
 * @function getMatchBlock
 * @param {String} str
 * @param {String|Regex} p1
 * @param {String|Regex} p2
 * @param {Boolean} all If it should return all matches or single one (default)
 * @return {String|Array|Null}
 * @example getMatchBlock('is a hello world today', 'h', 'd') // 'hello world'
 * @example getMatchBlock('is a hello world today', 'h', 'd', true) // ['hello world']
 * @example getMatchBlock('is a <hello world/> today', '<', '/>') // '<hello world/>'
 */
function getMatchBlock(str, p1, p2, all = false) {
    if (typeof str !== 'string') {
        return str;
    }
    p1 = setExpString(p1);
    p2 = setExpString(p2);
    let regex = new RegExp(setLookUpExp(p1, p2), 'gm');
    const matches = str.match(regex);
    if (matches) {
        return all ? matches : matches[0];
    }
    return null;
}
/**
 * Splits a string into chunks by a given splitter and cleans the chunks
 * @param {string} str
 * @param {string} splitter - The string/character to split the string by. Defaults to ','
 * @return {string|array}
 */
function getChunks(str, splitter = ',') {
    if (typeof str !== 'string') {
        return str;
    }
    if ((0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(str)) {
        return [];
    }
    str = cleanStr(str);
    let chunks = str.split(splitter).map((t) => cleanStr(t));
    return chunks.length === 1 && chunks[0] === '' ? [str] : chunks;
}

/**
 * find a match in between two delimeters, either string or regex given, returns clean matches
 * @function getMatchBlock
 * @param {String} str
 * @param {String|Regex} p1
 * @param {String|Regex} p2
 * @param {Boolean} all If it should return all matches or single one (default)
 * @return {String|Array|Null}
 * @example getMatchInBetween('hello world', 'h', 'd') // 'ello worl'
 * @example getMatchInBetween('hello <world/>', '<', '/>', true) // ['world']
 * @example getMatchInBetween('hello <world/>', '<', '/>') // 'world'
 */
function getMatchInBetween(str, p1, p2, all = false) {
    if (typeof str !== 'string') {
        return str;
    }
    const matchBlock = getMatchBlock(str, p1, p2, all) ?? (all ? [] : str);
    return all ? matchBlock.map((match) => cleanStr(match, p1, p2)) : cleanStr(matchBlock, p1, p2);
}

/**
 * Remove quotes from a string
 * @function removeQuotes
 * @param {String} str
 * @return {String}
 * @example removeQuotes('"hello"') // hello
 * @example removeQuotes("'hello'") // hello
 */
function removeQuotes(str) {
    if (typeof str !== 'string') {
        return str;
    }
    return str.replace(/`|'|"/g, '');
}

/**
 * Checks if a string starts and ends with a given string
 * @param {string} strExp
 * @param {string} start - The string/character to check it starts with
 * @param {string} end - The string/character to check it ends with
 * @return {string}
 * @example startAndEndWith('hello world', 'h', 'd') // false
 * @example startAndEndWith('hello world', 'h', 'd') // true
 */
function startAndEndWith(strExp, start = null, end = null) {
    return (!start || strExp.startsWith(start)) && (!end || strExp.endsWith(end));
}

/**
 * Scapes a string to create a regex or returns the regex if it already is an expression
 * @function setExpString
 * @param {String|Regex} exp
 * @return {String|Regex}
 * @example setExpString('hello') // '\h\e\l\l\o'
 * @example setExpString(/hello/) // /hello/
 * @example setExpString([hello]) // \\[hello\\/ then use like new new RegExp(setExpString(StringOrRegex))
 */
function setExpString(exp) {
    if (exp instanceof RegExp) {
        return exp;
    } else {
        return exp
            .split('')
            .map((char) =>
                ['$', '^', '.', '*', '+', '?', '(', ')', '[', ']', '{', '}', '|', '\\'].includes(char)
                    ? `\\${char}`
                    : char,
            )
            .join('');
    }
}

/**
 * Regex builder to get a match in between two delimeters
 * @function setLookUpExp
 * @param {String|Regex} args - minimun two arguments as delimeters
 * @return {String} - Regex
 * @example setLookUpExp('h', 'd') // 'h((.|\n)*?)d'
 * @example setLookUpExp('h', 'd', 'c') // 'h((.|\n)*?)d((.|\n)*?)c'
 * @usage:
 * const pattern = setLookUpExp(".", "!");
const regex = new RegExp(pattern, 'g');
const text = "Hello World. Sunshine is here! Have fun!";
const matches = text.match(regex);
console.log(matches);  // Output: [". Sunshine is here!"]
 */
function setLookUpExp(...args) {
    if (args.length < 2) {
        throw new Error('You need to pass at least two arguments');
    }
    let expression = '';
    // loop through args
    args.forEach((arg, index) => {
        // if arg is a regex, return the source
        if (arg instanceof RegExp) {
            arg = arg.source;
        }
        if (index === 0) {
            expression = arg;
        } else {
            expression += `((.|\n)*?)${arg}`;
        }
    });

    return expression;
}

/**
 * Set a string to be used as a wildcard pattern
 * @function setWildCardString
 * @param {string} string - The string to set as a wildcard pattern
 * @param {boolean} matchStart - If the pattern should match the start of the string
 * @param {boolean} matchEnd - If the pattern should match the end of the string
 * @return {string} - The wildcard pattern
 * @example setWildCardString('name.*', true) // returns '^name\.(.*?)'
 * @example setWildCardString('name.*', false, true) // returns 'name\.(.*?)$'
 * @example setWildCardString('name.**') // returns 'name\..*' greedy
 */
function setWildCardString(str, matchStart = false, matchEnd = false) {
    if (typeof str !== 'string') {
        return str;
    }
    if (!str) {
        return null;
    }
    matchStart = (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.convertToBool)(matchStart);
    matchEnd = (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.convertToBool)(matchEnd);
    // eslint-disable-next-line no-useless-escape
    let regexStr = str.replace(/([.+?^${}()|\[\]\/\\])/g, '\\$&'); // escape all regex special chars
    let regStart = matchStart ? '^' : '';
    let regEnd = matchEnd ? '$' : '';

    regexStr = regexStr
        .replace(/\*\*/g, '[_g_]') // Replace wildcard patterns with temporary markers
        .replace(/\*/g, '(.*?)')
        .replace(/\[_g_\]/g, '.*');

    return `${regStart}${regexStr}${regEnd}`;
}

/**
 * Search for a wildcard pattern in a list of strings or viceversa
 * @method wildCardStringSearch
 * @param {string} pattern - The pattern to search for
 * @param {array|string} list - The list of strings to search in
 * @param {boolean} matchStart - If the pattern should match the start of the string (optional)
 * @param {boolean} matchEnd - If the pattern should match the end of the string optional)
 * @return {string[]|null} - Returns a list of strings that match the pattern, or null if no match is found
 * @example wildCardStringSearch('name.*', ['name.a', 'name.b', 'name.c']) // returns ['name.a', 'name.b', 'name.c']
 */
function wildCardStringSearch(pattern, listOrString, matchStart = false, matchEnd = false) {
    if (!pattern || !listOrString) {
        return null;
    }

    const regex = new RegExp(setWildCardString(pattern, matchStart, matchEnd));

    if (typeof listOrString === 'string') {
        const matches = listOrString.match(regex);
        return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.emptyOrValue)(matches);
    }

    let filteredList = [];
    filteredList = listOrString.filter((item) => regex.test(item));

    return (0,_Utility_js__WEBPACK_IMPORTED_MODULE_0__.emptyOrValue)(filteredList);
}

const powerHelper = {
    addQuotes,
    cleanStr,
    convertKeysToSymbols,
    findAndReplaceInArray,
    findNested,
    fixQuotes,
    getArrObjFromString,
    getChunks,
    getDirectivesFromString,
    getMatchBlock,
    getMatchInBetween,
    removeQuotes,
    startAndEndWith,
    setExpString,
    setLookUpExp,
    setWildCardString,
    wildCardStringSearch,
};

// Export ES6 modules



/***/ }),

/***/ "./node_modules/@knighttower/js-utility-functions/src/ProxyHelper.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@knighttower/js-utility-functions/src/ProxyHelper.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ProxyHelper)
/* harmony export */ });
/* Author Knighttower
    MIT License
    [2023] [Knighttower] https://github.com/knighttower
*/
/**
 * @module ProxyHelper
 * Convert to proxy to protect objects
 * Allows to declare _private, _protected and _mutable - all arrays with prop names
 * @example ProxyHelper({objectProps..., _protected: array(...)})
 * @param {Object} object
 * @return {Proxy}
 * @usage const proxy = ProxyHelper({objectProps..., _protected: array(...), _private: array(...), _mutable: array(...)})
 * @usage _protected: array(...) -> Cannot be modified
 * @usage _private: array(...) -> Cannot be accessed
 * @usage _mutable: array(...) -> Can be modified
 */
function ProxyHelper(object) {
    'use strict';
    const _private = new Map((object._private || ['_private']).map((prop) => [prop, true]));
    const _protected = new Map([..._private, ...(object._protected || []).map((prop) => [prop, true])]);
    const _mutable = new Map((object._mutable || []).map((prop) => [prop, true]));

    return new Proxy(object, {
        get(target, prop) {
            if (prop in target && !_private.has(String(prop))) {
                return target[prop];
            } else {
                console.error('Prop is private, not set, or object is protected', prop);
                return undefined;
            }
        },
        set(target, prop, value) {
            prop = String(prop);
            if (prop in target) {
                if (_mutable.has(prop)) {
                    target[prop] = value;
                    return true;
                }
                if (!_protected.has(prop) && !_private.has(prop)) {
                    target[prop] = value;
                    return true;
                } else {
                    console.error('The prop is protected or private and cannot be modified', prop, value);
                    return false;
                }
            } else {
                console.error('Protected Object, cannot set new props', prop, value);
                return false;
            }
        },
    });
}


/***/ }),

/***/ "./node_modules/@knighttower/js-utility-functions/src/UrlHelper.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@knighttower/js-utility-functions/src/UrlHelper.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ UrlHelper)
/* harmony export */ });
/**
 * URL Object Class with public methods for URL functions and manipulation.
 *
 * @module urlHelper
 */
function UrlHelper(__u) {
    'use strict';

    /**
     * Reference to the global window object.
     * @type {Window}
     */
    const win = window;

    /**
     * Reference to the global document object.
     * @type {Document}
     */
    const doc = document;

    /**
     * Get the host value, check if template head has defined this variable.
     * @type {string|boolean}
     */
    const $H = win.$HOST || false;

    /**
     * Get the template value, check if template head has defined this variable.
     * @type {string|boolean}
     */
    const $TMP = win.$TEMPLATE || false;

    /**
     * Server Protocol.
     * @type {string}
     */
    const PROTOCOL = win.location.protocol.replace(':', '');

    /**
     * Hostname.
     * @type {string}
     */
    const HOST = $H || win.location.host;

    /**
     * Template URL.
     * @type {string}
     */
    const TEMPLATE = $TMP || '';

    /**
     * Current Pathname.
     * @type {string}
     */
    const PATH = location.pathname;

    /**
     * Site URL.
     * @type {string}
     */
    const SITE_URL = $H ? $H : `${PROTOCOL}://${HOST}`;

    /**
     * Full URL.
     * @type {string}
     */
    const FULL_URL = $H ? `${$H}${PATH}` : `${PROTOCOL}://${HOST}${PATH}`;

    /**
     * Cached URL parameters.
     * @type {Object|null}
     */
    let cachedURLParams = null;

    /**
     * Parse and return URL parameters.
     *
     * @return {Object} with params, queryString, search, keys, values, and collection.
     * @private
     */
    const parseURLParams = () => {
        if (cachedURLParams) {
            return cachedURLParams;
        }

        const params = new URLSearchParams(win.location.search);
        const vars = {};

        for (const [key, value] of params.entries()) {
            vars[key] = value;
        }

        cachedURLParams = {
            params,
            queryString: params.toString(),
            search: win.location.search,
            keys: Array.from(params.keys()),
            values: Array.from(params.values()),
            collection: vars,
        };

        return cachedURLParams;
    };

    /**
     * Get the current page name (Last part of the URL).
     *
     * @return {string} Current page name.
     */
    __u.getPage = () => {
        const cURL = doc.location.toString().toLowerCase();
        const page = cURL.split('/').pop().split('.')[0];
        return page || 'index'; // assuming 'index' as the default page name
    };

    /**
     * Get the query object info from the current URL.
     *
     * @return {Object} with params, queryString, search, keys, values, and collection.
     */
    __u.getParams = () => {
        return parseURLParams();
    };

    /**
     * Get the query string from the current URL.
     *
     * @return {string} Query string.
     */
    __u.getQuery = () => {
        return parseURLParams().queryString;
    };

    /**
     * Add params to the current query string from the current URL.
     *
     * @param {Object} query - The query object to add.
     * @return {Object} with collection and queryString.
     */
    __u.addToQuery = (query) => {
        const currentQuery = parseURLParams().collection;
        Object.assign(currentQuery, query);
        const qString = Object.entries(currentQuery)
            .map(([key, value]) => `${key}=${value}`)
            .join('&');

        return {
            collection: currentQuery,
            queryString: qString,
        };
    };

    /**
     * Get only the URL hash.
     *
     * @return {string} Current hash.
     */
    __u.getHash = () => win.location.hash.substring(1);

    /**
     * Set the URL hash.
     *
     * @param {string} h - The hash to set.
     */
    __u.setHash = (h) => {
        doc.location.hash = h;
    };

    /**
     * Remove the URL hash.
     */
    __u.deleteHash = () => {
        history.pushState('', doc.title, win.location.pathname);
    };

    /**
     * Go to a specific URL on the same page.
     *
     * @param {string} url - The URL to go to.
     * @return {boolean} Always returns false to prevent browser default behavior.
     */
    __u.goTo = (url) => {
        win.location.href = url;
        return false;
    };

    /**
     * Open a URL in the browser.
     *
     * @param {string} url - The URL to open.
     * @param {string} [name='_blank'] - The name attribute for the new window.
     * @param {string} [params=''] - The window parameters.
     * @return {Window} The window object of the opened URL.
     */
    __u.open = (url, name = '_blank', params = '') => {
        return win.open(url, name, params);
    };

    /**
     * Execute a function if the current URL changes.
     *
     * @param {function} callback - The callback function to execute.
     */
    __u.onChange = (callback) => {
        if (typeof callback === 'function') {
            win.addEventListener('hashchange', callback);
        }
    };

    // Expose constants
    __u.fullUrl = FULL_URL;
    __u.siteUrl = SITE_URL;
    __u.template = TEMPLATE;
    __u.protocol = PROTOCOL;
    __u.host = HOST;
    __u.path = PATH;
    __u.readUrl = doc.URL;
}


/***/ }),

/***/ "./node_modules/@knighttower/js-utility-functions/src/Utility.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@knighttower/js-utility-functions/src/Utility.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Utility: () => (/* binding */ Utility),
/* harmony export */   convertToBool: () => (/* binding */ convertToBool),
/* harmony export */   convertToNumber: () => (/* binding */ convertToNumber),
/* harmony export */   currencyToDecimal: () => (/* binding */ currencyToDecimal),
/* harmony export */   dateFormat: () => (/* binding */ dateFormat),
/* harmony export */   decimalToCurrency: () => (/* binding */ decimalToCurrency),
/* harmony export */   "default": () => (/* binding */ Utility),
/* harmony export */   emptyOrValue: () => (/* binding */ emptyOrValue),
/* harmony export */   formatPhoneNumber: () => (/* binding */ formatPhoneNumber),
/* harmony export */   getDynamicId: () => (/* binding */ getDynamicId),
/* harmony export */   getGoogleMapsAddress: () => (/* binding */ getGoogleMapsAddress),
/* harmony export */   getRandomId: () => (/* binding */ getRandomId),
/* harmony export */   includes: () => (/* binding */ includes),
/* harmony export */   instanceOf: () => (/* binding */ instanceOf),
/* harmony export */   isEmpty: () => (/* binding */ isEmpty),
/* harmony export */   isNumber: () => (/* binding */ isNumber),
/* harmony export */   openGoogleMapsAddress: () => (/* binding */ openGoogleMapsAddress),
/* harmony export */   proxyObject: () => (/* binding */ proxyObject),
/* harmony export */   selectElement: () => (/* binding */ selectElement),
/* harmony export */   toCurrency: () => (/* binding */ toCurrency),
/* harmony export */   toDollarString: () => (/* binding */ toDollarString),
/* harmony export */   typeOf: () => (/* binding */ typeOf),
/* harmony export */   utility: () => (/* binding */ Utility),
/* harmony export */   utils: () => (/* binding */ Utility),
/* harmony export */   validateEmail: () => (/* binding */ validateEmail),
/* harmony export */   validatePhone: () => (/* binding */ validatePhone)
/* harmony export */ });
/* harmony import */ var _ProxyHelper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ProxyHelper.js */ "./node_modules/@knighttower/js-utility-functions/src/ProxyHelper.js");
/* harmony import */ var _ElementHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ElementHelper.js */ "./node_modules/@knighttower/js-utility-functions/src/ElementHelper.js");
// // -----------------------------------------
// /**
//  * @knighttower
//  * @url knighttower.io
//  * @git https://github.com/knighttower/
//  * @license MIT
//  */
// // -----------------------------------------

// @see https://github.com/knighttower/JsObjectProxyHelper


// @see https://github.com/knighttower/ElementHelper


// -----------------------------
// METHODS
// -----------------------------

/**
 * Convert a value to bool
 * @param {String|Boolean|Int|Number} val
 * @return {Boolean}
 * @usage convertToBool('true') // true
 * @usage convertToBool('false') // false
 * @usage convertToBool('0') // false
 * @usage convertToBool('1') // true
 * @usage convertToBool('') // false
 * @usage convertToBool('true') // true
 * @usage convertToBool('false') // false
 */
function convertToBool(val) {
    switch (typeof val) {
        case 'boolean':
            return val;
        case 'string':
            return val === 'false' || val === '0' ? false : true;
        case 'number':
            return val !== 0;
        default:
            return Boolean(val);
    }
}

/**
 * Converts a given variable to a number if possible.
 * @param {string|number} input - The input variable to convert.
 * @returns {string|number} - The converted number or the original variable.
 * @example convertToNumber(123) // Output: 123 (number)
 * @example convertToNumber(123.45) // Output: 123.45 (number)
 * @example convertToNumber("123") // Output: 123 (number)
 * @example convertToNumber("123.45") // Output: 123.45 (number)
 * @example convertToNumber("abc") // Output: "abc" (original string)
 * @example convertToNumber("123abc") // Output: "123abc" (original string)
 * @example convertToNumber(null) // Output: null (original)
 */
function convertToNumber(input) {
    const isNum = isNumber(input);

    if (isNum !== null) {
        return isNum;
    }
    // Case: String that cannot be converted to a number
    return input;
}

/**
 * Translate dollar amounts to decimal notation
 * @function currencyToDecimal
 * @memberof Utility
 * @param {String|Number} amount
 * @return number
 * @example currencyToDecimal('$123.45') // 123.45
 */
function currencyToDecimal(amount) {
    return Number(amount.replace(/[^0-9.-]+/g, ''));
}

/**
 * Format dates to standard US, with or w/out time
 * @function dateFormat
 * @memberof Utility
 * @param {String} dateTime Raw format 2201-01-01 16:15PM or unix or object
 * @param {Boolean} wTime If set, returns date with time as H:MM A
 * @return string
 * @example dateFormat('2201-01-01 16:15PM') // 01/01/2201
 * @example dateFormat('2201-01-01 16:15PM', true) // 01/01/2201 @ 4:15 PM
 * @example dateFormat('2201-01-01 16:15PM', false) // 01/01/2201
 * @example dateFormat('2201-01-01') // 01/01/2201
 */
function dateFormat(dateTime, wTime) {
    if (!dateTime || isNaN(new Date(dateTime).getTime())) {
        return null;
    }

    const date = new Date(dateTime);

    // Ensuring that the time zone is taken into account.
    const optionsDate = { year: 'numeric', month: '2-digit', day: '2-digit', timeZone: 'UTC' };
    const formattedDate = new Intl.DateTimeFormat('en-US', optionsDate).format(date);

    if (wTime) {
        const optionsTime = { hour: '2-digit', minute: '2-digit', hour12: true, timeZone: 'UTC' };
        const formattedTime = new Intl.DateTimeFormat('en-US', optionsTime).format(date);
        return `${formattedDate} @ ${formattedTime}`;
    }

    return formattedDate;
}

/**
 * Translate decimal notation to dollar amount
 * @function decimalToCurrency
 * @memberof Utility
 * @param {String|Number} amount
 * @return number
 * @example decimalToCurrency(123.45) // 123.45
 * @example decimalToCurrency(2123.46) // 2,123.46
 */
function decimalToCurrency(amount) {
    const formatConfig = {
        minimumFractionDigits: 2,
    };
    return new Intl.NumberFormat('en-GB', formatConfig).format(amount);
}

/**
 * Check if there is a value, if not return null or the default value
 * It can test strings, arrays, objects, numbers, booleans
 * @function emptyOrValue
 * @memberof Utility
 * @param {String|Number} value If the value is not empty, returns it
 * @param {String|Number} _default The default value if empty
 * @return mixed
 * @example emptyOrValue('test', 'default') // 'test'
 * @example emptyOrValue('', 'default') // 'default'
 * @example emptyOrValue('test') // 'test'
 * @example emptyOrValue('') // null
 * @example emptyOrValue(0) // 0
 * @example var hello = ''; emptyOrValue(hello) // Null
 * @example var hello = 'test'; emptyOrValue(hello) // 'test'
 * @example var hello = 'test'; emptyOrValue(hello, 'default') // 'test'
 * @example var hello = ''; emptyOrValue(hello, 'default') // 'default'
 * @example var hello = []; emptyOrValue(hello, 'default') // null
 * @example var hello = {}; emptyOrValue(hello, 'default') // null
 * @example var hello = [...]; emptyOrValue(hello') // [...]
 */
function emptyOrValue(value, _default = null) {
    /**
     * Test sequence:
     * If it is a number 0> : true
     * If is not undefined: true
     * If it is boolean (true|false) prevents going to empty
     * If it is not Empty, [], null, {}, 0, true, false: true
     */

    if (isNumber(value) !== null || typeof value === 'boolean') {
        return value;
    } else if (!isEmpty(value)) {
        return value;
    }

    return _default;
}

/**
 * Format a phone number based on a given template.
 * @param {string} phoneNumber - The phone number to format.
 * @param {string} template - The template to use for formatting.
 * @returns {string} - The formatted phone number.
 * @example console.log(formatPhoneNumber('1234567890', '(000) 000-0000')); // Output: (123) 456-7890
 * @example console.log(formatPhoneNumber('1234567890', '000-000-0000')); // Output: 123-456-7890
 * @example console.log(formatPhoneNumber('123-456-7890', '(000) 000-0000')); // Output: (123) 456-7890
 * @example console.log(formatPhoneNumber('(123) 456-7890', '000-0000-0000')); // Output: 123-4567-890
 */
function formatPhoneNumber(phoneNumber, template) {
    // Remove all non-numeric characters from the phone number
    const cleaned = phoneNumber.replace(/\D/g, '');

    // Verify the length of the cleaned phone number
    if (cleaned.length !== 10) {
        throw new Error('Invalid phone number length');
    }

    // Initialize an array to hold the formatted phone number
    let formatted = [];

    // Initialize a pointer for the cleaned phone number
    let cleanedPointer = 0;

    // Loop through the template and replace placeholders with actual numbers
    for (let i = 0; i < template.length; i++) {
        if (template[i] === '0') {
            formatted.push(cleaned[cleanedPointer]);
            cleanedPointer++;
        } else {
            formatted.push(template[i]);
        }
    }

    return formatted.join('');
}

/**
 * Generate unique ids
 * @function getDynamicId
 * @memberof Utility
 * @return string Format kn__000000__000
 */
function getDynamicId() {
    return 'kn__' + new Date().getTime() + '__' + Math.floor(Math.random() * (999 - 100));
}

/**
 * Alias to getDynamicId
 * @function getRandomId
 * @memberof Utility
 * @return string
 * @example getRandomId() // kn__000000__000
 */
const getRandomId = getDynamicId;

/**
 * Form a valid Google search address
 * @function getGoogleMapsAddress
 * @memberof Utility
 * @param {String|Object} address
 * @return string
 * @example getGoogleMapsAddress('New York') // 'https://maps.google.it/maps?q=New+York'
 * @example getGoogleMapsAddress({ address: 'New York', zip: '10001' }) // 'https://maps.google.it/maps?q=New+York+10001'
 * @example getGoogleMapsAddress({ address: 'New York', city: 'New York', state: 'NY' }) // 'https://maps.google.it/maps?q=New+York+New+York+NY'
 */
function getGoogleMapsAddress(address) {
    if (!address) {
        return false;
    }

    let search = '';

    if (typeOf(address, 'string')) {
        search = address;
    } else {
        const keys = ['address', 'address1', 'city', 'state', 'zip', 'zipcode'];

        search = keys.reduce((acc, key) => {
            const value = Object.keys(address).find((aKey) => aKey.includes(key) && address[aKey]);
            return value ? `${acc} ${address[value]}` : acc;
        }, '');
    }

    search = search.trim().replace(/\s+|,/g, '+');
    return `https://maps.google.it/maps?q=${search}`;
}

/**
 * Check if a value is in a collection (array, string, object)
 * @param {collection} collection - The collection to search in
 * @param {value} value - The value to search for
 * @param {fromIndex} fromIndex - The index to start searching from
 * @return {boolean} - True if the value is in the collection, false otherwise
 */
function includes(collection, value, fromIndex = 0) {
    if (Array.isArray(collection) || typeof collection === 'string') {
        // Use native includes for arrays and strings
        return collection.includes(value, fromIndex);
    }

    if (typeof collection === 'object') {
        // Search in object values
        for (let key in collection) {
            if (collection[key] === value) {
                return true;
            }
        }
    }

    return false;
}

/**
 * Check if a value is empty
 * @function isEmpty
 * @memberof Utility
 * @param {string|array|object|map|set|number|boolean} value
 * @url https://moderndash.io/
 * @return {string}
 */
function isEmpty(value) {
    if (value === null || value === undefined) {
        return true;
    }

    if (typeof value === 'string' || Array.isArray(value)) {
        return value.length === 0;
    }

    if (value instanceof Map || value instanceof Set) {
        return value.size === 0;
    }

    if (ArrayBuffer.isView(value)) {
        return value.byteLength === 0;
    }

    if (typeof value === 'object') {
        return Object.keys(value).length === 0;
    }

    return false;
}

/**
 * Check if is a number or Int, if not return null
 * Integrates both Int and Number, or convert a string number to number to test
 * Note: this is not like Lodash isNumber since this one takes into consideration the 'string number'
 * @function isNumber
 * @memberof Utility
 * @param {String|Number} value
 * @return null|int
 * @example isNumber(123) // true
 * @example isNumber(123.45) // true
 * @example isNumber('123abc') // false
 * @example isNumber('abc') // false
 * @example isNumber('') // false
 * @example isNumber("123") // true
 * @example isNumber("123.45") // true
 */
function isNumber(value) {
    const isType = typeof value;
    switch (value) {
        case null:
        case undefined:
        case '':
            return null;
        case '0':
        case 0:
            return 0;
        default:
            if (isType === 'number' || isType === 'string') {
                if (typeof value === 'number' || !Number.isNaN(Number(value))) {
                    return +value;
                }
            }

            break;
    }

    return null;
}

/**
 * Check the instance of a variable, and get the correct type for it. It also accepts simple comparisons
 * For more advance type checking see https://github.com/knighttower/JsTypeCheck
 * @param {any} input - The variable to check
 * @return {string|boolean} - The type of the variable or boolean when test is provided
 */
function instanceOf(input, test) {
    let inputType = 'unknown';
    if (input === null) {
        return inputType;
    }
    const instanceMapping = [
        {
            type: 'date',
            inst: Date,
        },
        {
            type: 'regexp',
            inst: RegExp,
        },
        {
            type: 'promise',
            inst: Promise,
        },
        {
            type: 'map',
            inst: Map,
        },
        {
            type: 'set',
            inst: Set,
        },
        {
            type: 'weakMap',
            inst: WeakMap,
        },
        {
            type: 'weakSet',
            inst: WeakSet,
        },
    ];
    let instTotal = instanceMapping.length;
    while (instTotal--) {
        if (input instanceof instanceMapping[instTotal].inst) {
            inputType = instanceMapping[instTotal].type;
            break;
        }
    }

    if (test) {
        return test === inputType;
    }

    return inputType;
}

/**
 * Open a Google Map using a provided address
 * @function openGoogleMapsAddress
 * @memberof Utility
 * @param {String|Object} object - Address information either as a string or as an object
 * @throws {Error} Throws an error if the address is invalid or if it's not a string or object.
 * @return {void}
 * @example openGoogleMapsAddress('New York'); // Opens Google Maps with the address 'New York'
 * @example openGoogleMapsAddress({ address: 'New York', zip: '10001' }); // Opens Google Maps with the address 'New York 10001'
 */
function openGoogleMapsAddress(object) {
    if (!typeOf(object, 'string') || !typeOf(object, 'object')) {
        throw new Error('The input must be a string or an object.');
    }

    const address = getGoogleMapsAddress(object);

    if (!isEmpty(address) || !typeOf(address, 'string')) {
        throw new Error('The address you are trying to open is invalid.');
    }

    return window.open(address, '_blank');
}

/**
 * @example ProxyHelper({objectProps..., _protected: array(...)})
 * @param {Object} object
 * @return {Proxy}
 * @usage const proxy = ProxyHelper({objectProps..., _protected: array(...), _private: array(...), _mutable: array(...)})
 * @usage _protected: array(...) -> Cannot be modified
 * @usage _private: array(...) -> Cannot be accessed
 * @usage _mutable: array(...) -> Can be modified
 */
function proxyObject(obj) {
    return (0,_ProxyHelper_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj);
}

/**
 * Dom Element selector
 * @function selectElement
 * @param {String} selector - The selector to search for
 * @param {Object} scope - The scope to search in
 * @return {String} - The first element that matches the selector
 * @uses ElementHelper @knighttower/element-helper (https://github.com/knighttower/ElementHelper)
 * @example selectElement('#test') // <div id="test"></div>
 */
function selectElement(selector, scope = document) {
    return new _ElementHelper_js__WEBPACK_IMPORTED_MODULE_1__["default"](selector, scope);
}

/**
 * Alias to getDynamicId
 * @function toCurrency
 * @memberof Utility
 * @param {String|Number} amount
 * @return number
 * @example toCurrency(123.45) // 123.45
 * @example toCurrency(2123.46) // 2,123.46
 */
function toCurrency(amount) {
    return decimalToCurrency(amount);
}

/**
 * Covert to dollar string
 * @function toDollarString
 * @memberof Utility
 * @param {String|Number} amount
 * @return number
 * @example toDollarString(2,000) // 2K
 * @example toDollarString(2,000,000) // 2M
 * @example toDollarString(2,500,000) // 2.5M
 */
function toDollarString(amount) {
    if (typeOf(amount, 'string')) {
        amount = currencyToDecimal(amount);
    }

    if (Math.abs(amount) > 999 && Math.abs(amount) < 999999) {
        return Math.sign(amount) * (Math.abs(amount) / 1000).toFixed(1) + 'K';
    }
    if (Math.abs(amount) > 999999) {
        return Math.sign(amount) * (Math.abs(amount) / 1000000).toFixed(1) + 'M';
    }

    return Math.sign(amount) * Math.abs(amount);
}

/**
 * Check the type of a variable, and get the correct type for it. It also accepts simple comparisons
 * For more advance type checking see https://github.com/knighttower/JsTypeCheck
 * @param {any} input - The variable to check
 * @param {string} test - The types to check against, piped string
 * @return {string|boolean} - The type of the variable
 * @example typeOf('hello', 'string') // returns true
 * @example typeOf('hello', 'number') // returns false
 * @example typeOf('hello', 'string') // returns true
 * @example typeOf('hello') // returns 'string'
 * @example typeOf({}) // returns 'object'
 */
function typeOf(input, test) {
    // Special case for null since it can be treated as an object
    if (input === null) {
        if (test) {
            return test === null || test === 'null' ? true : false;
        }
        return 'null';
    }

    let inputType;

    switch (typeof input) {
        case 'number':
        case 'string':
        case 'boolean':
        case 'undefined':
        case 'bigint':
        case 'symbol':
        case 'function':
            inputType = typeof input;
            break;
        case 'object':
            inputType = Array.isArray(input) ? 'array' : 'object';

            break;
        default:
            inputType = 'unknown';
    }

    if (test) {
        return test === inputType;
    }

    return inputType;
}

/**
 * Validate emails
 * @function validateEmail
 * @memberof Utility
 * @param {String} email
 * @return Boolean
 * @example validateEmail('<EMAIL>') // false
 * @example validateEmail('test@test') // false
 * @example validateEmail('test@test.') // false
 * @example validateEmail('test@test.c') // false
 * @example validateEmail('test@test.com') // true
 */
function validateEmail(email) {
    var emailRegex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}$/;
    return emailRegex.test(email);
}

/**
 * Validate a phone number
 * @function validatePhone
 * @memberof Utility
 * @param {String} phone
 * @return void|Toast
 * @example validatePhone('1234567890') // true
 * @example validatePhone('(123) 456-7890') // true
 * @example validatePhone('123-456-7890') // true
 * @example validatePhone('123 456 7890') // false
 * @example validatePhone('123-4567-89') // false
 */
function validatePhone(phone) {
    var phoneRegex = /^\(?(\d{3})\)?[- ]?(\d{3})[- ]?(\d{4})$/;
    return phoneRegex.test(phone);
}

// export default Utility;
const Utility = {
    convertToBool,
    currencyToDecimal,
    convertToNumber,
    dateFormat,
    decimalToCurrency,
    emptyOrValue,
    formatPhoneNumber,
    getDynamicId,
    getGoogleMapsAddress,
    getRandomId,
    includes,
    isEmpty, // from https://moderndash.io/
    isNumber,
    instanceOf,
    openGoogleMapsAddress,
    proxyObject,
    selectElement,
    toCurrency,
    toDollarString,
    typeOf,
    validateEmail,
    validatePhone,
};

// Export ES6 modules



/***/ }),

/***/ "./node_modules/@knighttower/type-check-js/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@knighttower/type-check-js/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _tc: () => (/* reexport safe */ _src_TypeCheck_js__WEBPACK_IMPORTED_MODULE_1__._tc),
/* harmony export */   _tcx: () => (/* reexport safe */ _src_TypeCheck_js__WEBPACK_IMPORTED_MODULE_1__._tcx),
/* harmony export */   addTypeTest: () => (/* reexport safe */ _src_TestBuilder_js__WEBPACK_IMPORTED_MODULE_0__.addTypeTest),
/* harmony export */   testBuilder: () => (/* reexport safe */ _src_TestBuilder_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   typeCheck: () => (/* reexport safe */ _src_TypeCheck_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   typesMap: () => (/* reexport safe */ _src_types_js__WEBPACK_IMPORTED_MODULE_2__.typesMap),
/* harmony export */   validType: () => (/* reexport safe */ _src_TypeCheck_js__WEBPACK_IMPORTED_MODULE_1__.validType)
/* harmony export */ });
/* harmony import */ var _src_TestBuilder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/TestBuilder.js */ "./node_modules/@knighttower/type-check-js/src/TestBuilder.js");
/* harmony import */ var _src_TypeCheck_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/TypeCheck.js */ "./node_modules/@knighttower/type-check-js/src/TypeCheck.js");
/* harmony import */ var _src_types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/types.js */ "./node_modules/@knighttower/type-check-js/src/types.js");
// Single Modules and Aliases from: TestBuilder

// Default Module from: TestBuilder

// Single Modules and Aliases from: TypeCheck

// Default Module from: TypeCheck

// Single Modules and Aliases from: types


 

/***/ }),

/***/ "./node_modules/@knighttower/type-check-js/src/TestBuilder.js":
/*!********************************************************************!*\
  !*** ./node_modules/@knighttower/type-check-js/src/TestBuilder.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addTypeTest: () => (/* binding */ addTypeTest),
/* harmony export */   "default": () => (/* binding */ testBuilder),
/* harmony export */   testBuilder: () => (/* binding */ testBuilder)
/* harmony export */ });
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.js */ "./node_modules/@knighttower/type-check-js/src/types.js");
/* harmony import */ var _knighttower_js_utility_functions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @knighttower/js-utility-functions */ "./node_modules/@knighttower/js-utility-functions/index.js");
//  type definitions



('use strict');

// =========================================
// --> STORAGE
// --------------------------
// Cache storage for tests
const cachedTests = new Map();
const cachedPipedTypes = new Map();

// =========================================
// --> Utility functions
// --------------------------

/**
 * If the type is a union type, split it and return the tests for each type
 * @param {string} str
 * @return {array} tests
 */
function getPipedTypes(str) {
    if (cachedPipedTypes.has(str)) {
        return cachedPipedTypes.get(str);
    }
    return str.split('|').reduce((testsForKey, t) => {
        let itCanBeNull = false;
        let type = t.trim();

        if (type.endsWith('?')) {
            type = type.slice(0, -1);
            itCanBeNull = true;
        }
        // lookup the test for the type and add it to the testsForKey array
        const typeObj = _types_js__WEBPACK_IMPORTED_MODULE_0__.typesMap.get(type);
        const test = typeObj ?? isNoType(type);
        if (test) {
            testsForKey.push(test);
        }
        // for optional types, add the tests for null and undefined
        if (itCanBeNull) {
            testsForKey.push(_types_js__WEBPACK_IMPORTED_MODULE_0__.typesMap.get('null'), _types_js__WEBPACK_IMPORTED_MODULE_0__.typesMap.get('undefined'));
        }
        cachedPipedTypes.set(str, testsForKey);
        return testsForKey;
    }, []);
}

/**
 * Get the tests for a type
 * @param {string} type
 * @return {function[]} tests
 * @throws {Error} if type is not supported
 */
function isNoType(type) {
    throw new Error(`Type Error: "${type}" is not supported`);
}

/**
 * Determine the type of the expression
 * @param {any} strExp
 * @return {string}
 */
function determineMethod(strExp) {
    if ((0,_knighttower_js_utility_functions__WEBPACK_IMPORTED_MODULE_1__.typeOf)(strExp, 'array') || (0,_knighttower_js_utility_functions__WEBPACK_IMPORTED_MODULE_1__.typeOf)(strExp, 'object')) {
        return (0,_knighttower_js_utility_functions__WEBPACK_IMPORTED_MODULE_1__.typeOf)(strExp);
    }
    const __str = strExp.trim();
    if ((0,_knighttower_js_utility_functions__WEBPACK_IMPORTED_MODULE_1__.startAndEndWith)(__str, '[', ']')) {
        return 'array';
    }
    if ((0,_knighttower_js_utility_functions__WEBPACK_IMPORTED_MODULE_1__.startAndEndWith)(__str, '{', '}')) {
        return 'object';
    }
    return 'basic';
}

// =========================================
// --> Handlers for different types
// --------------------------

/**
 * Basic single types
 * @param {string} typeStr
 * @return {object} tests
 */
const basicTypes = (typeStr) => {
    return getPipedTypes(typeStr);
};

/**
 * Handle array types
 * @param {string} strExp
 * @return {array} tests
 */
const arrayTypes = (strExp) => {
    const testUnit = [];
    const convertedObj = (0,_knighttower_js_utility_functions__WEBPACK_IMPORTED_MODULE_1__.getArrObjFromString)(strExp);

    convertedObj.forEach((test) => {
        testUnit.push(testBuilder(test));
    });
    return testUnit;
};

/**
 * Handle object types
 * @param {string} strExp
 * @return {object} tests
 */
const objectTypes = (strExp) => {
    return new (class handleObjects {
        constructor() {
            this.testUnit = new Map([
                ['tests', new Map()],
                ['optionalKeys', []],
                ['testFew', []],
                ['testAllAny', false],
                ['testOnly', false],
            ]);

            return this.handleObject();
        }

        checkOptionalKey(key) {
            if (key.endsWith('?')) {
                key = key.slice(0, -1);
                this.testUnit.get('optionalKeys').push(key);
            }
            return key;
        }

        checkTheAnyKey(obj) {
            if ('any' in obj) {
                const keys = Object.keys(obj);
                if (keys.length === 1) {
                    this.testUnit.set('testAllAny', true);
                } else {
                    this.testUnit.set(
                        'testFew',
                        keys.filter((key) => key !== 'any'),
                    );
                }
            }
        }

        handleObject() {
            const convertedObj = (0,_knighttower_js_utility_functions__WEBPACK_IMPORTED_MODULE_1__.getArrObjFromString)(strExp);
            this.checkTheAnyKey(convertedObj);
            for (const key in convertedObj) {
                const cleanKey = this.checkOptionalKey(key);
                const value = convertedObj[key];

                if (value === '...') {
                    delete convertedObj[key];
                    this.testUnit.set('testOnly', true);
                    continue;
                }

                this.testUnit.get('tests').set(cleanKey, testBuilder(value));
            }

            return this.testUnit;
        }
    })();
};

/**
 * Build the test unit
 * @param {any} strExp String expression
 * @return {object} testUnit
 * @throws {Error} if type is not supported
 * @example testBuilder('number') // returns {testMethod: 'basic', tests: [function]}
 * @example testBuilder('[number]') // returns {testMethod: 'array', tests: [[function]]}
 * @example testBuilder('{any: number}') // returns {testMethod: 'object', tests: {any: [function]}}
 * @usage See more cases in the 'type-pattern.txt' file
 */
function testBuilder(strExp) {
    if (cachedTests.has(strExp)) {
        return cachedTests.get(strExp);
    }
    let testUnit = new Map([
        ['testMethod', determineMethod(strExp)],
        ['tests', null],
    ]);

    switch (testUnit.get('testMethod')) {
        case 'basic':
            testUnit.set('tests', basicTypes(strExp));
            break;
        case 'array':
            testUnit.set('tests', arrayTypes(strExp));
            break;
        case 'object':
            /* eslint-disable-next-line */
            const objTypes = objectTypes(strExp);
            testUnit = new Map([...testUnit, ...objTypes]);
            break;
        default:
            isNoType(strExp);
    }

    cachedTests.set(strExp, testUnit);
    return testUnit;
}

/**
 * Add a new type test
 * @param {string} name The name of the test to add
 * @param {function} testUnit The test function
 * @return {boolean} true if the test was added
 * @throws {Error} if the test already exists
 */
const addTypeTest = (name, testUnit) => {
    if (!_types_js__WEBPACK_IMPORTED_MODULE_0__.typesMap.has(name)) {
        _types_js__WEBPACK_IMPORTED_MODULE_0__.typesMap.set(name, testUnit);
        return true;
    }

    throw new Error(`Type Error: "${name}" already exists`);
};




/***/ }),

/***/ "./node_modules/@knighttower/type-check-js/src/TypeCheck.js":
/*!******************************************************************!*\
  !*** ./node_modules/@knighttower/type-check-js/src/TypeCheck.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TypeCheck: () => (/* binding */ typeCheck),
/* harmony export */   _tc: () => (/* binding */ _tc),
/* harmony export */   _tcx: () => (/* binding */ _tcx),
/* harmony export */   "default": () => (/* binding */ typeCheck),
/* harmony export */   typeCheck: () => (/* binding */ typeCheck),
/* harmony export */   validType: () => (/* binding */ validType)
/* harmony export */ });
/* harmony import */ var _knighttower_js_utility_functions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @knighttower/js-utility-functions */ "./node_modules/@knighttower/js-utility-functions/index.js");
/* harmony import */ var _TestBuilder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TestBuilder.js */ "./node_modules/@knighttower/type-check-js/src/TestBuilder.js");



// Error collectot
const typeErrorLogs = [];
// Setting cache
const cachedSettings = new Map();

const runBasicTest = (inputVal, tests) => {
    return tests.some((test) => {
        const testResult = test(inputVal);
        if (!testResult) {
            typeErrorLogs.push({ value: inputVal, tests: tests });
        }
        return testResult;
    });
};

const runArrayTest = (inputVal, tests) => {
    // If the input is not an array, return false
    if (!(0,_knighttower_js_utility_functions__WEBPACK_IMPORTED_MODULE_0__.typeOf)(inputVal, 'array')) {
        return false;
    }
    // Else, test each value in the array
    return tests.every((test, index) => {
        // console.log('is array: ', inputVal[index], test);
        return runRouteTest(inputVal[index], test);
    });
};

class HandleObjects {
    constructor(inputVal, unitTest) {
        // Extract all properties at once
        const { testOnly, testFew, testAllAny, optionalKeys, tests } = [...unitTest.entries()].reduce(
            (acc, [key, value]) => ({ ...acc, [key]: value }),
            {},
        );
        // Use destructured variables
        this.testUnitKeys = [...tests.keys()];
        this.testOnly = testOnly;
        this.testFew = testFew;
        this.testAllAny = testAllAny;
        this.optionalKeys = optionalKeys;
        this.testCollection = tests;
        // the input object to test
        this.inputObject = inputVal;
    }

    handleUnitTest() {
        switch (true) {
            case this.testAllAny:
                // '{any: type}' // any key
                return this.testObjAllAny();
            case !(0,_knighttower_js_utility_functions__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(this.testFew):
                // '{key1: type, any: type}'; // specific key, and all other "any"
                // test the testFew fist so that we can remove them from the inputObject
                /* eslint-disable-next-line */
                const testFewResults = this.testObjFew();
                // remove the testFew from the inputObject
                this.filterOutFew();
                return testFewResults && this.testObjAllAny();
            case !(0,_knighttower_js_utility_functions__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(this.optionalKeys):
                // '{key1?: type, key2?: type}'; // optional keys
                // test the optionalKeys fist so that we can remove them from the inputObject
                /* eslint-disable-next-line */
                const optionalKeysResults = this.testObjOptionalKeys();
                // remove the optionalKeys from the inputObject
                this.filterOutOptionalKeys();
                return optionalKeysResults && this.defaultTest();
            case !this.testOnly:
                // '{key1: type, key2: type}'; // all keys
                for (const k in this.inputObject) {
                    if (!this.testCollection.has(k)) {
                        return false;
                    }
                }
                // when testOnly it will bypass this and check only those found in the test collection
                // even if the test value has more keys
                break;
        }

        return this.defaultTest();
    }

    filterOutOptionalKeys() {
        this.testUnitKeys = this.testUnitKeys.filter((item) => !this.optionalKeys.includes(item));
    }

    filterOutFew() {
        this.inputObject = Object.fromEntries(
            Object.entries(this.inputObject).filter(([key]) => !this.testFew.includes(key)),
        );
    }

    testObjOptionalKeys() {
        return this.optionalKeys.every((key) => {
            const test = this.testCollection.get(key);
            const testValue = this.inputObject[key];
            return !testValue ? true : runRouteTest(testValue, test);
        });
    }

    testObjFew() {
        return this.testFew.every((key) => {
            const test = this.testCollection.get(key);
            const testValue = this.inputObject[key];

            return runRouteTest(testValue, test);
        });
    }

    testObjAllAny() {
        return Object.values(this.inputObject).every((value) => {
            return runRouteTest(value, this.testCollection.get('any'));
        });
    }

    defaultTest() {
        return this.testUnitKeys.every((key) => {
            const test = this.testCollection.get(key);
            const testValue = this.inputObject[key];
            return runRouteTest(testValue, test);
        });
    }
}

const runObjectTest = (inputVal, unitTest) => {
    if (!(0,_knighttower_js_utility_functions__WEBPACK_IMPORTED_MODULE_0__.typeOf)(inputVal, 'object')) {
        return false;
    }
    return new HandleObjects(inputVal, unitTest).handleUnitTest();
};

function runRouteTest(inputVal, unitTest) {
    const testMethod = unitTest.get('testMethod');
    const tests = unitTest.get('tests');

    switch (testMethod) {
        case 'basic':
            return runBasicTest(inputVal, tests);
        case 'array':
            return runArrayTest(inputVal, tests);
        case 'object':
            return runObjectTest(inputVal, unitTest); // No change here as the entire Map is passed
        default:
            return false;
    }
}

/**
 * Get settings either from an object or a string keyword.
 * @param {Object | string} input - The settings object or keyword for predefined settings.
 * @return {object | null} - The settings object.
 */
function getSettings(input) {
    if (input) {
        if (cachedSettings.has(input)) {
            return cachedSettings.get(input);
        }
        // Check if input is an object
        const type = typeof input;
        let _val = null;
        switch (type) {
            case 'function':
                _val = { callback: input };
                break;
            case 'object':
                _val = input;
                break;
            case 'string':
                switch (input) {
                    case 'log':
                        _val = { log: true };
                        break;
                    case 'fail':
                        _val = { fail: true };
                        break;
                    case 'return':
                        _val = { return: true };
                        break;
                    case 'validOutput':
                        _val = { validOutput: input };
                        break;
                }
                break;
        }
        cachedSettings.set(input, _val);
        return _val;
    }

    return {
        log: false,
        fail: false,
        return: false,
        validOutput: false,
        callback: null,
    };
}

/**
 * Throw an error with the last typeErrorLogs
 */
function typeError() {
    const errorLog = typeErrorLogs[typeErrorLogs.length - 1];
    console.log(typeErrorLogs);
    //clean the array of error logs
    typeErrorLogs.length = 0;
    throw new Error(`Type Error: "${errorLog.value}" is not valid, see log console for details`);
}

/**
* TypeCheck
* @param {string} typeExp
* @param {any} inputVal
* @param {object | string} params Parameters for the typeCheck function. 
* @return {bool | any} TypeChecker By default it returns boolean, but if '.return()' is used it will return the inputVal
* @example typeCheck('number', 1) // true
* @example typeCheck('[number]', [1]) // true
* @example typeCheck('{any: number}', {x: 1, y: 2}) // true
* @example typeCheck('{y: number, x: string}', { x: 'string', y: 10 }, ($this) => {
        console.log('__testLogHere__', $this);
    }) // using call back function
* @usage (stringTypeExpression, anyInputValue, params: object | string)
* @usage params: object = { log: boolean, fail: boolean, callback: function }
* @usage params: string = 'log' | 'fail' | callback: function
* @usage chain Methods: log(), fail(), return() // returns the input value, test() returns the boolean
* @notes This function cannot validate the return value of a function when the validOutput is provided, use _tcx instead
* Params: log = true ; // logs the testData
* Params: fail = true ; // throws an error when the test fails
* Params: return = true ; // returns the inputVal
* Params: callback = function ; // callback function
* @see testUnit for more examples and test cases   
*/
const typeCheck = (typeExp, inputVal, params) => {
    return new (class {
        constructor() {
            this.unitTest = (0,_TestBuilder_js__WEBPACK_IMPORTED_MODULE_1__["default"])(typeExp);
            this.testResult = runRouteTest(inputVal, this.unitTest);
            this.bool = this.testResult;
            this.settings = getSettings(params);
            this.callback = this.settings.callback ?? null;
            this.testData = {
                typeExp,
                inputVal,
                callback: this.callback,
                unitTest: this.unitTest,
                testResult: this.testResult,
            };
            if (this.settings.log) {
                this.log();
            }

            if (this.settings.fail) {
                this.fail();
            }

            if (this.callback) {
                this.callback(this.testData);
            }
        }
        test() {
            return this.testResult;
        }
        log() {
            console.table(this.testData);
            return this;
        }
        fail() {
            if (!this.testResult) {
                return typeError();
            }
            return this;
        }
        return() {
            return inputVal;
        }
    })();
};

/**
* _tc is a helper function to wrap a function with typeCheck
* It is basic but faster the _tcx (neglible but if micro-optimization is needed)
* @param {string} typeExp Expression to test
* @param {function} __function Function to wrap
* @param {object | string} params Parameters for the typeCheck function.
* @return {function} Wrapped function
* @example _tc('[number]', function (myVar) {
        //code
        console.log(myVar);
    });
* @usage (stringTypeExpression, Function(), params: object | string)
* @usage params: object = { log: boolean, fail: boolean, return: boolean, validOutput: string }
* @usage params: string = 'log' | 'fail' | 'return' 
* @notes this function does not accept callback arguments and when using shorthand arguments (string) it does not accept validOutput
* Params: log = true ; // logs the testData
* Params: fail = true ; // throws an error when the test fails
* Params: return = true ; // returns the inputVal
* Params: callback = function ; // callback function
* @see directory test for more information and examples
*/
const _tc = (typeExp, __function, params) => {
    return (...args) => {
        typeCheck(typeExp, args, params);
        return __function(...args);
    };
};

/**
* _tcx is a helper function to wrap a function with typeCheck
* It is as performant as the _tc but it has a lot more features to offer
* @param {string} typeExp Expression to test
* @param {function} __function Function to wrap
* @param {object | string} params Parameters for the typeCheck function. 
* @return {function} Wrapped function
* @example _tcx('[number]', function (myVar) {
        //code
        console.log(myVar);
    });
* @usage (stringTypeExpression, Function(), params: object | string)
* @usage params: object = { log: boolean, fail: boolean, return: boolean, validOutput: stringTypeExpression }
* @usage params: string = 'log' | 'fail' | 'return'
* @notes This function can validate the return value of a function when the validOutput is provided
* @feature Return value validation
* @feature all instances accept individual fail, log, and return
* @feature all instances accept chaining parameters: myCoolFunction(44.5, 'yes!').log().fail().return()
* Params: log = true ; // logs the testData
* Params: fail = true ; // throws an error when the test fails
* Params: return = true ; // returns the inputVal
* Params: callback = function ; // callback function
* Params: validOutput = stringTypeExpression ; // validate the return value of the function
* @see directory test for more information and examples
*/
const _tcx = (typeExp, __function, params) => {
    const $settings = getSettings(params);

    return (...args) => {
        return new (class {
            constructor() {
                this.args = args;
                this.testResults = typeCheck(typeExp, args, $settings);
                return this.default();
            }
            default() {
                this.returns = __function(...args);

                const validOutput = $settings.validOutput ?? false;
                if (validOutput) {
                    typeCheck(validOutput, this.returns, 'fail');
                }
                return this;
            }
            log() {
                this.testResults.log();
                return this;
            }
            fail() {
                this.testResults.fail();
                return this;
            }
            return() {
                return this.returns;
            }
        })();
    };
};

/**
 * validType is a helper function to quick validate a value with a type expression, is a wrapper for typeCheck with less optional arguments
 * @param {string} typeExp Expression to test
 * @param {any} inputVal Value to test
 * @return {bool} isValidType
 * @example validType('[number]', 1) // true
 * @example validType('[number]', 'str') // false - throws exception
 * @usage (stringTypeExpression, anyInputValue)
 * @usage returns boolean
 * @see directory test for more information and examples
 */
const validType = (typeExp, inputVal) => {
    return typeCheck(typeExp, inputVal).fail().test();
};




/***/ }),

/***/ "./node_modules/@knighttower/type-check-js/src/types.js":
/*!**************************************************************!*\
  !*** ./node_modules/@knighttower/type-check-js/src/types.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   typesMap: () => (/* binding */ typesMap)
/* harmony export */ });
/* harmony import */ var _knighttower_js_utility_functions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @knighttower/js-utility-functions */ "./node_modules/@knighttower/js-utility-functions/index.js");
// typeOf is used here insteand of the native typeof because it can handle better the identifications of arrays and objects


const typesMap = new Map([
    ['array', (_var_) => (0,_knighttower_js_utility_functions__WEBPACK_IMPORTED_MODULE_0__.typeOf)(_var_, 'array')],
    ['bigInt', (_var_) => typeof _var_ === 'bigint'],
    ['boolean', (_var_) => typeof _var_ === 'boolean'],
    ['date', (_var_) => _var_ instanceof Date],
    ['float', (_var_) => typeof _var_ === 'number' && !Number.isInteger(_var_)],
    ['function', (_var_) => typeof _var_ === 'function'],
    ['int', (_var_) => Number.isInteger(_var_)],
    ['map', (_var_) => _var_ instanceof Map],
    ['null', (_var_) => _var_ === null],
    ['number', (_var_) => typeof _var_ === 'number'],
    ['object', (_var_) => (0,_knighttower_js_utility_functions__WEBPACK_IMPORTED_MODULE_0__.typeOf)(_var_, 'object')],
    ['promise', (_var_) => _var_ instanceof Promise],
    ['regExp', (_var_) => _var_ instanceof RegExp],
    ['set', (_var_) => _var_ instanceof Set],
    ['string', (_var_) => typeof _var_ === 'string'],
    ['symbol', (_var_) => typeof _var_ === 'symbol'],
    ['undefined', (_var_) => typeof _var_ === 'undefined'],
    ['weakMap', (_var_) => _var_ instanceof WeakMap],
    ['weakSet', (_var_) => _var_ instanceof WeakSet],
]);


/***/ }),

/***/ "./src/QueryHandler.js":
/*!*****************************!*\
  !*** ./src/QueryHandler.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _readOnlyError(name) { throw new TypeError("\"" + name + "\" is read-only"); }
// Author Knighttower
// MIT License
// Copyright (c) [2022] [Knighttower] https://github.com/knighttower

/**
 * @class Detect DOM changes
 * @param {window} selector
 * @param {Funtion}
 * @return QueryHandler
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function QueryHandler() {
  'use strict';
  var $window = typeof window !== 'undefined' ? window : {};
  /**
   * Query Handler Class Object
   * @private
   * @return {Object}
   */
  var $this = {};
  var QueryHandler = new Proxy($this, {
    get: function get(target, prop, receiver) {
      if (prop in target) {
        return target[prop];
      }
    }
  });

  /**
   * Holds memory of registered queries expressions
   * @private
   */
  var registeredQueries = {};

  /**
   * Holds memory of registered queries to match
   * @private
   */
  var domQueriesMatch = {};

  /**
   * Holds memory of registered queries to Unmatch
   * @private
   */
  var domQueriesUnMatch = {};

  /**
   * Flag
   * @private
   */
  var loaded = false;

  // =========================================
  // --> PUBLIC
  // --------------------------

  /**
   * Register a query
   * @param {Object} queries Media queries with breakdowns and directives
   * @param {Function} matchCallback Callback
   * @param {Function|Null} unMatchCallback Callback
   * @param {Object|Null} Adaptive When in use with Adaptive.js object
   * @return {Void}
   */
  $this.add = function (queries, matchCallback) {
    var unMatchCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var Adaptive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    for (var query in queries) {
      var _getPreset;
      // Values are the classes, styles, functions
      var values = queries[query];

      // Set a preset if found or just the query in case is custom
      var queryExpression = (_getPreset = getPreset(query, Adaptive)) !== null && _getPreset !== void 0 ? _getPreset : query;

      // If it does not exists, add it as an array
      if (!Boolean(domQueriesMatch[queryExpression])) {
        domQueriesMatch[queryExpression] = [];
        domQueriesUnMatch[queryExpression] = [];
      }
      domQueriesMatch[queryExpression].push([matchCallback, values]);
      if (unMatchCallback) {
        domQueriesUnMatch[queryExpression].push([unMatchCallback, values]);
      }
      registerQueryListener(queryExpression);
    }
  };

  /**
   * Remove items from domQueriesMatch based on value and prop.
   *
   * @param {any} value - The value to be removed.
   * @param {string} prop - The property to look up in the object.
   */
  $this.remove = function (value, prop) {
    for (var _i = 0, _Object$entries = Object.entries(domQueriesMatch); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
        expression = _Object$entries$_i[0],
        collection = _Object$entries$_i[1];
      var _iterator = _createForOfIteratorHelper(collection),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var reg = _step.value;
          var type = _typeof(reg[1]);
          // LookUp by the prop value when the second array element is an object
          if (prop && type === 'object') {
            if (prop in reg[1] && reg[1][prop] === value) {
              console.log(domQueriesMatch[expression]);
              domQueriesMatch[expression] = domQueriesMatch[expression].filter(function (o) {
                return o[1][prop] !== value;
              });
            }
            // LookUp by the value (function) and prop when the second array element is a string
          } else if (type === 'string' && reg[1] === prop) {
            domQueriesMatch[expression] = domQueriesMatch[expression].filter(function (o) {
              return o[0] !== value;
            });
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  };

  /**
   * Initialization of the class functionality
   * @return {Void}
   */
  $this.init = function () {
    loaded = true;
    Object.keys(domQueriesMatch).forEach(function (queryExpression) {
      // Listener for after initial load
      registerQueryListener(queryExpression);
      // Run the queries on load once
      singleRun(queryExpression);
    });
  };

  /**
   * Reset the whole object | warning
   * @return {Void}
   */
  $this.reset = function () {
    Object.keys(registeredQueries).forEach(function (queryExpression) {
      $window.matchMedia(queryExpression).removeEventListener('change', registeredQueries[queryExpression]);
      delete registeredQueries[queryExpression];
    });
    Object.keys(domQueriesMatch).forEach(function (key) {
      return delete domQueriesMatch[key];
    });
    Object.keys(domQueriesUnMatch).forEach(function (key) {
      return delete domQueriesUnMatch[key];
    });
  };

  // =========================================
  // --> PRIVATE
  // --------------------------

  function singleRun(queryExpression) {
    var mq = $window.matchMedia(queryExpression);
    if (mq.matches) {
      domQueriesMatch[mq.media].forEach(function (callback) {
        return callback[0](callback[1]);
      });
    }
  }

  /**
   * Get the preset query values present in Adaptive object
   * @private
   */
  function getPreset(queryId) {
    var Adaptive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var presets = {
      q: null,
      // query min-max values preset
      e: null // custom expression preset
    };

    // -----------------------------------------
    // when working with Adaptive.Js
    if (Adaptive) {
      var _presetQs$queryId, _presetEs$queryId;
      var presetQs = Adaptive.getMinMaxQueries();
      var presetEs = Adaptive.getExpQueries();
      presets.q = (_presetQs$queryId = presetQs[queryId]) !== null && _presetQs$queryId !== void 0 ? _presetQs$queryId : null;
      presets.e = (_presetEs$queryId = presetEs[queryId]) !== null && _presetEs$queryId !== void 0 ? _presetEs$queryId : null;
      if (!presets.q && !presets.e) {
        if (queryId.includes('|')) {
          var qs = queryId.split('|');
          var qs1 = qs[0];
          var qs2 = qs[1];
          if (presetQs[qs1] && presetQs[qs2]) {
            return buildExpression(presetQs[qs1], presetQs[qs2], true);
          }
          if (presetEs[qs1] && presetEs[qs2]) {
            return buildExpression(presetEs[qs1], presetEs[qs2], true, true);
          }
        }
      } else {
        // Write the correct expression for the preset min-max
        if (presets.q) {
          return buildExpression(presets.q[0], presets.q[1]);
        }
        // No need to build the expression as it already is
        if (presets.e) {
          return presets.e;
        }
      }
    }
    return null;
  }

  /**
   * @private
   */
  function buildExpression(q1, q2) {
    var isCompound = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var isExpression = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var templateQuery = '(min-width: $1px) and (max-width: $2px)';
    if (isCompound) {
      if (!isExpression) {
        q1 = templateQuery.replace('$1', q1[0]).replace('$2', q1[1]);
        q2 = templateQuery.replace('$1', q2[0]).replace('$2', q2[1]);
      }
      return "".concat(q1, ", ").concat(q2);
    }
    return templateQuery.replace('$1', q1).replace('$2', q2);
  }
  function registerQueryListener(queryExpression) {
    // If not already registered
    // This helps to avoid too many Listeners created
    if (!Boolean(registeredQueries[queryExpression])) {
      var matchQuery = $window.matchMedia(queryExpression);
      var callback = function callback(mq) {
        if (!mq.matches) {
          domQueriesUnMatch[mq.media].forEach(function (callback) {
            return callback[0](callback[1]);
          });
        } else {
          domQueriesMatch[mq.media].forEach(function (callback) {
            return callback[0](callback[1]);
          });
        }
      };
      registeredQueries[queryExpression] = callback;
      return matchQuery.addEventListener('change', callback);
    }
    // For those added after the loaded event
    if (loaded) {
      singleRun(queryExpression);
    }
  }
  return $window.QueryHandler = QueryHandler;
})());

/***/ }),

/***/ "./src/Teleport.js":
/*!*************************!*\
  !*** ./src/Teleport.js ***!
  \*************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Teleport: () => (/* binding */ Teleport),
/* harmony export */   TeleportGlobal: () => (/* binding */ TeleportGlobal),
/* harmony export */   "default": () => (/* binding */ Teleport)
/* harmony export */ });
/* harmony import */ var _knighttower_js_utility_functions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @knighttower/js-utility-functions */ "./node_modules/@knighttower/js-utility-functions/index.js");
/* harmony import */ var _knighttower_type_check_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @knighttower/type-check-js */ "./node_modules/@knighttower/type-check-js/index.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// author Knighttower
//  MIT License
//  Copyright (c) [2022] [Knighttower] https://github.com/knighttower



/**
 * @module Teleport
 * Teleport an element to another place in the DOM before, inside or after a target
 * @param {Object|String} props || selector - props object (domElement: element, adaptiveId: null|uniqueId})
 * @example new Teleport({domElement: element, adaptiveId: uniqueId}).beam({to: selector})
 * @example new Teleport(domElement).beam({after: selector})
 * @example new Teleport(domElement).beam({before: selector})
 * @example new Teleport(domElement).beam(selector) // defaults to "to" which is inside the selector
 * @example const eleTeleport = new Teleport(domElement) // returns the object with eleTeleport{beam(String|Object), back(), cancel()}
 * @example Make it global so that is available in the browser and works as a 'window' library
 *   TeleportGlobal()
 *      - <div data-teleport="selector"></div>
 *      - <div data-teleport="{before: 'selector'}"></div>
 *     - <div data-teleport="{after: 'selector'}"></div>
 * @feature If the target (element where it will be sent to) is not in the DOM it will wait until it is and then it will beam the element
 * @return {Object} Teleport object
 */
var Teleport = /*#__PURE__*/function () {
  /**
   * Constructor
   * @param {String|Object} selector || props object (see AdaptiveElement)
   * @return {Object}
   */
  function Teleport(props) {
    _classCallCheck(this, Teleport);
    // Early exit if no props are provided
    if (!(0,_knighttower_type_check_js__WEBPACK_IMPORTED_MODULE_1__.typeCheck)('string | object', props).test()) return;
    this.props = props;
    if (!this.props.adaptiveId) {
      var _element$getAttribute;
      var element = (0,_knighttower_js_utility_functions__WEBPACK_IMPORTED_MODULE_0__.selectElement)(this.props);
      var attrId = (_element$getAttribute = element.getAttribute('data-adaptive-id')) !== null && _element$getAttribute !== void 0 ? _element$getAttribute : null;
      // If adaptiveId is not present, create or retrieve it
      var uniqueId = attrId || element.getHash();
      if (!attrId) {
        element.domElement.setAttribute('data-adaptive-id', uniqueId);
      }

      // Update props with additional properties
      this.props = Object.assign({}, this.props, {
        adaptiveId: uniqueId,
        helper: element,
        domElement: element.domElement,
        xpath: element.getXpathTo()
      });
    }
    var placeholder = (0,_knighttower_js_utility_functions__WEBPACK_IMPORTED_MODULE_0__.selectElement)("[name=\"adaptive\"][value=\"".concat(this.props.adaptiveId, "\""));
    if (!placeholder.isInDom()) {
      placeholder = document.createElement('param');
      placeholder.name = 'adaptive';
      placeholder.value = this.props.adaptiveId;
      this.props.domElement.insertAdjacentElement('beforebegin', placeholder);
    }
  }

  /**
   * Beam the element to another place in the DOM
   * This method will look for the "tagert" element if it is in the DOM and it will querying the DOM until it finds it
   * if the target is not found call the cancel() method to stop the observer
   * @param {String|Object} target (selector) directive defaults to "to" || {to|after|before: target}
   * @example new Teleport(domElement).beam({after: selector})
   * @example domElement.beam({after: selector})
   */
  _createClass(Teleport, [{
    key: "beam",
    value: function beam(settings) {
      var _this = this;
      settings = (0,_knighttower_js_utility_functions__WEBPACK_IMPORTED_MODULE_0__.getDirectivesFromString)(settings).directive;

      // Transform settings to an array format
      switch ((0,_knighttower_js_utility_functions__WEBPACK_IMPORTED_MODULE_0__.typeOf)(settings)) {
        case 'string':
          settings = ['default', settings];
          break;
        case 'object':
          var key = Object.keys(settings)[0];
          settings = [key, settings[key]];
          break;
        case 'array':
          if (settings.length === 1) {
            settings = ['default', settings[0]];
          }
          break;
      }
      var _settings = settings,
        _settings2 = _slicedToArray(_settings, 2),
        direction = _settings2[0],
        selector = _settings2[1];
      var target = (0,_knighttower_js_utility_functions__WEBPACK_IMPORTED_MODULE_0__.selectElement)(selector);
      var position = 'beforeend';
      switch (direction) {
        case 'before':
          position = 'beforebegin';
          break;
        case 'after':
          position = 'afterend';
          break;
      }
      if (target.isInDom()) {
        target.domElement.insertAdjacentElement(position, this.props.domElement);
        return;
      }

      // Add observer if the target is not in the DOM
      _knighttower_js_utility_functions__WEBPACK_IMPORTED_MODULE_0__.DomObserver.addOnNodeChange(this.props.adaptiveId, function () {
        var observedTarget = (0,_knighttower_js_utility_functions__WEBPACK_IMPORTED_MODULE_0__.selectElement)(selector);
        if (observedTarget.isInDom()) {
          observedTarget.domElement.insertAdjacentElement(position, _this.props.domElement);
          _knighttower_js_utility_functions__WEBPACK_IMPORTED_MODULE_0__.DomObserver.removeOnNodeChange(_this.props.adaptiveId);
        }
      });
    }

    /**
     * Return to its original place
     * @example new Teleport(domElement).back()
     * @example domElement.back()
     */
  }, {
    key: "back",
    value: function back() {
      var target = (0,_knighttower_js_utility_functions__WEBPACK_IMPORTED_MODULE_0__.selectElement)("[name=\"adaptive\"][value=\"".concat(this.props.adaptiveId, "\""));
      if (target.isInDom()) {
        target.domElement.insertAdjacentElement('afterend', this.props.domElement);
        // target.domElement.remove();
      }
    }

    /**
     * If element target is no it the DOM and needs to cancel the observer
     * @example new Teleport(domElement).cancel()
     * @example domElement.cancel()
     */
  }, {
    key: "cancel",
    value: function cancel() {
      _knighttower_js_utility_functions__WEBPACK_IMPORTED_MODULE_0__.DomObserver.removeOnNodeChange(this.props.adaptiveId);
    }
  }]);
  return Teleport;
}(); // Storage
var TeleportIsGlobal = false;

/**
 * Warning, this will make it global and would work with data attr like data-teleport
 * @example new Teleport().global()
 */
function TeleportGlobal() {
  // Exit if already initialized
  if (TeleportIsGlobal) return;

  // Use forEach directly on NodeList
  document.querySelectorAll('[data-teleport]').forEach(function (element) {
    new Teleport(element).beam(element.getAttribute('data-teleport'));
  });

  // Mark as initialized
  TeleportIsGlobal = true;
}


/***/ }),

/***/ "./src/classes/AdaptiveElement.js":
/*!****************************************!*\
  !*** ./src/classes/AdaptiveElement.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AdaptiveElement)
/* harmony export */ });
/* harmony import */ var _Teleport_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Teleport.js */ "./src/Teleport.js");
/* harmony import */ var _QueryHandler_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../QueryHandler.js */ "./src/QueryHandler.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// Author Knighttower
//  MIT License
//  Copyright (c) [2022] [Knighttower] https://github.com/knighttower


// when it imports, it also registers itself as global


/**
 * @class Adds some extra functionality to interact with a DOM element
 * @param {Object} props
 * @param {Object} Adaptive Instance of
 * @return {Object}
 */
var AdaptiveElement = /*#__PURE__*/function () {
  /**
   * Constructor
   * @param {String|Object} selector
   * @return {Object}
   */
  function AdaptiveElement(props, Adaptive) {
    _classCallCheck(this, AdaptiveElement);
    this.props = props;
    this.Adaptive = Adaptive;
    for (var directive in props.settings) {
      // Matches the method name and passes the directives
      // Ex: this[addClass]({...})
      this[directive](props.settings[directive]);
    }
  }
  _createClass(AdaptiveElement, [{
    key: "addClass",
    value: function addClass(queries) {
      var _this = this;
      return _QueryHandler_js__WEBPACK_IMPORTED_MODULE_1__["default"].add(queries, function ($classes) {
        $classes = $classes.split(' ');
        $classes.forEach(function ($class) {
          _this.props.domElement.classList.add($class);
        });
        return;
      }, function ($classes) {
        $classes = $classes.split(' ');
        $classes.forEach(function ($class) {
          _this.props.domElement.classList.remove($class);
        });
        return;
      }, this.Adaptive);
    }
  }, {
    key: "removeClass",
    value: function removeClass(queries) {
      var _this2 = this;
      return _QueryHandler_js__WEBPACK_IMPORTED_MODULE_1__["default"].add(queries, function ($classes) {
        $classes = $classes.split(' ');
        $classes.forEach(function ($class) {
          _this2.props.domElement.classList.remove($class);
        });
        return;
      }, function ($classes) {
        $classes = $classes.split(' ');
        $classes.forEach(function ($class) {
          _this2.props.domElement.classList.add($class);
        });
        return;
      }, this.Adaptive);
    }
  }, {
    key: "addStyle",
    value: function addStyle(queries) {
      var _this3 = this;
      // Save the original style in memory to not discard them
      this.props.originalStyle = this.props.domElement.getAttribute('style');
      return _QueryHandler_js__WEBPACK_IMPORTED_MODULE_1__["default"].add(queries, function ($styles) {
        return _this3.props.domElement.style.cssText += $styles;
      }, function () {
        return _this3.props.domElement.style.cssText = _this3.props.originalStyle;
      }, this.Adaptive);
    }
  }, {
    key: "teleport",
    value: function teleport(queries) {
      var $element = new _Teleport_js__WEBPACK_IMPORTED_MODULE_0__["default"](this.props);
      return _QueryHandler_js__WEBPACK_IMPORTED_MODULE_1__["default"].add(queries, function ($directive) {
        return $element.beam($directive);
      }, function () {
        $element.back();
        return $element.cancel();
      }, this.Adaptive);
    }
  }, {
    key: "execute",
    value: function execute(queries) {
      var $element = this;
      var attrs = {
        adaptiveId: $element.props.uniqueId,
        helper: $element.props.helper,
        domElement: $element.props.domElement,
        xpath: $element.props.xpath
      };
      return _QueryHandler_js__WEBPACK_IMPORTED_MODULE_1__["default"].add(queries, function ($callback) {
        if ($callback && typeof $callback === 'function') {
          return $callback(attrs);
        }
      }, function ($callback) {
        if ($callback && typeof $callback === 'function') {
          return $callback(attrs);
        }
      }, this.Adaptive);
    }
  }]);
  return AdaptiveElement;
}();


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames not based on template
/******/ 			if ({"src_vue-components_TeleportTo_vue":1,"src_web-components_TeleportTo_js":1}[chunkId]) return "examples/vue/app.min/" + chunkId + ".js";
/******/ 			// return url for filenames based on template
/******/ 			return undefined;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get mini-css chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.miniCssF = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return undefined;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "@knighttower/adaptive:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "/";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/dist/Adaptive": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk_knighttower_adaptive"] = self["webpackChunk_knighttower_adaptive"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!*************************!*\
  !*** ./src/Adaptive.js ***!
  \*************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Adaptive: () => (/* binding */ _adaptive),
/* harmony export */   adaptive: () => (/* binding */ _adaptive),
/* harmony export */   "default": () => (/* binding */ _adaptive)
/* harmony export */ });
/* harmony import */ var _knighttower_js_utility_functions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @knighttower/js-utility-functions */ "./node_modules/@knighttower/js-utility-functions/index.js");
/* harmony import */ var _classes_AdaptiveElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./classes/AdaptiveElement.js */ "./src/classes/AdaptiveElement.js");
/* harmony import */ var _Teleport_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Teleport.js */ "./src/Teleport.js");
/* harmony import */ var _QueryHandler_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./QueryHandler.js */ "./src/QueryHandler.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
// Author Knighttower
// MIT License
// Copyright (c) [2022] [knighttower] https://github.com/knighttower

// Inspired by http://wicky.nillia.ms/enquire.js

// Import the Element DOM helper

// -----------------------------------------






// =========================================
// --> ADAPTIVE JS
// --------------------------

/**
 * @module Adaptive
 * Add/remove classes/styles or teleport an element
 * @return {Object}
 * @example Adaptive(window, Adaptive)
 * @example Adaptive(this, Adaptive)
 * @example Adaptive.registerElement(element)
 * @see "example" folder for more
 */
var _adaptive = function () {
  'use strict';

  var $window = typeof window !== 'undefined' ? window : {};

  // -----------------------------------------
  // This will make it reuse the same instance if already imported without overwrites
  if ($window.$adaptive) {
    return $window.$adaptive;
  }
  // -----------------------------------------

  /**
   * Register this library into the $window
   * @private
   * @return {Object}
   */
  var $this = {};
  var Adaptive = (0,_knighttower_js_utility_functions__WEBPACK_IMPORTED_MODULE_0__.proxyObject)($this);

  /**
   * All the elements that will be part of the grid
   * @private
   */
  var domElements = {};

  /**
   * Flag for isMounted
   * @private
   */
  var isMounted = false;

  /**
   * Flag for using Vue
   * @private
   */
  var useVue = false;

  /**
   * Flag for using React
   * @private
   */
  var useReact = false;

  /**
   * Flag for using React
   * @private
   */
  var useWeb = false;

  /**
   * Flag for using Hybrid
   * @private
   */
  var isHybrid = false;

  /**
   * queries possible sizes
   * @private
   */
  var screens = {
    320: [1, 379],
    480: [380, 519],
    520: [520, 599] /* up to : mobiles */,
    600: [600, 699] /* up to : mid-size-tables */,
    700: [700, 799] /* up to : tablets / ipad */,
    800: [800, 919] /* transition in between tablets and desktop */,
    920: [920, 999] /* from here on for desktops */,
    1000: [1000, 1199],
    1200: [1200, 1439],
    1440: [1440, 1599],
    1600: [1600, 1700]
  };

  /**
   * break the 3 major device types
   * @private
   */
  var devices = {
    mobile: [1, 599] /* Actual phones */,
    tablet: [600, 799] /* tablets in portrait or below */,
    odd: [800, 1023] /* small Laptops and Ipads in landscape */,
    desktop: [1024, 1920] /* Most common resolutions below 1920 */
  };

  /**
   * break the 3 major device types
   * @private
   */
  var broadMediaQueries = {
    'non-desktop': [100, 1023],
    nondesktop: [100, 1023],
    fullscreen: [1920, 6000] /* Large monitos and fullscreen in 1920 res */
  };

  /**
   * To register additional custom queries add the key:[min, max]
   * @private
   */
  var customMinMaxQueries = {};

  /**
   * To register additional custom queries add the key:'Query Expression'
   * @private
   */
  var customExpressionQueries = {};

  // =========================================
  // --> Utility
  // --------------------------

  /**
   * Get all the available queries
   * @private
   * @return {Object}
   */
  $this.getAllQueries = function () {
    return Object.assign({}, screens, devices, broadMediaQueries, customMinMaxQueries, customExpressionQueries);
  };

  /**
   * @memberof Adaptive
   * @inner
   * Get all the available min max queries
   * @return {Object}
   */
  $this.getMinMaxQueries = function () {
    return Object.assign({}, screens, devices, broadMediaQueries, customMinMaxQueries);
  };

  /**
   * @memberof Adaptive
   * @inner
   * Get all the available "expression" queries
   * @return {Object}
   */
  $this.getExpQueries = function () {
    return Object.assign({}, customExpressionQueries);
  };

  /**
   * @memberof Adaptive
   * @inner
   * Register an element
   * @param {String|Object} elementOrSelector
   * @param {Object} data Optional used directly to add the directives, but is mostly for VUe
   * @return {Void}
   */
  $this.registerElement = function (elementOrSelector, data) {
    var helper = (0,_knighttower_js_utility_functions__WEBPACK_IMPORTED_MODULE_0__.selectElement)(elementOrSelector);
    if (helper.isInDom()) {
      return registerThis(helper, data);
    } else {
      helper.whenInDom().then(function (element) {
        return registerThis(element, data);
      });
    }
  };

  /**
   * Register an element
   * @private
   * @param {String|Object} elementOrSelector
   * @param {Object} data Optional used directly to add the directives, but is mostly for VUe
   * @return {Void}
   */
  function registerThis(element, data) {
    // Register only unique non indexed elements
    if (!element.getAttribute('data-adaptive-id')) {
      var uniqueId = element.getHash();
      var settings = (0,_knighttower_js_utility_functions__WEBPACK_IMPORTED_MODULE_0__.getDirectivesFromString)(data || element.getAttribute('data-adaptive')).directive;

      //set the unique id to the element for later use
      element.domElement.setAttribute('data-adaptive-id', uniqueId);
      domElements[uniqueId] = new _classes_AdaptiveElement_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
        adaptiveId: uniqueId,
        helper: element,
        domElement: element.domElement,
        xpath: element.getXpathTo(),
        settings: settings,
        useVue: useVue,
        useReact: useReact
      }, $this);
      return uniqueId;
    }
  }

  /**
   * @memberof Adaptive
   * @inner
   * Register A custom Query Min, Max
   * @param {String} id Identifier
   * @param {Number} min Number only, no units attached as it only handles pixels here
   * @param {Number} max Number only, no units attached as it only handles pixels here
   * @return {Void}
   */
  $this.addQueryMinMax = function (id, min, max) {
    if (!customMinMaxQueries[id]) {
      if (!min || !max) {
        throw new Exception('Min or Max must be passed (id, min, max)', 1);
      }
      customMinMaxQueries[id] = [min, max];
    }
  };

  /**
   * @memberof Adaptive
   * @inner
   * Register A custom Query Expression
   * @param {String} id Identifier
   * @param {String} query Media query, example "screen and (max-width: 500em) and (orientation: landscape)"
   * @param {Number} max Number only, no units attached as it only handles pixels here
   * @return {Void}
   */
  $this.addQueryExpression = function (id, query) {
    if (!customExpressionQueries[id]) {
      customExpressionQueries[id] = query;
    }
  };

  /**
   * @memberof Adaptive
   * @inner
   * Register A custom Query Expression
   * @param {String} breakdownId Identifier like "tablet" or "mobile", etc
   * @param {Fucntion|Array} callback Function/Method or Array with object and property to set
   * @example Adaptive.if('mobile', [object, propertyId]) || Adaptive.if('mobile', () => {})
   * @return {Object} Proxy
   */
  $this["if"] = function (breakdownId) {
    var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var isFunction = callback && typeof callback === 'function';
    var isArray = callback && Array.isArray(callback);
    var observer = {};
    observer[breakdownId] = {
      _private: ['breakdownId', 'match', 'ifElse', 'do', 'removeAfterExec'],
      _mutable: ['ifElse'],
      uid: (0,_knighttower_js_utility_functions__WEBPACK_IMPORTED_MODULE_0__.getDynamicId)(),
      breakdownId: breakdownId,
      match: false,
      executed: false,
      removeAfterExec: false,
      ifElse: null,
      "else": function _else(ifElse) {
        if (ifElse && typeof ifElse === 'function') {
          this.ifElse = ifElse;
        }
      },
      onlyOnce: function onlyOnce() {
        this.removeAfterExec = true;
        if (this.executed) {
          _QueryHandler_js__WEBPACK_IMPORTED_MODULE_3__["default"].remove(this.uid, 'uid');
        }
      },
      "do": function _do() {
        if (this.match) {
          if (isFunction) {
            callback();
          }
          if (isArray) {
            callback[0][callback[1]] = true;
          }
          if (this.removeAfterExec) {
            _QueryHandler_js__WEBPACK_IMPORTED_MODULE_3__["default"].remove(this.uid, 'uid');
          }
          this.executed = true;
          return true;
        }
        if (isArray) {
          callback[0][callback[1]] = false;
        }
        if (this.ifElse) {
          this.ifElse();
        }
        return false;
      }
    };
    _QueryHandler_js__WEBPACK_IMPORTED_MODULE_3__["default"].add(observer, function (o) {
      o.match = true;
      o["do"]();
    }, function (o) {
      o.match = false;
      o["do"]();
    }, $this);
    return (0,_knighttower_js_utility_functions__WEBPACK_IMPORTED_MODULE_0__.proxyObject)(observer[breakdownId]);
  };

  /**
   * Full reset, handle with care
   * @private
   * @return {Void}
   */
  $this.reset = function () {
    Object.keys(domElements).forEach(function (key) {
      return delete domElements[key];
    });
    DomObserver.cleanup();
    _QueryHandler_js__WEBPACK_IMPORTED_MODULE_3__["default"].reset();
    isMounted = false;
  };

  // =========================================
  // --> DomReady and INIT
  // --------------------------

  /**
   * Real init for the app
   * @private
   */
  function _init() {
    isMounted = true;
    document.querySelectorAll('[data-adaptive]:not([data-adaptive-id])').forEach(function (element, index) {
      $this.registerElement(element);
    });
    _QueryHandler_js__WEBPACK_IMPORTED_MODULE_3__["default"].init();
    if (useVue || useReact) {
      // hybrid mode
      // support for static and dynamic elements
      if (isHybrid) {
        (0,_Teleport_js__WEBPACK_IMPORTED_MODULE_2__.TeleportGlobal)();
      }
    } else {
      // vanilla js
      (0,_Teleport_js__WEBPACK_IMPORTED_MODULE_2__.TeleportGlobal)();
    }
  }

  /**
   * @memberof Adaptive
   * @inner
   * Initialization, cam be called externally to reinitialized after dom loaded
   * @return {Void}
   */
  $this.init = function () {
    if (isMounted) {
      return false;
    }
    if (document.readyState === 'complete' || document.readyState !== 'loading' && !document.documentElement.doScroll) {
      return domIsReady();
    } else {
      // Use the handy event callback
      document.addEventListener('DOMContentLoaded', domIsReady);
      // A fallback to $window.onload, that will always work
      $window.addEventListener('load', domIsReady);
    }
    return;
  };

  /**
   * When ready trigger the initialization
   * @private
   */
  function domIsReady() {
    document.removeEventListener('DOMContentLoaded', domIsReady);
    $window.removeEventListener('load', domIsReady);
    _init();
    return;
  }

  /**
   * @memberof Adaptive
   * @inner
   * For use with Vue
   * @param {Vue} Vue Vue instance
   * @param {Boolean} hybrid Allow support when using static and dynamic
   * @return {Vue}
   */
  $this.useVue = function (Vue) {
    var hybrid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (hybrid) {
      isHybrid = true;
    }
    if (_typeof(Vue) === 'object' && typeof Vue.mixin === 'function') {
      var TeleportTo = __webpack_require__.e(/*! import() */ "src_vue-components_TeleportTo_vue").then(__webpack_require__.bind(__webpack_require__, /*! ./vue-components/TeleportTo.vue */ "./src/vue-components/TeleportTo.vue"));
      useVue = true;
      var installer = {
        install: function install(app, options) {
          // For Options API
          app.config.globalProperties.Adaptive = Adaptive;
          // For composition API
          app.provide('Adaptive', Adaptive);
        }
      };

      /**
       * Adaptive used as vue.$Adaptive
       * @private
       */
      Vue.use(installer);
      /**
       * Adaptive used as v-adaptive
       * @private
       */
      Vue.directive('adaptive', {
        mounted: function mounted(element, binding, vnode, prevVnode) {
          Adaptive.registerElement(element, binding.value);
        }
      });

      /**
       * Adaptive used as v-teleport-to
       * @private
       */
      Vue.directive('teleport-to', {
        mounted: function mounted(element, binding, vnode, prevVnode) {
          return new _Teleport_js__WEBPACK_IMPORTED_MODULE_2__.Teleport(element).beam(binding.value);
        }
      });
      Vue.component('teleport-to', TeleportTo);

      /**
       * Adaptive used for non Vue elements register with data-adaptive attr
       * Hybrid mode
       * @private
       */
      Vue.mixin({
        mounted: function mounted() {
          return Adaptive.init();
        }
      });
    }
    return Vue;
  };

  //docs
  /**
   * For use with Web Components
   * @private
   * @return {Void}
   */
  $this.useWebComponent = function () {
    if (!useWeb && !useVue) {
      __webpack_require__.e(/*! import() */ "src_web-components_TeleportTo_js").then(__webpack_require__.bind(__webpack_require__, /*! ./web-components/TeleportTo.js */ "./src/web-components/TeleportTo.js"));
      useWeb = true;
    }
  };

  /**
   * @memberof Adaptive
   * @inner
   * For use with React
   * @param {React} React React instance
   * @param {Boolean} hybrid Allow support when using static and dynamic
   * @return {Void}
   */
  $this.useReact = function (React) {
    var hybrid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (hybrid) {
      isHybrid = true;
    }
    if (_typeof(React) === 'object') {
      $this.useWebComponent();
      useReact = true;
    }
  };
  return $window.$adaptive = Adaptive;
}();

})();

/******/ })()
;