/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./examples/react/hello.jsx":
/*!**********************************!*\
  !*** ./examples/react/hello.jsx ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function Counter() {
  var _React$useState = React.useState(5),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    count = _React$useState2[0],
    setCount = _React$useState2[1];
  var increment = function increment(e) {
    setCount(count + 1);
  };
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("button", {
    type: "button",
    onClick: function onClick() {
      increment();
    },
    children: ["clicker React count ", count, ", click me!"]
  });
}
var Button = /*#__PURE__*/function (_React$Component) {
  _inherits(Button, _React$Component);
  var _super = _createSuper(Button);
  function Button(props) {
    var _this;
    _classCallCheck(this, Button);
    _this = _super.call(this, props);
    _this.state = {
      count: 1
    };
    _this.increment = _this.increment.bind(_assertThisInitialized(_this));
    return _this;
  }
  _createClass(Button, [{
    key: "increment",
    value: function increment(e) {
      $adaptive["if"]('tablet', function () {
        console.log('Clicked on Tablet!');
      }).onlyOnce();
      this.setState(function (prevState, props) {
        return {
          count: prevState.count + 1
        };
      });
    }
  }, {
    key: "render",
    value: function render() {
      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("button", {
        type: "button",
        onClick: this.increment,
        children: ["clicker React count ", this.state.count, ", click me when it Tablet size and watch the console output!"]
      });
    }
  }]);
  return Button;
}(React.Component);
function Hello(props) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("h4", {
      children: "React component"
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("p", {
      children: ["This component will move at tablet to static hello ", props.hello]
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
      "data-adaptive": "addClass.tablet(laura, miau) && addClass.mobile|fullscreen(red, green) &&  addClass.desktop(uno, dos)",
      children: "This is inside the react component"
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Counter, {}), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("teleport-to", {
      target: "#hello",
      position: "after",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", {
        style: {
          padding: '8px',
          background: 'violet'
        },
        children: ["Teleporting an element from inside ", /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("b", {
          children: "react"
        }), " component"]
      })
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
      "data-adaptive": "teleport.desktop|mobile.before(#hello)",
      style: {
        background: 'beige'
      },
      children: "Teleporting on desktop or mobile"
    })]
  });
}
var root = ReactDOM.createRoot(document.getElementById('reactHello'));
root.render( /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Hello, {
  hello: "component"
}));
var other = ReactDOM.createRoot(document.getElementById('reactButton'));
other.render( /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Button, {}));

/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-runtime.development.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-runtime.development.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var React = __webpack_require__(/*! react */ "react");

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types.
var REACT_ELEMENT_TYPE = Symbol.for('react.element');
var REACT_PORTAL_TYPE = Symbol.for('react.portal');
var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
var REACT_CONTEXT_TYPE = Symbol.for('react.context');
var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
var REACT_MEMO_TYPE = Symbol.for('react.memo');
var REACT_LAZY_TYPE = Symbol.for('react.lazy');
var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');
var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

function error(format) {
  {
    {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      printWarning('error', format, args);
    }
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    } // eslint-disable-next-line react-internal/safe-string-coercion


    var argsWithFormat = args.map(function (item) {
      return String(item);
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

// -----------------------------------------------------------------------------

var enableScopeAPI = false; // Experimental Create Event Handle API.
var enableCacheElement = false;
var enableTransitionTracing = false; // No known bugs, but needs performance testing

var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber
// stuff. Intended to enable React core members to more easily debug scheduling
// issues in DEV builds.

var enableDebugTracing = false; // Track which Fiber(s) schedule render work.

var REACT_MODULE_REFERENCE;

{
  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');
}

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
    // types supported by any Flight configuration anywhere since
    // we don't know which Flight build this will end up being used
    // with.
    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
      return true;
    }
  }

  return false;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var displayName = outerType.displayName;

  if (displayName) {
    return displayName;
  }

  var functionName = innerType.displayName || innerType.name || '';
  return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
} // Keep in sync with react-reconciler/getComponentNameFromFiber


function getContextName(type) {
  return type.displayName || 'Context';
} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.


function getComponentNameFromType(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case REACT_FRAGMENT_TYPE:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case REACT_PROFILER_TYPE:
      return 'Profiler';

    case REACT_STRICT_MODE_TYPE:
      return 'StrictMode';

    case REACT_SUSPENSE_TYPE:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';

  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        var outerName = type.displayName || null;

        if (outerName !== null) {
          return outerName;
        }

        return getComponentNameFromType(type.type) || 'Memo';

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentNameFromType(init(payload));
          } catch (x) {
            return null;
          }
        }

      // eslint-disable-next-line no-fallthrough
    }
  }

  return null;
}

var assign = Object.assign;

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: assign({}, props, {
          value: prevLog
        }),
        info: assign({}, props, {
          value: prevInfo
        }),
        warn: assign({}, props, {
          value: prevWarn
        }),
        error: assign({}, props, {
          value: prevError
        }),
        group: assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if ( !fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled "<anonymous>"
                // but we have a user-provided "displayName"
                // splice it in to make the stack more readable.


                if (fn.displayName && _frame.includes('<anonymous>')) {
                  _frame = _frame.replace('<anonymous>', fn.displayName);
                }

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case REACT_SUSPENSE_TYPE:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var hasOwnProperty = Object.prototype.hasOwnProperty;

var loggedTypeFailures = {};
var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            // eslint-disable-next-line react-internal/prod-error-codes
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare

function isArray(a) {
  return isArrayImpl(a);
}

/*
 * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol
 * and Temporal.* types. See https://github.com/facebook/react/pull/22064.
 *
 * The functions in this module will throw an easier-to-understand,
 * easier-to-debug exception with a clear errors message message explaining the
 * problem. (Instead of a confusing exception thrown inside the implementation
 * of the `value` object).
 */
// $FlowFixMe only called in DEV, so void return is not possible.
function typeName(value) {
  {
    // toStringTag is needed for namespaced types like Temporal.Instant
    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
    return type;
  }
} // $FlowFixMe only called in DEV, so void return is not possible.


function willCoercionThrow(value) {
  {
    try {
      testStringCoercion(value);
      return false;
    } catch (e) {
      return true;
    }
  }
}

function testStringCoercion(value) {
  // If you ended up here by following an exception call stack, here's what's
  // happened: you supplied an object or symbol value to React (as a prop, key,
  // DOM attribute, CSS property, string ref, etc.) and when React tried to
  // coerce it to a string using `'' + value`, an exception was thrown.
  //
  // The most common types that will cause this exception are `Symbol` instances
  // and Temporal objects like `Temporal.Instant`. But any object that has a
  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this
  // exception. (Library authors do this to prevent users from using built-in
  // numeric operators like `+` or comparison operators like `>=` because custom
  // methods are needed to perform accurate arithmetic or comparison.)
  //
  // To fix the problem, coerce this object or symbol value to a string before
  // passing it to React. The most reliable way is usually `String(value)`.
  //
  // To find which value is throwing, check the browser or debugger console.
  // Before this exception was thrown, there should be `console.error` output
  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the
  // problem and how that type was used: key, atrribute, input value prop, etc.
  // In most cases, this console output also shows the component and its
  // ancestor components where the exception happened.
  //
  // eslint-disable-next-line react-internal/safe-string-coercion
  return '' + value;
}
function checkKeyStringCoercion(value) {
  {
    if (willCoercionThrow(value)) {
      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));

      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
    }
  }
}

var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown;
var specialPropRefWarningShown;
var didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function warnIfStringRefCannotBeAutoConverted(config, self) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}

function defineKeyPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingKey = function () {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingKey.isReactWarning = true;
    Object.defineProperty(props, 'key', {
      get: warnAboutAccessingKey,
      configurable: true
    });
  }
}

function defineRefPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingRef = function () {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingRef.isReactWarning = true;
    Object.defineProperty(props, 'ref', {
      get: warnAboutAccessingRef,
      configurable: true
    });
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * https://github.com/reactjs/rfcs/pull/107
 * @param {*} type
 * @param {object} props
 * @param {string} key
 */

function jsxDEV(type, config, maybeKey, source, self) {
  {
    var propName; // Reserved names are extracted

    var props = {};
    var key = null;
    var ref = null; // Currently, key can be spread in as a prop. This causes a potential
    // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
    // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
    // but as an intermediary step, we will use jsxDEV for everything except
    // <div {...props} key="Hi" />, because we aren't currently able to tell if
    // key is explicitly declared to be undefined or not.

    if (maybeKey !== undefined) {
      {
        checkKeyStringCoercion(maybeKey);
      }

      key = '' + maybeKey;
    }

    if (hasValidKey(config)) {
      {
        checkKeyStringCoercion(config.key);
      }

      key = '' + config.key;
    }

    if (hasValidRef(config)) {
      ref = config.ref;
      warnIfStringRefCannotBeAutoConverted(config, self);
    } // Remaining properties are added to a new props object


    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    } // Resolve default props


    if (type && type.defaultProps) {
      var defaultProps = type.defaultProps;

      for (propName in defaultProps) {
        if (props[propName] === undefined) {
          props[propName] = defaultProps[propName];
        }
      }
    }

    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }

    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
  }
}

var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement$1(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */


function isValidElement(object) {
  {
    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  }
}

function getDeclarationErrorAddendum() {
  {
    if (ReactCurrentOwner$1.current) {
      var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);

      if (name) {
        return '\n\nCheck the render method of `' + name + '`.';
      }
    }

    return '';
  }
}

function getSourceInfoErrorAddendum(source) {
  {
    if (source !== undefined) {
      var fileName = source.fileName.replace(/^.*[\\\/]/, '');
      var lineNumber = source.lineNumber;
      return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
    }

    return '';
  }
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  {
    var info = getDeclarationErrorAddendum();

    if (!info) {
      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

      if (parentName) {
        info = "\n\nCheck the top-level render call using <" + parentName + ">.";
      }
    }

    return info;
  }
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  {
    if (!element._store || element._store.validated || element.key != null) {
      return;
    }

    element._store.validated = true;
    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
      return;
    }

    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
    // property, it may be the creator of the child that's responsible for
    // assigning it a key.

    var childOwner = '';

    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
      // Give the component that originally created this child.
      childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
    }

    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  {
    if (typeof node !== 'object') {
      return;
    }

    if (isArray(node)) {
      for (var i = 0; i < node.length; i++) {
        var child = node[i];

        if (isValidElement(child)) {
          validateExplicitKey(child, parentType);
        }
      }
    } else if (isValidElement(node)) {
      // This element was passed in a valid location.
      if (node._store) {
        node._store.validated = true;
      }
    } else if (node) {
      var iteratorFn = getIteratorFn(node);

      if (typeof iteratorFn === 'function') {
        // Entry iterators used to provide implicit keys,
        // but now we print a separate warning for them later.
        if (iteratorFn !== node.entries) {
          var iterator = iteratorFn.call(node);
          var step;

          while (!(step = iterator.next()).done) {
            if (isValidElement(step.value)) {
              validateExplicitKey(step.value, parentType);
            }
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentNameFromType(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentNameFromType(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}

function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
  {
    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.

    if (!validType) {
      var info = '';

      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
      }

      var sourceInfo = getSourceInfoErrorAddendum(source);

      if (sourceInfo) {
        info += sourceInfo;
      } else {
        info += getDeclarationErrorAddendum();
      }

      var typeString;

      if (type === null) {
        typeString = 'null';
      } else if (isArray(type)) {
        typeString = 'array';
      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
        typeString = "<" + (getComponentNameFromType(type.type) || 'Unknown') + " />";
        info = ' Did you accidentally export a JSX literal instead of a component?';
      } else {
        typeString = typeof type;
      }

      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }

    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.

    if (element == null) {
      return element;
    } // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)


    if (validType) {
      var children = props.children;

      if (children !== undefined) {
        if (isStaticChildren) {
          if (isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              validateChildKeys(children[i], type);
            }

            if (Object.freeze) {
              Object.freeze(children);
            }
          } else {
            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
          }
        } else {
          validateChildKeys(children, type);
        }
      }
    }

    if (type === REACT_FRAGMENT_TYPE) {
      validateFragmentProps(element);
    } else {
      validatePropTypes(element);
    }

    return element;
  }
} // These two functions exist to still get child warnings in dev
// even with the prod transform. This means that jsxDEV is purely
// opt-in behavior for better messages but that we won't stop
// giving you warnings if you use production apis.

function jsxWithValidationStatic(type, props, key) {
  {
    return jsxWithValidation(type, props, key, true);
  }
}
function jsxWithValidationDynamic(type, props, key) {
  {
    return jsxWithValidation(type, props, key, false);
  }
}

var jsx =  jsxWithValidationDynamic ; // we may want to special case jsxs internally to take advantage of static children.
// for now we can ship identical prod functions

var jsxs =  jsxWithValidationStatic ;

exports.Fragment = REACT_FRAGMENT_TYPE;
exports.jsx = jsx;
exports.jsxs = jsxs;
  })();
}


/***/ }),

/***/ "./node_modules/react/jsx-runtime.js":
/*!*******************************************!*\
  !*** ./node_modules/react/jsx-runtime.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-jsx-runtime.development.js */ "./node_modules/react/cjs/react-jsx-runtime.development.js");
}


/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "React" ***!
  \************************/
/***/ ((module) => {

module.exports = React;

/***/ }),

/***/ "./src/Adaptive.js":
/*!*************************!*\
  !*** ./src/Adaptive.js ***!
  \*************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Adaptive: () => (/* binding */ _adaptive),
/* harmony export */   adaptive: () => (/* binding */ _adaptive),
/* harmony export */   "default": () => (/* binding */ _adaptive)
/* harmony export */ });
/* harmony import */ var knighttower_utility__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! knighttower/utility */ "./node_modules/knighttower/packages/utility/index.js");
/* harmony import */ var _classes_AdaptiveElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./classes/AdaptiveElement.js */ "./src/classes/AdaptiveElement.js");
/* harmony import */ var _Teleport_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Teleport.js */ "./src/Teleport.js");
/* harmony import */ var _QueryHandler_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./QueryHandler.js */ "./src/QueryHandler.js");
/* harmony import */ var _vue_components_TeleportTo_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./vue-components/TeleportTo.js */ "./src/vue-components/TeleportTo.js");
/* harmony import */ var _web_components_TeleportTo_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./web-components/TeleportTo.js */ "./src/web-components/TeleportTo.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
// Author Knighttower
// MIT License
// Copyright (c) [2022] [knighttower] https://github.com/knighttower

// Inspired by http://wicky.nillia.ms/enquire.js

// Import the Element DOM helper

// -----------------------------------------








// =========================================
// --> ADAPTIVE JS
// --------------------------

/**
 * @module Adaptive
 * Add/remove classes/styles or teleport an element
 * @return {Object}
 * @example Adaptive(window, Adaptive)
 * @example Adaptive(this, Adaptive)
 * @example Adaptive.registerElement(element)
 * @see "example" folder for more
 */
var _adaptive = function () {
  'use strict';

  var $window = typeof window !== 'undefined' ? window : {};

  // -----------------------------------------
  // This will make it reuse the same instance if already imported without overwrites
  if ($window.$adaptive) {
    return $window.$adaptive;
  }
  // -----------------------------------------

  /**
   * Register this library into the $window
   * @private
   * @return {Object}
   */
  var $this = {
    _mutable: ['registerElement', 'addQueryMinMax', 'addQueryExpression']
  };
  var Adaptive = (0,knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.proxyObject)($this);

  /**
   * All the elements that will be part of the grid
   * @private
   */
  var domElements = {};

  /**
   * Flag for isMounted
   * @private
   */
  var isMounted = false;

  /**
   * Flag for using Vue
   * @private
   */
  var useVue = false;

  /**
   * Flag for using React
   * @private
   */
  var useReact = false;

  /**
   * Flag for using React
   * @private
   */
  var useWeb = false;

  /**
   * Flag for using Hybrid
   * @private
   */
  var isHybrid = false;

  /**
   * queries possible sizes
   * @private
   */
  var screens = {
    320: [1, 379],
    480: [380, 519],
    520: [520, 599] /* up to : mobiles */,
    600: [600, 699] /* up to : mid-size-tables */,
    700: [700, 799] /* up to : tablets / ipad */,
    800: [800, 919] /* transition in between tablets and desktop */,
    920: [920, 999] /* from here on for desktops */,
    1000: [1000, 1199],
    1200: [1200, 1439],
    1440: [1440, 1599],
    1600: [1600, 1700]
  };

  /**
   * break the 3 major device types
   * @private
   */
  var devices = {
    mobile: [1, 599] /* Actual phones */,
    tablet: [600, 799] /* tablets in portrait or below */,
    odd: [800, 1023] /* small Laptops and Ipads in landscape */,
    desktop: [1024, 1920] /* Most common resolutions below 1920 */
  };

  /**
   * break the 3 major device types
   * @private
   */
  var broadMediaQueries = {
    'non-desktop': [100, 1023],
    nondesktop: [100, 1023],
    fullscreen: [1920, 6000] /* Large monitos and fullscreen in 1920 res */
  };

  /**
   * To register additional custom queries add the key:[min, max]
   * @private
   */
  var customMinMaxQueries = {};

  /**
   * To register additional custom queries add the key:'Query Expression'
   * @private
   */
  var customExpressionQueries = {};

  // =========================================
  // --> Utility
  // --------------------------

  /**
   * Get all the available queries
   * @private
   * @return {Object}
   */
  $this.getAllQueries = function () {
    return Object.assign({}, screens, devices, broadMediaQueries, customMinMaxQueries, customExpressionQueries);
  };

  /**
   * @memberof Adaptive
   * @inner
   * Get all the available min max queries
   * @return {Object}
   */
  $this.getMinMaxQueries = function () {
    return Object.assign({}, screens, devices, broadMediaQueries, customMinMaxQueries);
  };

  /**
   * @memberof Adaptive
   * @inner
   * Get all the available "expression" queries
   * @return {Object}
   */
  $this.getExpQueries = function () {
    return Object.assign({}, customExpressionQueries);
  };

  /**
   * @memberof Adaptive
   * @inner
   * Register an element
   * @param {String|Object} elementOrSelector
   * @param {Object} data Optional used directly to add the directives, but is mostly for VUe
   * @return {Void}
   */
  $this.registerElement = function (elementOrSelector, data) {
    var helper = (0,knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.selectElement)(elementOrSelector);
    if (helper.isInDom()) {
      return registerThis(helper, data);
    } else {
      helper.whenInDom().then(function (element) {
        return registerThis(element, data);
      });
    }
  };

  /**
   * Register an element
   * @private
   * @param {String|Object} elementOrSelector
   * @param {Object} data Optional used directly to add the directives, but is mostly for VUe
   * @return {Void}
   */
  function registerThis(element, data) {
    // Register only unique non indexed elements
    if (!element.getAttribute('data-adaptive-id')) {
      var uniqueId = element.getHash();
      var settings = (0,knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.getDirectivesFromString)(data || element.getAttribute('data-adaptive')).directive;

      //set the unique id to the element for later use
      element.domElement.setAttribute('data-adaptive-id', uniqueId);
      domElements[uniqueId] = new _classes_AdaptiveElement_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
        adaptiveId: uniqueId,
        helper: element,
        domElement: element.domElement,
        xpath: element.getXpathTo(),
        settings: settings,
        useVue: useVue,
        useReact: useReact
      }, $this);
      return uniqueId;
    }
  }

  /**
   * @memberof Adaptive
   * @inner
   * Register A custom Query Min, Max
   * @param {String} id Identifier
   * @param {Number} min Number only, no units attached as it only handles pixels here
   * @param {Number} max Number only, no units attached as it only handles pixels here
   * @return {Void}
   */
  $this.addQueryMinMax = function (id, min, max) {
    if (!customMinMaxQueries[id]) {
      if (!min || !max) {
        throw new Error('Min or Max must be passed (id, min, max)', 1);
      }
      customMinMaxQueries[id] = [min, max];
    }
  };

  /**
   * @memberof Adaptive
   * @inner
   * Register A custom Query Expression
   * @param {String} id Identifier
   * @param {String} query Media query, example "screen and (max-width: 500em) and (orientation: landscape)"
   * @param {Number} max Number only, no units attached as it only handles pixels here
   * @return {Void}
   */
  $this.addQueryExpression = function (id, query) {
    if (!customExpressionQueries[id]) {
      customExpressionQueries[id] = query;
    }
  };

  /**
   * @memberof Adaptive
   * @inner
   * Register A custom Query Expression
   * @param {String} breakdownId Identifier like "tablet" or "mobile", etc
   * @param {Fucntion|Array} callback Function/Method or Array with object and property to set
   * @example Adaptive.if('mobile', [object, propertyId]) || Adaptive.if('mobile', () => {})
   * @return {Object} Proxy
   */
  $this["if"] = function (breakdownId) {
    var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var isFunction = callback && typeof callback === 'function';
    var isArray = callback && Array.isArray(callback);
    var observer = {};
    observer[breakdownId] = {
      _private: ['breakdownId', 'match', 'ifElse', 'do', 'removeAfterExec'],
      _mutable: ['ifElse', 'match', 'removeAfterExec'],
      uid: (0,knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.getDynamicId)(),
      breakdownId: breakdownId,
      match: false,
      executed: false,
      removeAfterExec: false,
      ifElse: null,
      "else": function _else(ifElse) {
        if (ifElse && typeof ifElse === 'function') {
          this.ifElse = ifElse;
        }
      },
      onlyOnce: function onlyOnce() {
        this.removeAfterExec = true;
        if (this.executed) {
          _QueryHandler_js__WEBPACK_IMPORTED_MODULE_3__["default"].remove(this.uid, 'uid');
        }
      },
      "do": function _do() {
        if (this.match) {
          if (isFunction) {
            callback();
          }
          if (isArray) {
            callback[0][callback[1]] = true;
          }
          if (this.removeAfterExec) {
            _QueryHandler_js__WEBPACK_IMPORTED_MODULE_3__["default"].remove(this.uid, 'uid');
          }
          this.executed = true;
          return true;
        }
        if (isArray) {
          callback[0][callback[1]] = false;
        }
        if (this.ifElse) {
          this.ifElse();
        }
        return false;
      }
    };
    _QueryHandler_js__WEBPACK_IMPORTED_MODULE_3__["default"].add(observer, function (o) {
      o.match = true;
      o["do"]();
    }, function (o) {
      o.match = false;
      o["do"]();
    }, $this);
    return (0,knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.proxyObject)(observer[breakdownId]);
  };

  /**
   * Full reset, handle with care
   * @private
   * @return {Void}
   */
  $this.reset = function () {
    Object.keys(domElements).forEach(function (key) {
      return delete domElements[key];
    });
    knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.DomObserver.cleanup();
    _QueryHandler_js__WEBPACK_IMPORTED_MODULE_3__["default"].reset();
    isMounted = false;
  };

  // =========================================
  // --> DomReady and INIT
  // --------------------------

  /**
   * Real init for the app
   * @private
   */
  function _init() {
    isMounted = true;
    document.querySelectorAll('[data-adaptive]:not([data-adaptive-id])').forEach(function (element) {
      $this.registerElement(element);
    });
    _QueryHandler_js__WEBPACK_IMPORTED_MODULE_3__["default"].init();
    if (useVue || useReact) {
      // hybrid mode
      // support for static and dynamic elements
      if (isHybrid) {
        (0,_Teleport_js__WEBPACK_IMPORTED_MODULE_2__.TeleportGlobal)();
      }
    } else {
      // vanilla js
      (0,_Teleport_js__WEBPACK_IMPORTED_MODULE_2__.TeleportGlobal)();
    }
  }

  /**
   * @memberof Adaptive
   * @inner
   * Initialization, cam be called externally to reinitialized after dom loaded
   * @return {Void}
   */
  $this.init = function () {
    if (isMounted) {
      return false;
    }
    if (document.readyState === 'complete' || document.readyState !== 'loading' && !document.documentElement.doScroll) {
      return domIsReady();
    } else {
      // Use the handy event callback
      document.addEventListener('DOMContentLoaded', domIsReady);
      // A fallback to $window.onload, that will always work
      $window.addEventListener('load', domIsReady);
    }
    return;
  };

  /**
   * When ready trigger the initialization
   * @private
   */
  function domIsReady() {
    document.removeEventListener('DOMContentLoaded', domIsReady);
    $window.removeEventListener('load', domIsReady);
    _init();
    return;
  }

  /**
   * @memberof Adaptive
   * @inner
   * For use with Vue
   * @param {Vue} Vue Vue instance
   * @param {Boolean} hybrid Allow support when using static and dynamic
   * @return {Vue}
   */
  $this.useVue = function (Vue) {
    var hybrid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (hybrid) {
      isHybrid = true;
    }
    if (_typeof(Vue) === 'object' && typeof Vue.mixin === 'function') {
      useVue = true;
      var installer = {
        install: function install(app) {
          // For Options API
          app.config.globalProperties.Adaptive = Adaptive;
          // For composition API
          app.provide('Adaptive', Adaptive);
        }
      };

      /**
       * Adaptive used as vue.$Adaptive
       * @private
       */
      Vue.use(installer);
      /**
       * Adaptive used as v-adaptive
       * @private
       */
      Vue.directive('adaptive', {
        mounted: function mounted(element, binding) {
          Adaptive.registerElement(element, binding.value);
        }
      });

      /**
       * Adaptive used as v-teleport-to
       * @private
       */
      Vue.directive('teleport-to', {
        mounted: function mounted(element, binding) {
          return new _Teleport_js__WEBPACK_IMPORTED_MODULE_2__.Teleport(element).beam(binding.value);
        }
      });
      Vue.component('TeleportTo', _vue_components_TeleportTo_js__WEBPACK_IMPORTED_MODULE_4__["default"]);

      /**
       * Adaptive used for non Vue elements register with data-adaptive attr
       * Hybrid mode
       * @private
       */
      Vue.mixin({
        mounted: function mounted() {
          return Adaptive.init();
        }
      });
    }
    return Vue;
  };

  //docs
  /**
   * For use with Web Components
   * @private
   * @return {Void}
   */
  $this.useWebComponent = function () {
    if (!useWeb && !useVue) {
      (0,_web_components_TeleportTo_js__WEBPACK_IMPORTED_MODULE_5__["default"])();
      useWeb = true;
    }
  };

  /**
   * @memberof Adaptive
   * @inner
   * For use with React
   * @param {React} React React instance
   * @param {Boolean} hybrid Allow support when using static and dynamic
   * @return {Void}
   */
  $this.useReact = function (React) {
    var hybrid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (hybrid) {
      isHybrid = true;
    }
    if (_typeof(React) === 'object') {
      $this.useWebComponent();
      useReact = true;
    }
  };
  $window.$adaptive = Adaptive;
  return $window.$adaptive;
}();


/***/ }),

/***/ "./src/QueryHandler.js":
/*!*****************************!*\
  !*** ./src/QueryHandler.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   QueryHandler: () => (/* binding */ QH),
/* harmony export */   "default": () => (/* binding */ QH),
/* harmony export */   queryHandler: () => (/* binding */ QH)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _readOnlyError(name) { throw new TypeError("\"" + name + "\" is read-only"); }
// Author Knighttower
// MIT License
// Copyright (c) [2022] [Knighttower] https://github.com/knighttower

/**
 * @class CSS Query Handler
 * @return QueryHandler
 */
var QH = function QueryHandler() {
  'use strict';
  var $window = typeof window !== 'undefined' ? window : {};
  /**
   * Query Handler Class Object
   * @private
   * @return {Object}
   */
  var $this = {};
  var QueryHandler = new Proxy($this, {
    get: function get(target, prop) {
      if (prop in target) {
        return target[prop];
      }
    }
  });

  /**
   * Holds memory of registered queries expressions
   * @private
   */
  var registeredQueries = {};

  /**
   * Holds memory of registered queries to match
   * @private
   */
  var domQueriesMatch = {};

  /**
   * Holds memory of registered queries to Unmatch
   * @private
   */
  var domQueriesUnMatch = {};

  /**
   * Flag
   * @private
   */
  var loaded = false;

  // =========================================
  // --> PUBLIC
  // --------------------------

  /**
   * Register a query
   * @param {Object} queries Media queries with breakdowns and directives
   * @param {Function} matchCallback Callback
   * @param {Function|Null} unMatchCallback Callback
   * @param {Object|Null} Adaptive When in use with Adaptive.js object
   * @return {Void}
   */
  $this.add = function (queries, matchCallback) {
    var unMatchCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var Adaptive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    for (var query in queries) {
      var _getPreset;
      // Values are the classes, styles, functions
      var values = queries[query];

      // Set a preset if found or just the query in case is custom
      var queryExpression = (_getPreset = getPreset(query, Adaptive)) !== null && _getPreset !== void 0 ? _getPreset : query;

      // If it does not exists, add it as an array
      if (!domQueriesMatch[queryExpression]) {
        domQueriesMatch[queryExpression] = [];
        domQueriesUnMatch[queryExpression] = [];
      }
      domQueriesMatch[queryExpression].push([matchCallback, values]);
      if (unMatchCallback) {
        domQueriesUnMatch[queryExpression].push([unMatchCallback, values]);
      }
      registerQueryListener(queryExpression);
    }
  };

  /**
   * Remove items from domQueriesMatch based on value and prop.
   *
   * @param {any} value - The value to be removed.
   * @param {string} prop - The property to look up in the object.
   */
  $this.remove = function (value, prop) {
    for (var _i = 0, _Object$entries = Object.entries(domQueriesMatch); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
        expression = _Object$entries$_i[0],
        collection = _Object$entries$_i[1];
      var _iterator = _createForOfIteratorHelper(collection),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var reg = _step.value;
          var type = _typeof(reg[1]);
          // LookUp by the prop value when the second array element is an object
          if (prop && type === 'object') {
            if (prop in reg[1] && reg[1][prop] === value) {
              console.log(domQueriesMatch[expression]);
              domQueriesMatch[expression] = domQueriesMatch[expression].filter(function (o) {
                return o[1][prop] !== value;
              });
            }
            // LookUp by the value (function) and prop when the second array element is a string
          } else if (type === 'string' && reg[1] === prop) {
            domQueriesMatch[expression] = domQueriesMatch[expression].filter(function (o) {
              return o[0] !== value;
            });
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  };

  /**
   * Initialization of the class functionality
   * @return {Void}
   */
  $this.init = function () {
    loaded = true;
    Object.keys(domQueriesMatch).forEach(function (queryExpression) {
      // Listener for after initial load
      registerQueryListener(queryExpression);
      // Run the queries on load once
      singleRun(queryExpression);
    });
  };

  /**
   * Reset the whole object | warning
   * @return {Void}
   */
  $this.reset = function () {
    Object.keys(registeredQueries).forEach(function (queryExpression) {
      $window.matchMedia(queryExpression).removeEventListener('change', registeredQueries[queryExpression]);
      delete registeredQueries[queryExpression];
    });
    Object.keys(domQueriesMatch).forEach(function (key) {
      return delete domQueriesMatch[key];
    });
    Object.keys(domQueriesUnMatch).forEach(function (key) {
      return delete domQueriesUnMatch[key];
    });
  };

  // =========================================
  // --> PRIVATE
  // --------------------------

  function singleRun(queryExpression) {
    var mq = $window.matchMedia(queryExpression);
    if (mq.matches) {
      domQueriesMatch[mq.media].forEach(function (callback) {
        return callback[0](callback[1]);
      });
    }
  }

  /**
   * Get the preset query values present in Adaptive object
   * @private
   */
  function getPreset(queryId) {
    var Adaptive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var presets = {
      q: null,
      // query min-max values preset
      e: null // custom expression preset
    };

    // -----------------------------------------
    // when working with Adaptive.Js
    if (Adaptive) {
      var _presetQs$queryId, _presetEs$queryId;
      var presetQs = Adaptive.getMinMaxQueries();
      var presetEs = Adaptive.getExpQueries();
      presets.q = (_presetQs$queryId = presetQs[queryId]) !== null && _presetQs$queryId !== void 0 ? _presetQs$queryId : null;
      presets.e = (_presetEs$queryId = presetEs[queryId]) !== null && _presetEs$queryId !== void 0 ? _presetEs$queryId : null;
      if (!presets.q && !presets.e) {
        if (queryId.includes('|')) {
          var qs = queryId.split('|');
          var qs1 = qs[0];
          var qs2 = qs[1];
          if (presetQs[qs1] && presetQs[qs2]) {
            return buildExpression(presetQs[qs1], presetQs[qs2], true);
          }
          if (presetEs[qs1] && presetEs[qs2]) {
            return buildExpression(presetEs[qs1], presetEs[qs2], true, true);
          }
        }
      } else {
        // Write the correct expression for the preset min-max
        if (presets.q) {
          return buildExpression(presets.q[0], presets.q[1]);
        }
        // No need to build the expression as it already is
        if (presets.e) {
          return presets.e;
        }
      }
    }
    return null;
  }

  /**
   * @private
   */
  function buildExpression(q1, q2) {
    var isCompound = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var isExpression = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var templateQuery = '(min-width: $1px) and (max-width: $2px)';
    if (isCompound) {
      if (!isExpression) {
        q1 = templateQuery.replace('$1', q1[0]).replace('$2', q1[1]);
        q2 = templateQuery.replace('$1', q2[0]).replace('$2', q2[1]);
      }
      return "".concat(q1, ", ").concat(q2);
    }
    return templateQuery.replace('$1', q1).replace('$2', q2);
  }
  function registerQueryListener(queryExpression) {
    // If not already registered
    // This helps to avoid too many Listeners created
    if (!registeredQueries[queryExpression]) {
      var matchQuery = $window.matchMedia(queryExpression);
      var callback = function callback(mq) {
        if (!mq.matches) {
          domQueriesUnMatch[mq.media].forEach(function (callback) {
            return callback[0](callback[1]);
          });
        } else {
          domQueriesMatch[mq.media].forEach(function (callback) {
            return callback[0](callback[1]);
          });
        }
      };
      registeredQueries[queryExpression] = callback;
      return matchQuery.addEventListener('change', callback);
    }
    // For those added after the loaded event
    if (loaded) {
      singleRun(queryExpression);
    }
  }
  $window.QueryHandler = QueryHandler;
  return $window.QueryHandler;
}();


/***/ }),

/***/ "./src/Teleport.js":
/*!*************************!*\
  !*** ./src/Teleport.js ***!
  \*************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Teleport: () => (/* binding */ Teleport),
/* harmony export */   TeleportGlobal: () => (/* binding */ TeleportGlobal),
/* harmony export */   "default": () => (/* binding */ Teleport),
/* harmony export */   teleport: () => (/* binding */ Teleport)
/* harmony export */ });
/* harmony import */ var knighttower_utility__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! knighttower/utility */ "./node_modules/knighttower/packages/utility/index.js");
/* harmony import */ var knighttower_type_check__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! knighttower/type-check */ "./node_modules/knighttower/packages/type-check/index.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// author Knighttower
//  MIT License
//  Copyright (c) [2022] [Knighttower] https://github.com/knighttower



/**
 * @module Teleport
 * Teleport an element to another place in the DOM before, inside or after a target
 * @param {Object|String} props || selector - props object (domElement: element, adaptiveId: null|uniqueId})
 * @example new Teleport({domElement: element, adaptiveId: uniqueId}).beam({to: selector})
 * @example new Teleport(domElement).beam({after: selector})
 * @example new Teleport(domElement).beam({before: selector})
 * @example new Teleport(domElement).beam(selector) // defaults to "to" which is inside the selector
 * @example const eleTeleport = new Teleport(domElement) // returns the object with eleTeleport{beam(String|Object), back(), cancel()}
 * @example Make it global so that is available in the browser and works as a 'window' library
 *   TeleportGlobal()
 *      - <div data-teleport="selector"></div>
 *      - <div data-teleport="{before: 'selector'}"></div>
 *     - <div data-teleport="{after: 'selector'}"></div>
 * @feature If the target (element where it will be sent to) is not in the DOM it will wait until it is and then it will beam the element
 * @return {Object} Teleport object
 */
var Teleport = /*#__PURE__*/function () {
  /**
   * Constructor
   * @param {String|Object} selector || props object (see AdaptiveElement)
   * @return {Object}
   */
  function Teleport(props) {
    _classCallCheck(this, Teleport);
    // Early exit if no props are provided
    if (!(0,knighttower_type_check__WEBPACK_IMPORTED_MODULE_1__.validType)(props, 'string|object')) {
      return;
    }
    this.props = props;
    if (!this.props.adaptiveId) {
      var _element$getAttribute;
      var element = (0,knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.selectElement)(this.props);
      var attrId = (_element$getAttribute = element.getAttribute('data-adaptive-id')) !== null && _element$getAttribute !== void 0 ? _element$getAttribute : null;
      // If adaptiveId is not present, create or retrieve it
      var uniqueId = attrId || element.getHash();
      if (!attrId) {
        element.domElement.setAttribute('data-adaptive-id', uniqueId);
      }

      // Update props with additional properties
      this.props = Object.assign({}, this.props, {
        adaptiveId: uniqueId,
        helper: element,
        domElement: element.domElement,
        xpath: element.getXpathTo()
      });
    }
    var placeholder = (0,knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.selectElement)("[name=\"adaptive\"][value=\"".concat(this.props.adaptiveId, "\""));
    if (!placeholder.isInDom()) {
      placeholder = document.createElement('param');
      placeholder.name = 'adaptive';
      placeholder.value = this.props.adaptiveId;
      this.props.domElement.insertAdjacentElement('beforebegin', placeholder);
    }
  }

  /**
   * Beam the element to another place in the DOM
   * This method will look for the "tagert" element if it is in the DOM and it will querying the DOM until it finds it
   * if the target is not found call the cancel() method to stop the observer
   * @param {String|Object} target (selector) directive defaults to "to" || {to|after|before: target}
   * @example new Teleport(domElement).beam({after: selector})
   * @example domElement.beam({after: selector})
   */
  _createClass(Teleport, [{
    key: "beam",
    value: function beam(settings) {
      var _this = this;
      settings = (0,knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.getDirectivesFromString)(settings).directive;

      // Transform settings to an array format
      switch ((0,knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.typeOf)(settings)) {
        case 'string':
          settings = ['default', settings];
          break;
        case 'object':
          // eslint-disable-next-line no-case-declarations
          var key = Object.keys(settings)[0];
          settings = [key, settings[key]];
          break;
        case 'array':
          if (settings.length === 1) {
            settings = ['default', settings[0]];
          }
          break;
      }
      var _settings = settings,
        _settings2 = _slicedToArray(_settings, 2),
        direction = _settings2[0],
        selector = _settings2[1];
      var target = (0,knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.selectElement)(selector);
      var position = 'beforeend';
      switch (direction) {
        case 'before':
          position = 'beforebegin';
          break;
        case 'after':
          position = 'afterend';
          break;
      }
      if (target.isInDom()) {
        target.domElement.insertAdjacentElement(position, this.props.domElement);
        return;
      }

      // Add observer if the target is not in the DOM
      knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.DomObserver.addOnNodeChange(this.props.adaptiveId, function () {
        var observedTarget = (0,knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.selectElement)(selector);
        if (observedTarget.isInDom()) {
          observedTarget.domElement.insertAdjacentElement(position, _this.props.domElement);
          knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.DomObserver.removeOnNodeChange(_this.props.adaptiveId);
        }
      });
    }

    /**
     * Return to its original place
     * @example new Teleport(domElement).back()
     * @example domElement.back()
     */
  }, {
    key: "back",
    value: function back() {
      var target = (0,knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.selectElement)("[name=\"adaptive\"][value=\"".concat(this.props.adaptiveId, "\""));
      if (target.isInDom()) {
        target.domElement.insertAdjacentElement('afterend', this.props.domElement);
        // target.domElement.remove();
      }
    }

    /**
     * If element target is no it the DOM and needs to cancel the observer
     * @example new Teleport(domElement).cancel()
     * @example domElement.cancel()
     */
  }, {
    key: "cancel",
    value: function cancel() {
      knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.DomObserver.removeOnNodeChange(this.props.adaptiveId);
    }
  }]);
  return Teleport;
}(); // Storage
var TeleportIsGlobal = false;

/**
 * Warning, this will make it global and would work with data attr like data-teleport
 * @example new Teleport().global()
 */
function TeleportGlobal() {
  // Exit if already initialized
  if (TeleportIsGlobal) {
    return;
  }

  // Use forEach directly on NodeList
  document.querySelectorAll('[data-teleport]').forEach(function (element) {
    new Teleport(element).beam(element.getAttribute('data-teleport'));
  });

  // Mark as initialized
  TeleportIsGlobal = true;
}


/***/ }),

/***/ "./src/classes/AdaptiveElement.js":
/*!****************************************!*\
  !*** ./src/classes/AdaptiveElement.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AdaptiveElement)
/* harmony export */ });
/* harmony import */ var _Teleport_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Teleport.js */ "./src/Teleport.js");
/* harmony import */ var _QueryHandler_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../QueryHandler.js */ "./src/QueryHandler.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// Author Knighttower
//  MIT License
//  Copyright (c) [2022] [Knighttower] https://github.com/knighttower


// when it imports, it also registers itself as global


/**
 * @class Adds some extra functionality to interact with a DOM element
 * @param {Object} props
 * @param {Object} Adaptive Instance of
 * @return {Object}
 */
var AdaptiveElement = /*#__PURE__*/function () {
  /**
   * Constructor
   * @param {String|Object} selector
   * @return {Object}
   */
  function AdaptiveElement(props, Adaptive) {
    var _this = this;
    _classCallCheck(this, AdaptiveElement);
    _defineProperty(this, "_addClass", function ($classes) {
      $classes = $classes.split(' ');
      $classes.forEach(function ($class) {
        _this.props.domElement.classList.add($class);
      });
      return;
    });
    _defineProperty(this, "_removeClass", function ($classes) {
      $classes = $classes.split(' ');
      $classes.forEach(function ($class) {
        _this.props.domElement.classList.remove($class);
      });
      return;
    });
    this.props = props;
    this.Adaptive = Adaptive;
    for (var directive in props.settings) {
      // Matches the method name and passes the directives
      this[directive](props.settings[directive]);
    }
  }
  _createClass(AdaptiveElement, [{
    key: "addClass",
    value: function addClass(queries) {
      return _QueryHandler_js__WEBPACK_IMPORTED_MODULE_1__["default"].add(queries, this._addClass, this._removeClass, this.Adaptive);
    }
  }, {
    key: "removeClass",
    value: function removeClass(queries) {
      return _QueryHandler_js__WEBPACK_IMPORTED_MODULE_1__["default"].add(queries, this._removeClass, this._addClass, this.Adaptive);
    }
  }, {
    key: "addStyle",
    value: function addStyle(queries) {
      var _this2 = this;
      // Save the original style in memory to not discard them
      this.props.originalStyle = this.props.domElement.getAttribute('style');
      return _QueryHandler_js__WEBPACK_IMPORTED_MODULE_1__["default"].add(queries, function ($styles) {
        // eslint-disable-next-line no-return-assign
        return _this2.props.domElement.style.cssText += $styles;
      }, function () {
        // eslint-disable-next-line no-return-assign
        return _this2.props.domElement.style.cssText = _this2.props.originalStyle;
      }, this.Adaptive);
    }
  }, {
    key: "teleport",
    value: function teleport(queries) {
      var $element = new _Teleport_js__WEBPACK_IMPORTED_MODULE_0__["default"](this.props);
      return _QueryHandler_js__WEBPACK_IMPORTED_MODULE_1__["default"].add(queries, function ($directive) {
        return $element.beam($directive);
      }, function () {
        $element.back();
        return $element.cancel();
      }, this.Adaptive);
    }
  }, {
    key: "execute",
    value: function execute(queries) {
      var $element = this;
      var attrs = {
        adaptiveId: $element.props.uniqueId,
        helper: $element.props.helper,
        domElement: $element.props.domElement,
        xpath: $element.props.xpath
      };
      return _QueryHandler_js__WEBPACK_IMPORTED_MODULE_1__["default"].add(queries, function ($callback) {
        if ($callback && typeof $callback === 'function') {
          return $callback(attrs);
        }
      }, function ($callback) {
        if ($callback && typeof $callback === 'function') {
          return $callback(attrs);
        }
      }, this.Adaptive);
    }
  }]);
  return AdaptiveElement;
}();


/***/ }),

/***/ "./src/vue-components/TeleportTo.js":
/*!******************************************!*\
  !*** ./src/vue-components/TeleportTo.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Adaptive Teleport
 * @module
 * @example <teleport-to target="" position=""></teleport-to>
 * @property {String|Object} target
 * @property {String} target
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'TeleportTo',
  inheritAttrs: false,
  props: {
    target: {
      type: [String, Object],
      require: true
    },
    position: {
      type: String,
      "default": 'to',
      require: false
    }
  },
  setup: function setup(props) {
    var directive = "".concat(props.position, "(").concat(props.target, ")");
    return {
      directive: directive
    };
  },
  template: "\n        <div>\n            <div v-teleport-to=\"directive\">\n                <slot></slot>\n            </div>\n        </div>\n    "
});

/***/ }),

/***/ "./src/web-components/TeleportTo.js":
/*!******************************************!*\
  !*** ./src/web-components/TeleportTo.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ componentTeleportTo)
/* harmony export */ });
/* harmony import */ var _Teleport_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Teleport.js */ "./src/Teleport.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _isNativeFunction(fn) { try { return Function.toString.call(fn).indexOf("[native code]") !== -1; } catch (e) { return typeof fn === "function"; } }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var TeleportTo = /*#__PURE__*/function (_HTMLElement) {
  _inherits(TeleportTo, _HTMLElement);
  var _super = _createSuper(TeleportTo);
  function TeleportTo() {
    _classCallCheck(this, TeleportTo);
    return _super.call(this);
  }
  _createClass(TeleportTo, [{
    key: "connectedCallback",
    value: function connectedCallback() {
      var _this$getAttribute;
      var target = this.getAttribute('target');
      var position = (_this$getAttribute = this.getAttribute('position')) !== null && _this$getAttribute !== void 0 ? _this$getAttribute : 'to';
      var dId = this.getAttribute('data-adaptive-id');
      if (target && !dId) {
        return new _Teleport_js__WEBPACK_IMPORTED_MODULE_0__["default"](this).beam("".concat(position, "(").concat(target, ")"));
      }
    }
  }]);
  return TeleportTo;
}( /*#__PURE__*/_wrapNativeSuper(HTMLElement));
function componentTeleportTo() {
  customElements.define('teleport-to', TeleportTo);
}

/***/ }),

/***/ "./node_modules/knighttower/packages/type-check/dist/esm/TypeCheck.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/knighttower/packages/type-check/dist/esm/TypeCheck.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TypeCheck: () => (/* binding */ typeCheck),
/* harmony export */   _tc: () => (/* binding */ _tc),
/* harmony export */   _tcx: () => (/* binding */ _tcx),
/* harmony export */   _typeCheck: () => (/* binding */ _typeCheck),
/* harmony export */   addTypeTest: () => (/* binding */ addTypeTest),
/* harmony export */   "default": () => (/* binding */ typeCheck),
/* harmony export */   testBuilder: () => (/* binding */ testBuilder),
/* harmony export */   typeCheck: () => (/* binding */ typeCheck),
/* harmony export */   typesMap: () => (/* binding */ typesMap),
/* harmony export */   validType: () => (/* binding */ validType)
/* harmony export */ });
// Author Knighttower
// MIT License
// [2022] [Knighttower] https://github.com/knighttower
/**
 * @module DomObserver
 * Detect DOM changes
 * @name DomObserver
 * @param {window} selector
 * @param {Function}
 * @return DomObserver
 * @example DomObserver.addOnNodeChange('elementIdentifier', () => { console.log('Node changed') })
 * @example DomObserver.removeOnNodeChange('elementIdentifier')
 */
/**
 * Holds memory of registered functions
 * @private
 */
const executeOnNodeChanged$1 = {};
/**
 * Observer
 * @private
 * @return {MutationObserver}
 */
(() => {
    if (typeof window !== 'undefined') {
        const callback = (mutationList) => {
            for (const mutation of mutationList) {
                if (mutation.type === 'childList') {
                    for (const id in executeOnNodeChanged$1) {
                        executeOnNodeChanged$1[id]();
                    }
                }
            }
        };
        const config = {
            childList: true,
            subtree: true,
        };
        const observer = new MutationObserver(callback);
        observer.observe(document.body, config);
    }
})();

// Author Knighttower
// MIT License
// [2022] [Knighttower] https://github.com/knighttower
/**
 * @module DomObserver
 * Detect DOM changes
 * @name DomObserver
 * @param {window} selector
 * @param {Function}
 * @return DomObserver
 * @example DomObserver.addOnNodeChange('elementIdentifier', () => { console.log('Node changed') })
 * @example DomObserver.removeOnNodeChange('elementIdentifier')
 */
/**
 * Holds memory of registered functions
 * @private
 */
const executeOnNodeChanged = {};
/**
 * Observer
 * @private
 * @return {MutationObserver}
 */
(() => {
    if (typeof window !== 'undefined') {
        const callback = (mutationList) => {
            for (const mutation of mutationList) {
                if (mutation.type === 'childList') {
                    for (const id in executeOnNodeChanged) {
                        executeOnNodeChanged[id]();
                    }
                }
            }
        };
        const config = {
            childList: true,
            subtree: true,
        };
        const observer = new MutationObserver(callback);
        observer.observe(document.body, config);
    }
})();

// // -----------------------------------------
// /**
//  * @knighttower
//  * @url knighttower.io
//  * @git https://github.com/knighttower/
//  */
// // -----------------------------------------


/**
 * Converts a given variable to a number if possible.
 * @param {string|number} input - The input variable to convert.
 * @returns {string|number} - The converted number or the original variable.
 * @example convertToNumber(123) // Output: 123 (number)
 * @example convertToNumber(123.45) // Output: 123.45 (number)
 * @example convertToNumber("123") // Output: 123 (number)
 * @example convertToNumber("123.45") // Output: 123.45 (number)
 * @example convertToNumber("abc") // Output: "abc" (original string)
 * @example convertToNumber("123abc") // Output: "123abc" (original string)
 * @example convertToNumber(null) // Output: null (original)
 */
function convertToNumber(input) {
    const isNum = isNumber(input);

    if (isNum !== null) {
        return isNum;
    }
    // Case: String that cannot be converted to a number
    return input;
}

/**
 * Check if there is a value, if not return null or the default value
 * It can test strings, arrays, objects, numbers, booleans
 * @function emptyOrValue
 * @memberof Utility
 * @param {String|Number} value If the value is not empty, returns it
 * @param {String|Number} _default The default value if empty
 * @return mixed
 * @example emptyOrValue('test', 'default') // 'test'
 * @example emptyOrValue('', 'default') // 'default'
 * @example emptyOrValue('test') // 'test'
 * @example emptyOrValue('') // null
 * @example emptyOrValue(0) // 0
 * @example var hello = ''; emptyOrValue(hello) // Null
 * @example var hello = 'test'; emptyOrValue(hello) // 'test'
 * @example var hello = 'test'; emptyOrValue(hello, 'default') // 'test'
 * @example var hello = ''; emptyOrValue(hello, 'default') // 'default'
 * @example var hello = []; emptyOrValue(hello, 'default') // null
 * @example var hello = {}; emptyOrValue(hello, 'default') // null
 * @example var hello = [...]; emptyOrValue(hello') // [...]
 */
function emptyOrValue(value, _default = null) {
    /**
     * Test sequence:
     * If it is a number 0> : true
     * If is not undefined: true
     * If it is boolean (true|false) prevents going to empty
     * If it is not Empty, [], null, {}, 0, true, false: true
     */

    if (isNumber(value) !== null || typeof value === 'boolean') {
        return value;
    } else if (!isEmpty$1(value)) {
        return value;
    }

    return _default;
}

/**
 * Generate unique ids
 * @function getDynamicId
 * @memberof Utility
 * @return string Format kn__000000__000
 */
function getDynamicId() {
    return 'kn__' + new Date().getTime() + '__' + Math.floor(Math.random() * (999 - 100));
}

/**
 * Alias to getDynamicId
 * @function getRandomId
 * @memberof Utility
 * @return string
 * @example getRandomId() // kn__000000__000
 */
const getRandomId = getDynamicId;

/**
 * Check if a value is empty
 * @function isEmpty
 * @memberof Utility
 * @param {string|array|object|map|set|number|boolean} value
 * @url https://moderndash.io/
 * @return {string}
 */
function isEmpty$1(value) {
    if (value === null || value === undefined) {
        return true;
    }

    if (typeof value === 'string' || Array.isArray(value)) {
        return value.length === 0;
    }

    if (value instanceof Map || value instanceof Set) {
        return value.size === 0;
    }

    if (ArrayBuffer.isView(value)) {
        return value.byteLength === 0;
    }

    if (typeof value === 'object') {
        return Object.keys(value).length === 0;
    }

    return false;
}

/**
 * Check if is a number or Int, if not return null
 * Integrates both Int and Number, or convert a string number to number to test
 * Note: this is not like Lodash isNumber since this one takes into consideration the 'string number'
 * @function isNumber
 * @memberof Utility
 * @param {String|Number} value
 * @return null|int
 * @example isNumber(123) // true
 * @example isNumber(123.45) // true
 * @example isNumber('123abc') // false
 * @example isNumber('abc') // false
 * @example isNumber('') // false
 * @example isNumber("123") // true
 * @example isNumber("123.45") // true
 */
function isNumber(value) {
    const isType = typeof value;
    switch (value) {
        case null:
        case undefined:
        case '':
            return null;
        case '0':
        case 0:
            return 0;
        default:
            if (isType === 'number' || isType === 'string') {
                if (typeof value === 'number' || !Number.isNaN(Number(value))) {
                    return +value;
                }
            }

            break;
    }

    return null;
}

/**
 * Check the type of a variable, and get the correct type for it. It also accepts simple comparisons
 * For more advance type checking see https://github.com/knighttower/JsTypeCheck
 * @param {any} input - The variable to check
 * @param {string} test - The types to check against, piped string
 * @return {string|boolean} - The type of the variable
 * @example typeOf('hello', 'string') // returns true
 * @example typeOf('hello', 'number') // returns false
 * @example typeOf('hello', 'string') // returns true
 * @example typeOf('hello') // returns 'string'
 * @example typeOf({}) // returns 'object'
 */
function typeOf$1(input, test) {
    // Special case for null since it can be treated as an object
    if (input === null) {
        if (test) {
            return test === null || test === 'null' ? true : false;
        }
        return 'null';
    }

    let inputType;

    switch (typeof input) {
        case 'number':
        case 'string':
        case 'boolean':
        case 'undefined':
        case 'bigint':
        case 'symbol':
        case 'function':
            inputType = typeof input;
            break;
        case 'object':
            inputType = Array.isArray(input) ? 'array' : 'object';

            break;
        default:
            inputType = 'unknown';
    }

    if (test) {
        if (test.includes('|')) {
            for (let type of test.split('|')) {
                if (inputType === type) {
                    return type;
                }
            }
            return false;
        }

        return test === inputType;
    }

    return inputType;
}

// Author Knighttower
// MIT License
// Copyright (c) [2022] [Knighttower] https://github.com/knighttower


// @private
function _removeBrackets(strExp) {
    const regex = /^(\[|\{)(.*?)(\]|\})$/; // Match brackets at start and end
    const match = strExp.match(regex);

    if (match) {
        return match[2].trim(); // Extract and trim the content between brackets
    }

    return strExp; // Return the original string if no brackets found at start and end
}

/**
 * Clean a string from delimeters or just trimmed if no delimeters given
 * @funtion cleanStr
 * @param {String} str - String to use
 * @param {String|Regex} p1 - Delimeter 1
 * @param {String|Regex} p2 - Delimeter 2
 * @return {String|void}
 * @example cleanStr('hello world', 'h', 'd') // 'ello worl'
 * @example cleanStr('  hello world  ') // 'hello world'
 * @example cleanStr('hello world', 'hello') // 'world'
 * @example cleanStr('Hello World. Sunshine is here!', '\..*!') // Hello World
 * @example cleanStr('Hello World. Sunshine is here!', /Hello/g) // ' World. Sunshine is here!'
 * @example cleanStr('Hello World. Sunshine is here!', /Hello/g, /Sunshine/g) // ' World.  is here!'
 */
function cleanStr(str, ...args) {
    if (!str) {
        return;
    }
    if (typeof str !== 'string') {
        return str;
    }

    return args
        .reduce((accStr, arg) => {
            const regex = arg instanceof RegExp ? arg : new RegExp(setExpString(arg));
            return accStr.replace(regex, '');
        }, str)
        .trim();
}

/**
 * Find the last instance of nested pattern with delimeters
 * @function findNested
 * @param {string} str
 * @param {string} start - Delimeter 1
 * @param {string} end - Delimeter 2
 * @return {string|null}
 * @example findNested('[[]hello [world]]', '[', ']') // [world]
 */
function findNested(str, start = '[', end = ']') {
    if (typeof str !== 'string') {
        return str;
    }
    // Find the last index of '['
    const lastIndex = str.lastIndexOf(start);
    // If '[' is not found, return null or some default value
    if (lastIndex === -1) {
        return null;
    }

    // Extract the substring starting from the last '[' to the end
    const substring = str.substring(lastIndex);
    // Find the index of the first ']' in the substring
    const endIndex = substring.indexOf(end);
    // If ']' is not found, return null or some default value
    if (endIndex === -1) {
        return null;
    }
    // Extract and return the content between the last '[' and the next ']', including them
    return substring.substring(0, endIndex + 1);
}

/**
 * Converts strings formats into objects or arrays
 * Note: quoted strings are not supported, use getDirectiveFromString instead
 * @param {string} strExp
 * @return {object|array|string}
 * @example getArrObjFromString('[[value,value],value]') // [['value', 'value'], 'value']
 * @example getArrObjFromString('[[value,value],value, { y: hello }, hello]') // [['value', 'value'], 'value', { y: 'hello' }, 'hello']
 * @example getArrObjFromString('{ y: hello, x: world, z: [value,value]}') // { y: 'hello', x: 'world', z: ['value', 'value'] }
 */
function getArrObjFromString(strExp) {
    // alredy typeof object or array just return it
    if (typeOf$1(strExp, 'object') || typeOf$1(strExp, 'array')) {
        return strExp;
    }
    const isObject = startAndEndWith(strExp, '{', '}');
    const isArray = startAndEndWith(strExp, '[', ']');
    // If it is other type of string, return it
    if (!isObject && !isArray) {
        return strExp;
    }

    const newCollection = isObject ? {} : [];
    const nestedElements = {};

    //remove the brackets
    let newStrExp = _removeBrackets(strExp);

    const loopNested = (objects = false) => {
        // ignore eslint comment
        // eslint-disable-next-line no-constant-condition
        while (true) {
            //find any nested arrays or objects
            let matched = objects ? findNested(newStrExp, '{', '}') : findNested(newStrExp);

            if (!matched) {
                break;
            }

            //replace the nested array or object with a marker so that we can safely split the string
            let marker = `__${getRandomId()}__`;
            nestedElements[marker] = matched;

            newStrExp = newStrExp.replace(matched, marker);
        }
    };

    loopNested();
    loopNested(true);

    getChunks(newStrExp).forEach((chunk, index) => {
        const isObjectKey = chunk.includes(':') && isObject;
        const chunkParts = isObjectKey ? getChunks(chunk, ':') : [];
        const chunkKey = removeQuotes(emptyOrValue(chunkParts[0], index));
        chunk = isObjectKey ? chunkParts[1] : chunk;
        if (chunk in nestedElements) {
            chunk = getArrObjFromString(nestedElements[chunk]);
        }
        chunk = convertToNumber(removeQuotes(chunk));
        // set back in the collection either as an object or array
        isObject ? (newCollection[chunkKey] = chunk) : newCollection.push(chunk);
    });
    // uncomment to debug
    // console.log('___ log ___', newCollection);
    return newCollection;
}
/**
 * Splits a string into chunks by a given splitter and cleans the chunks
 * @param {string} str
 * @param {string} splitter - The string/character to split the string by. Defaults to ','
 * @return {string|array}
 */
function getChunks(str, splitter = ',') {
    if (typeof str !== 'string') {
        return str;
    }
    if (isEmpty$1(str)) {
        return [];
    }
    str = cleanStr(str);
    let chunks = str.split(splitter).map((t) => cleanStr(t));
    return chunks.length === 1 && chunks[0] === '' ? [str] : chunks;
}

/**
 * Remove quotes from a string
 * @function removeQuotes
 * @param {String} str
 * @return {String}
 * @example removeQuotes('"hello"') // hello
 * @example removeQuotes("'hello'") // hello
 */
function removeQuotes(str) {
    if (typeof str !== 'string') {
        return str;
    }
    return str.replace(/`|'|"/g, '');
}

/**
 * Checks if a string starts and ends with a given string
 * @param {string} strExp
 * @param {string} start - The string/character to check it starts with
 * @param {string} end - The string/character to check it ends with
 * @return {string}
 * @example startAndEndWith('hello world', 'h', 'd') // false
 * @example startAndEndWith('hello world', 'h', 'd') // true
 */
function startAndEndWith(strExp, start = null, end = null) {
    return (!start || strExp.startsWith(start)) && (!end || strExp.endsWith(end));
}

/**
 * Scapes a string to create a regex or returns the regex if it already is an expression
 * @function setExpString
 * @param {String|Regex} exp
 * @return {String|Regex}
 * @example setExpString('hello') // '\h\e\l\l\o'
 * @example setExpString(/hello/) // /hello/
 * @example setExpString([hello]) // \\[hello\\/ then use like new new RegExp(setExpString(StringOrRegex))
 */
function setExpString(exp) {
    if (exp instanceof RegExp) {
        return exp;
    } else {
        return exp
            .split('')
            .map((char) =>
                ['$', '^', '.', '*', '+', '?', '(', ')', '[', ']', '{', '}', '|', '\\'].includes(char)
                    ? `\\${char}`
                    : char
            )
            .join('');
    }
}

// // -----------------------------------------
// /**
//  * @knighttower
//  * @url knighttower.io
//  * @git https://github.com/knighttower/
//  */
// // -----------------------------------------


/**
 * Check if a value is empty
 * @function isEmpty
 * @memberof Utility
 * @param {string|array|object|map|set|number|boolean} value
 * @url https://moderndash.io/
 * @return {string}
 */
function isEmpty(value) {
    if (value === null || value === undefined) {
        return true;
    }

    if (typeof value === 'string' || Array.isArray(value)) {
        return value.length === 0;
    }

    if (value instanceof Map || value instanceof Set) {
        return value.size === 0;
    }

    if (ArrayBuffer.isView(value)) {
        return value.byteLength === 0;
    }

    if (typeof value === 'object') {
        return Object.keys(value).length === 0;
    }

    return false;
}

/**
 * Check the type of a variable, and get the correct type for it. It also accepts simple comparisons
 * For more advance type checking see https://github.com/knighttower/JsTypeCheck
 * @param {any} input - The variable to check
 * @param {string} test - The types to check against, piped string
 * @return {string|boolean} - The type of the variable
 * @example typeOf('hello', 'string') // returns true
 * @example typeOf('hello', 'number') // returns false
 * @example typeOf('hello', 'string') // returns true
 * @example typeOf('hello') // returns 'string'
 * @example typeOf({}) // returns 'object'
 */
function typeOf(input, test) {
    // Special case for null since it can be treated as an object
    if (input === null) {
        if (test) {
            return test === null || test === 'null' ? true : false;
        }
        return 'null';
    }

    let inputType;

    switch (typeof input) {
        case 'number':
        case 'string':
        case 'boolean':
        case 'undefined':
        case 'bigint':
        case 'symbol':
        case 'function':
            inputType = typeof input;
            break;
        case 'object':
            inputType = Array.isArray(input) ? 'array' : 'object';

            break;
        default:
            inputType = 'unknown';
    }

    if (test) {
        if (test.includes('|')) {
            for (let type of test.split('|')) {
                if (inputType === type) {
                    return type;
                }
            }
            return false;
        }

        return test === inputType;
    }

    return inputType;
}

// typeOf is used here insteand of the native typeof because it can handle better the identifications of arrays and objects

const typesMap = new Map([
    ['array', (_var_) => typeOf(_var_, 'array')],
    ['bigInt', (_var_) => typeof _var_ === 'bigint'],
    ['boolean', (_var_) => typeof _var_ === 'boolean'],
    ['date', (_var_) => _var_ instanceof Date],
    ['float', (_var_) => typeof _var_ === 'number' && !Number.isInteger(_var_)],
    ['function', (_var_) => typeof _var_ === 'function'],
    ['int', (_var_) => Number.isInteger(_var_)],
    ['map', (_var_) => _var_ instanceof Map],
    ['null', (_var_) => _var_ === null],
    ['number', (_var_) => typeof _var_ === 'number'],
    ['object', (_var_) => typeOf(_var_, 'object')],
    ['promise', (_var_) => _var_ instanceof Promise],
    ['regExp', (_var_) => _var_ instanceof RegExp],
    ['set', (_var_) => _var_ instanceof Set],
    ['string', (_var_) => typeof _var_ === 'string'],
    ['symbol', (_var_) => typeof _var_ === 'symbol'],
    ['undefined', (_var_) => typeof _var_ === 'undefined'],
    ['weakMap', (_var_) => _var_ instanceof WeakMap],
    ['weakSet', (_var_) => _var_ instanceof WeakSet],
]);

//  type definitions

// =========================================
// --> STORAGE
// --------------------------
// Cache storage for tests
const cachedTests = new Map();
const cachedPipedTypes = new Map();

// =========================================
// --> Utility functions
// --------------------------

/**
 * If the type is a union type, split it and return the tests for each type
 * @param {string} str
 * @return {array} tests
 */
function getPipedTypes(str) {
    if (cachedPipedTypes.has(str)) {
        return cachedPipedTypes.get(str);
    }
    return str.split('|').reduce((testsForKey, t) => {
        let itCanBeNull = false;
        let type = t.trim();

        if (type.endsWith('?')) {
            type = type.slice(0, -1);
            itCanBeNull = true;
        }
        // lookup the test for the type and add it to the testsForKey array
        const typeObj = typesMap.get(type);
        const test = typeObj ?? isNoType(type);
        if (test) {
            testsForKey.push(test);
        }
        // for optional types, add the tests for null and undefined
        if (itCanBeNull) {
            testsForKey.push(typesMap.get('null'), typesMap.get('undefined'));
        }
        cachedPipedTypes.set(str, testsForKey);
        return testsForKey;
    }, []);
}

/**
 * Get the tests for a type
 * @param {string} type
 * @return {function[]} tests
 * @throws {Error} if type is not supported
 */
function isNoType(type) {
    throw new Error(`Type Error: "${type}" is not supported`);
}

/**
 * Determine the type of the expression
 * @param {any} strExp
 * @return {string}
 */
function determineMethod(strExp) {
    if (typeOf(strExp, 'array') || typeOf(strExp, 'object')) {
        return typeOf(strExp);
    }
    const __str = strExp.trim();
    if (startAndEndWith(__str, '[', ']')) {
        return 'array';
    }
    if (startAndEndWith(__str, '{', '}')) {
        return 'object';
    }
    return 'basic';
}

// =========================================
// --> Handlers for different types
// --------------------------

/**
 * Basic single types
 * @param {string} typeStr
 * @return {object} tests
 */
const basicTypes = (typeStr) => {
    return getPipedTypes(typeStr);
};

/**
 * Handle array types
 * @param {string} strExp
 * @return {array} tests
 */
const arrayTypes = (strExp) => {
    const testUnit = [];
    const convertedObj = getArrObjFromString(strExp);

    convertedObj.forEach((test) => {
        testUnit.push(testBuilder(test));
    });
    return testUnit;
};

/**
 * Handle object types
 * @param {string} strExp
 * @return {object} tests
 */
const objectTypes = (strExp) => {
    return new (class handleObjects {
        constructor() {
            this.testUnit = new Map([
                ['tests', new Map()],
                ['optionalKeys', []],
                ['testFew', []],
                ['testAllAny', false],
                ['testOnly', false],
            ]);

            return this.handleObject();
        }

        checkOptionalKey(key) {
            if (key.endsWith('?')) {
                key = key.slice(0, -1);
                this.testUnit.get('optionalKeys').push(key);
            }
            return key;
        }

        checkTheAnyKey(obj) {
            if ('any' in obj) {
                const keys = Object.keys(obj);
                if (keys.length === 1) {
                    this.testUnit.set('testAllAny', true);
                } else {
                    this.testUnit.set(
                        'testFew',
                        keys.filter((key) => key !== 'any')
                    );
                }
            }
        }

        handleObject() {
            const convertedObj = getArrObjFromString(strExp);
            this.checkTheAnyKey(convertedObj);
            for (const key in convertedObj) {
                const cleanKey = this.checkOptionalKey(key);
                const value = convertedObj[key];

                if (value === '...') {
                    delete convertedObj[key];
                    this.testUnit.set('testOnly', true);
                    continue;
                }

                this.testUnit.get('tests').set(cleanKey, testBuilder(value));
            }

            return this.testUnit;
        }
    })();
};

/**
 * Build the test unit
 * @param {any} strExp String expression
 * @return {object} testUnit
 * @throws {Error} if type is not supported
 * @example testBuilder('number') // returns {testMethod: 'basic', tests: [function]}
 * @example testBuilder('[number]') // returns {testMethod: 'array', tests: [[function]]}
 * @example testBuilder('{any: number}') // returns {testMethod: 'object', tests: {any: [function]}}
 * @usage See more cases in the 'type-pattern.txt' file
 */
function testBuilder(strExp) {
    if (cachedTests.has(strExp)) {
        return cachedTests.get(strExp);
    }
    let testUnit = new Map([
        ['testMethod', determineMethod(strExp)],
        ['tests', null],
    ]);

    switch (testUnit.get('testMethod')) {
        case 'basic':
            testUnit.set('tests', basicTypes(strExp));
            break;
        case 'array':
            testUnit.set('tests', arrayTypes(strExp));
            break;
        case 'object':
            /* eslint-disable-next-line */
            const objTypes = objectTypes(strExp);
            testUnit = new Map([...testUnit, ...objTypes]);
            break;
        default:
            isNoType(strExp);
    }

    cachedTests.set(strExp, testUnit);
    return testUnit;
}

/**
 * Add a new type test
 * @param {string} name The name of the test to add
 * @param {function} testUnit The test function
 * @return {boolean} true if the test was added
 * @throws {Error} if the test already exists
 */
const addTypeTest = (name, testUnit) => {
    if (!typesMap.has(name)) {
        typesMap.set(name, testUnit);
        return true;
    }

    return `"${name}" already exists!`;
};

// Error collectot
const typeErrorLogs = [];
// Setting cache
const cachedSettings = new Map();

const runBasicTest = (inputVal, tests) => {
    return tests.some((test) => {
        const testResult = test(inputVal);

        if (!testResult) {
            pushToErrorLogs(inputVal, tests);
        }
        return testResult;
    });
};

const runArrayTest = (inputVal, tests) => {
    // If the input is not an array, return false
    if (!typeOf(inputVal, 'array') || inputVal.length === 0) {
        return false;
    }
    // Else, test each value in the array
    return tests.every((test, index) => {
        // console.log('is array: ', inputVal[index], test);
        return runRouteTest(inputVal[index], test);
    });
};

class HandleObjects {
    constructor(inputVal, unitTest) {
        // Extract all properties at once
        const { testOnly, testFew, testAllAny, optionalKeys, tests } = [...unitTest.entries()].reduce(
            (acc, [key, value]) => ({ ...acc, [key]: value }),
            {}
        );
        // Use destructured variables
        this.testUnitKeys = [...tests.keys()];
        this.testOnly = testOnly;
        this.testFew = testFew;
        this.testAllAny = testAllAny;
        this.optionalKeys = optionalKeys;
        this.testCollection = tests;
        // the input object to test
        this.inputObject = inputVal;
    }

    handleUnitTest() {
        switch (true) {
            case this.testAllAny:
                // '{any: type}' // any key
                return this.testObjAllAny();
            case !isEmpty(this.testFew):
                // '{key1: type, any: type}'; // specific key, and all other "any"
                // test the testFew fist so that we can remove them from the inputObject
                /* eslint-disable-next-line */
                const testFewResults = this.testObjFew();
                // remove the testFew from the inputObject
                this.filterOutFew();
                return testFewResults && this.testObjAllAny();
            case !isEmpty(this.optionalKeys):
                // '{key1?: type, key2?: type}'; // optional keys
                // test the optionalKeys fist so that we can remove them from the inputObject
                /* eslint-disable-next-line */
                const optionalKeysResults = this.testObjOptionalKeys();
                // remove the optionalKeys from the inputObject
                this.filterOutOptionalKeys();
                return optionalKeysResults && this.defaultTest();
            case !this.testOnly:
                // '{key1: type, key2: type}'; // all keys
                for (const k in this.inputObject) {
                    if (!this.testCollection.has(k)) {
                        pushToErrorLogs(
                            this.inputObject,
                            `Key: "${k}" not found in the test collection, or use the "any" (any:[type]) key test or "..." after the last key in the test collection {key1: type, key2: type, ...} to only test a few keys.`
                        );
                        return false;
                    }
                }
                // when testOnly, it will bypass this and check only those found in the test collection
                // even if the test value has more keys
                break;
        }

        return this.defaultTest();
    }

    filterOutOptionalKeys() {
        this.testUnitKeys = this.testUnitKeys.filter((item) => !this.optionalKeys.includes(item));
    }

    filterOutFew() {
        this.inputObject = Object.fromEntries(
            Object.entries(this.inputObject).filter(([key]) => !this.testFew.includes(key))
        );
    }

    testObjOptionalKeys() {
        return this.optionalKeys.every((key) => {
            const test = this.testCollection.get(key);
            const testValue = this.inputObject[key];
            return !testValue ? true : runRouteTest(testValue, test);
        });
    }

    testObjFew() {
        return this.testFew.every((key) => {
            const test = this.testCollection.get(key);
            const testValue = this.inputObject[key];

            return runRouteTest(testValue, test);
        });
    }

    testObjAllAny() {
        const testValues = Object.values(this.inputObject);
        if (testValues.length === 0) {
            return runRouteTest(null, this.testCollection.get('any'));
        }
        return testValues.every((value) => {
            return runRouteTest(value, this.testCollection.get('any'));
        });
    }

    defaultTest() {
        return this.testUnitKeys.every((key) => {
            const test = this.testCollection.get(key);
            const testValue = this.inputObject[key];
            return runRouteTest(testValue, test);
        });
    }
}

const runObjectTest = (inputVal, unitTest) => {
    if (!typeOf(inputVal, 'object')) {
        return false;
    }
    return new HandleObjects(inputVal, unitTest).handleUnitTest();
};

function runRouteTest(inputVal, unitTest) {
    const testMethod = unitTest.get('testMethod');
    const tests = unitTest.get('tests');

    switch (testMethod) {
        case 'basic':
            return runBasicTest(inputVal, tests);
        case 'array':
            return runArrayTest(inputVal, tests);
        case 'object':
            return runObjectTest(inputVal, unitTest); // No change here as the entire Map is passed
        default:
            return false;
    }
}

/**
 * Get settings either from an object or a string keyword.
 * @param {Object | string} input - The settings object or keyword for predefined settings.
 * @return {object | null} - The settings object.
 */
function getSettings(input) {
    if (input) {
        if (cachedSettings.has(input)) {
            return cachedSettings.get(input);
        }
        // Check if input is an object
        const type = typeof input;
        let _val = null;
        switch (type) {
            case 'function':
                _val = { callback: input };
                break;
            case 'object':
                _val = input;
                break;
            case 'string':
                switch (input) {
                    case 'log':
                        _val = { log: true };
                        break;
                    case 'fail':
                        _val = { fail: true };
                        break;
                    case 'return':
                        _val = { return: true };
                        break;
                    case 'validOutput':
                        _val = { validOutput: input };
                        break;
                }
                break;
        }
        cachedSettings.set(input, _val);
        return _val;
    }

    return {
        log: false,
        fail: false,
        return: false,
        validOutput: false,
        callback: null,
    };
}

/**
 * Throw an error with the last typeErrorLogs
 */
function typeError(inputVal) {
    const errorLog = typeErrorLogs[typeErrorLogs.length - 1];

    console.log('\n::::::::::::: Type error or not valid ::::::::::::::');
    console.log('Input Value used: ', inputVal);
    console.log('---> Value Found:', errorLog.found);
    console.log('---> Test Permormed:', errorLog.tests);
    //clean the array of error logs
    typeErrorLogs.length = 0;
    throw new Error(
        `\n\n---------------------\nTypeCheck Error --->\n\n The value must not be of type (Type found) = "${errorLog.found}". \n\n The Type used is invalid for value: "${errorLog.value}". \n\n see logged error for details\n---------------------\n\n`
    );
}

function pushToErrorLogs(inputVal, tests) {
    typeErrorLogs.push({
        value: JSON.stringify(inputVal),
        tests: JSON.stringify(tests),
        found: typeOf(inputVal),
    });
}

/**
* _TypeCheck
* @param {any} inputVal
* @param {string} typeExp
* @param {object | string} params Parameters for the typeCheck function. 
* @return {bool | any} TypeChecker By default it returns boolean, but if '.return()' is used it will return the inputVal
* @example typeCheck(1, 'number') // true
* @example typeCheck([1], '[number]') // true
* @example typeCheck({x: 1, y: 2}, '{any: number}') // true
* @example typeCheck({ x: 'string', y: 10 }, '{y: number, x: string}', ($this) => {
        console.log('__testLogHere__', $this);
    }) // using call back function
* @usage (anyInputValue, stringTypeExpression, params: object | string)
* @usage params: object = { log: boolean, fail: boolean, callback: function }
* @usage params: string = 'log' | 'fail' | callback: function
* @usage chain Methods: log(), fail(), return() // returns the input value, test() returns the boolean
* @notes This function cannot validate the return value of a function when the validOutput is provided, use _tcx instead
* Params: log = true ; // logs the testData
* Params: fail = true ; // throws an error when the test fails
* Params: return = true ; // returns the inputVal
* Params: callback = function ; // callback function
* @see testUnit for more examples and test cases   
*/
const _typeCheck = (inputVal, typeExp, params) => {
    return new (class {
        constructor() {
            this.unitTest = testBuilder(typeExp);
            this.testResult = runRouteTest(inputVal, this.unitTest);
            this.bool = this.testResult;
            this.settings = getSettings(params);
            this.callback = this.settings.callback ?? null;
            this.testData = {
                typeExp,
                inputVal,
                inputType: typeOf(inputVal),
                callback: this.callback,
                unitTest: this.unitTest,
                testResult: this.testResult,
            };
            if (this.settings.log) {
                this.log();
            }

            if (this.settings.fail) {
                this.fail();
            }

            if (this.callback) {
                this.callback(this.testData);
            }
        }
        test() {
            return this.testResult;
        }
        log() {
            console.log('-------------------------- \n ::: Test Data Info :::');
            console.table(this.testData);
            return this;
        }
        fail() {
            if (!this.testResult) {
                this.log();
                this.settings?.error && console.log('\n\n-----> Error Message: ', this.settings.error);
                return typeError(inputVal);
            }
            return this;
        }
        return() {
            return inputVal;
        }
    })();
};

/**
* _tc is a helper function to wrap a function with typeCheck
* It is basic but faster the _tcx (neglible but if micro-optimization is needed)
* @param {array} typeExp array of types to test
* @param {function} __function Function to wrap
* @param {object | string} params Parameters for the typeCheck function.
* @return {function} Wrapped function
* @example _tc('[number]', function (myVar) {
        //code
        console.log(myVar);
    });
* @usage (stringTypeExpression, Function(), params: object | string)
* @usage params: object = { log: boolean, fail: boolean, return: boolean, validOutput: string }
* @usage params: string = 'log' | 'fail' | 'return' 
* @usage defaults: log = false, fail = true, return = false
* @notes this function does not accept callback arguments and when using shorthand arguments (string) it does not accept validOutput
* Params: log = true ; // logs the testData
* Params: fail = true ; // throws an error when the test fails
* Params: return = true ; // returns the inputVal
* Params: callback = function ; // callback function
* @see directory test for more information and examples
*/
const _tc = (typeExp, __function, params = {}) => {
    return (...args) => {
        params = { ...{ fail: true }, ...params };
        _typeCheck(args, typeExp, params);
        return __function(...args);
    };
};

/**
* _tcx is a helper function to wrap a function with typeCheck
* It is as performant as the _tc but it has a lot more features to offer
* @param {string} typeExp Expression to test
* @param {function} __function Function to wrap
* @param {object | string} params Parameters for the typeCheck function. 
* @return {function} Wrapped function
* @example _tcx('[number]', function (myVar) {
        //code
        console.log(myVar);
    });
* @usage (stringTypeExpression, Function(), params: object | string)
* @usage params: object = { log: boolean, fail: boolean, return: boolean, validOutput: stringTypeExpression }
* @usage params: string = 'log' | 'fail' | 'return'
* @notes This function can validate the return value of a function when the validOutput is provided
* @feature Return value validation
* @feature all instances accept individual fail, log, and return
* @feature all instances accept chaining parameters: myCoolFunction(44.5, 'yes!').log().fail().return()
* Params: log = true ; // logs the testData
* Params: fail = true ; // throws an error when the test fails
* Params: return = true ; // returns the inputVal
* Params: callback = function ; // callback function
* Params: validOutput = stringTypeExpression ; // validate the return value of the function
* @see directory test for more information and examples
*/
const _tcx = (typeExp, __function, params) => {
    let $settings = getSettings(params);
    //set default as true
    $settings = { ...{ fail: true }, ...$settings };
    return (...args) => {
        return new (class {
            constructor() {
                this.args = args;
                this.testResults = _typeCheck(args, typeExp, $settings);
                return this.default();
            }
            default() {
                this.returns = __function(...args);

                const validOutput = $settings.validOutput ?? false;
                if (validOutput) {
                    _typeCheck(this.returns, validOutput, 'fail');
                }
                return this;
            }
            log() {
                this.testResults.log();
                return this;
            }
            fail() {
                this.testResults.fail();
                return this;
            }
            return() {
                return this.returns;
            }
        })();
    };
};

/**
 * Test the type but does not throw an error, althought it can use the rest of the chain methods
 * @param {any} inputVal
 * @param {string} typeExp
 */
const validType = (inputVal, typeExp) => {
    return _typeCheck(inputVal, typeExp).test();
};

/**
* TypeCheck
* @param {any} inputVal
* @param {string} typeExp
* @example typeCheck(1, 'number') // true
* @example typeCheck([1], '[number]') // true
* @example typeCheck({x: 1, y: 2}, '{any: number}') // true
* @example typeCheck({ x: 'string', y: 10 }, '{y: number, x: string}', ($this) => {
        console.log('__testLogHere__', $this);
    }) // using call back function
* @see testUnit for more examples and test cases   
*/
const typeCheck = (inputVal, typeExp, params = null) => {
    return _typeCheck(inputVal, typeExp, params).fail();
};




/***/ }),

/***/ "./node_modules/knighttower/packages/type-check/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/knighttower/packages/type-check/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TypeCheck: () => (/* reexport safe */ _dist_esm_TypeCheck_mjs__WEBPACK_IMPORTED_MODULE_0__.TypeCheck),
/* harmony export */   _tc: () => (/* reexport safe */ _dist_esm_TypeCheck_mjs__WEBPACK_IMPORTED_MODULE_0__._tc),
/* harmony export */   _tcx: () => (/* reexport safe */ _dist_esm_TypeCheck_mjs__WEBPACK_IMPORTED_MODULE_0__._tcx),
/* harmony export */   _typeCheck: () => (/* reexport safe */ _dist_esm_TypeCheck_mjs__WEBPACK_IMPORTED_MODULE_0__._typeCheck),
/* harmony export */   addTypeTest: () => (/* reexport safe */ _dist_esm_TypeCheck_mjs__WEBPACK_IMPORTED_MODULE_0__.addTypeTest),
/* harmony export */   testBuilder: () => (/* reexport safe */ _dist_esm_TypeCheck_mjs__WEBPACK_IMPORTED_MODULE_0__.testBuilder),
/* harmony export */   typeCheck: () => (/* reexport safe */ _dist_esm_TypeCheck_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   typesMap: () => (/* reexport safe */ _dist_esm_TypeCheck_mjs__WEBPACK_IMPORTED_MODULE_0__.typesMap),
/* harmony export */   validType: () => (/* reexport safe */ _dist_esm_TypeCheck_mjs__WEBPACK_IMPORTED_MODULE_0__.validType)
/* harmony export */ });
/* harmony import */ var _dist_esm_TypeCheck_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/esm/TypeCheck.mjs */ "./node_modules/knighttower/packages/type-check/dist/esm/TypeCheck.mjs");
// Single Modules and Aliases from: TypeCheck

// Default Module from: TypeCheck





/***/ }),

/***/ "./node_modules/knighttower/packages/utility/dist/esm/DomObserver.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/knighttower/packages/utility/dist/esm/DomObserver.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DomObserver: () => (/* binding */ DomObserver),
/* harmony export */   "default": () => (/* binding */ DomObserver),
/* harmony export */   domObserver: () => (/* binding */ DomObserver)
/* harmony export */ });
// Author Knighttower
// MIT License
// [2022] [Knighttower] https://github.com/knighttower
/**
 * @module DomObserver
 * Detect DOM changes
 * @name DomObserver
 * @param {window} selector
 * @param {Function}
 * @return DomObserver
 * @example DomObserver.addOnNodeChange('elementIdentifier', () => { console.log('Node changed') })
 * @example DomObserver.removeOnNodeChange('elementIdentifier')
 */
/**
 * Holds memory of registered functions
 * @private
 */
const executeOnNodeChanged = {};
/**
 * When node change
 * @param {String} id
 * @param {Function} callback Callback when any node changes/ add/deleted/modified
 * @return {Void}
 */
const addOnNodeChange = (id, callback) => {
    if (callback) {
        executeOnNodeChanged[id] = callback;
    }
};
/**
 * Remove from node change
 * @param {String} id
 * @return {Void}
 */
const removeOnNodeChange = (id) => {
    if (id) {
        delete executeOnNodeChanged[id];
    }
};
/**
 * Deep cleanup
 * @return {Void}
 */
const cleanup = () => {
    Object.keys(executeOnNodeChanged).forEach((key) => delete executeOnNodeChanged[key]);
};
/**
 * Observer
 * @private
 * @return {MutationObserver}
 */
(() => {
    if (typeof window !== 'undefined') {
        const callback = (mutationList) => {
            for (const mutation of mutationList) {
                if (mutation.type === 'childList') {
                    for (const id in executeOnNodeChanged) {
                        executeOnNodeChanged[id]();
                    }
                }
            }
        };
        const config = {
            childList: true,
            subtree: true,
        };
        const observer = new MutationObserver(callback);
        observer.observe(document.body, config);
    }
})();
const DomObserver = {
    executeOnNodeChanged,
    addOnNodeChange,
    removeOnNodeChange,
    cleanup,
};




/***/ }),

/***/ "./node_modules/knighttower/packages/utility/dist/esm/ElementHelper.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/knighttower/packages/utility/dist/esm/ElementHelper.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ElementHelper: () => (/* binding */ ElementHelper),
/* harmony export */   "default": () => (/* binding */ ElementHelper),
/* harmony export */   elementHelper: () => (/* binding */ ElementHelper),
/* harmony export */   selectElement: () => (/* binding */ selectElement)
/* harmony export */ });
// Author Knighttower
// MIT License
// [2022] [Knighttower] https://github.com/knighttower
/**
 * @module DomObserver
 * Detect DOM changes
 * @name DomObserver
 * @param {window} selector
 * @param {Function}
 * @return DomObserver
 * @example DomObserver.addOnNodeChange('elementIdentifier', () => { console.log('Node changed') })
 * @example DomObserver.removeOnNodeChange('elementIdentifier')
 */
/**
 * Holds memory of registered functions
 * @private
 */
const executeOnNodeChanged = {};
/**
 * When node change
 * @param {String} id
 * @param {Function} callback Callback when any node changes/ add/deleted/modified
 * @return {Void}
 */
const addOnNodeChange = (id, callback) => {
    if (callback) {
        executeOnNodeChanged[id] = callback;
    }
};
/**
 * Remove from node change
 * @param {String} id
 * @return {Void}
 */
const removeOnNodeChange = (id) => {
    if (id) {
        delete executeOnNodeChanged[id];
    }
};
/**
 * Deep cleanup
 * @return {Void}
 */
const cleanup = () => {
    Object.keys(executeOnNodeChanged).forEach((key) => delete executeOnNodeChanged[key]);
};
/**
 * Observer
 * @private
 * @return {MutationObserver}
 */
(() => {
    if (typeof window !== 'undefined') {
        const callback = (mutationList) => {
            for (const mutation of mutationList) {
                if (mutation.type === 'childList') {
                    for (const id in executeOnNodeChanged) {
                        executeOnNodeChanged[id]();
                    }
                }
            }
        };
        const config = {
            childList: true,
            subtree: true,
        };
        const observer = new MutationObserver(callback);
        observer.observe(document.body, config);
    }
})();
const DomObserver = {
    executeOnNodeChanged,
    addOnNodeChange,
    removeOnNodeChange,
    cleanup,
};

// Author Knighttower
// MIT License
// Copyright (c) [2022] [Knighttower] https://github.com/knighttower


/**
 * @class Adds some extra functionality to interact with a DOM element
 * @param {String|Object} selector Class or ID or DOM element
 * @param {String} scope The scope to search in, window, document, dom element. Defaults to document
 * @return {Object}
 * @example new ElementHelper('elementSelector')
 * @example new ElementHelper('elementSelector', domElement|window|document)
 *
 */
class ElementHelper {
    /**
     * Constructor
     * @param {String|Object} selector
     * @return {Object}
     */
    constructor(selector, scope = document) {
        this.selector = selector;
        if (typeof selector === 'object') {
            this.domElement = selector;
        } else if (String(selector).includes('//')) {
            this.domElement = this.getElementByXpath(selector);
        } else {
            this.domElement = scope.querySelector(selector);
        }
    }

    // =========================================
    // --> Public
    // --------------------------

    /**
     * Check if the element exists or is visible. It will keep querying
     * @return {Boolean}
     */
    isInDom() {
        return Boolean(this.domElement?.outerHTML);
    }

    /**
     * Wait for element exists or is visible. It will keep querying
     * @function whenInDom
     * @return {Promise}
     */
    whenInDom() {
        let $this = this;
        let callbackId = Date.now() + Math.floor(Math.random() * 1000);

        return new Promise(function (resolveThis) {
            if (!$this.isInDom()) {
                DomObserver.addOnNodeChange(callbackId, () => {
                    let element = new ElementHelper($this.selector);
                    if (element.isInDom()) {
                        $this = element;
                        resolveThis($this);
                        DomObserver.removeOnNodeChange(callbackId);
                    }
                });
            } else {
                resolveThis($this);
            }
        });
    }

    /**
     * Find element by Xpath string
     * @param {String} xpath
     * @example getElementByXpath("//html[1]/body[1]/div[1]")
     * @return {Object} DOM element
     */
    getElementByXpath(xpath) {
        return document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
    }

    /**
     * Get the element xpath string
     * @author Based on https://stackoverflow.com/questions/2631820/how-do-i-ensure-saved-click-coordinates-can-be-reload-to-the-same-place-even-if/2631931#2631931
     * @return {String}
     */
    getXpathTo() {
        let element = this.domElement;

        if (element.id) {
            return `//*[@id='${element.id}']`;
        }
        if (element === document.body) {
            return '//' + element.tagName;
        }

        let ix = 0;
        let siblings = element.parentNode.childNodes;
        for (let i = 0; i < siblings.length; i++) {
            let sibling = siblings[i];
            if (sibling === element) {
                return (
                    new ElementHelper(element.parentNode).getXpathTo() + '/' + element.tagName + '[' + (ix + 1) + ']'
                );
            }
            if (sibling.nodeType === 1 && sibling.tagName === element.tagName) {
                ix++;
            }
        }
    }

    /**
     * Get the element attribute, but parse it if it is an object or array
     * @param {String} attr Atrribute name
     * @return {String|Array|Object|Null}
     */
    getAttribute(attr) {
        return this.domElement.getAttribute(attr) || null;
    }

    /**
     * Create a unique has for the element derived from its xpath
     * @author Based on https://www.geeksforgeeks.org/how-to-create-hash-from-string-in-javascript/
     * @return {String}
     */
    getHash() {
        let string = String(this.getXpathTo());
        let hash = 0;

        if (string.length === 0) {
            return hash;
        }

        for (let i = 0; i < string.length; i++) {
            let char = string.charCodeAt(i);
            hash = (hash << 5) - hash + char;
            hash = hash & hash;
        }

        return hash;
    }
}

// =========================================
// --> Utilities
// --------------------------
const selectElement = (selector, scope = document) => new ElementHelper(selector, scope);




/***/ }),

/***/ "./node_modules/knighttower/packages/utility/dist/esm/EventBus.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/knighttower/packages/utility/dist/esm/EventBus.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EventBus: () => (/* binding */ EventBus),
/* harmony export */   _eventBus: () => (/* binding */ _eventBus),
/* harmony export */   "default": () => (/* binding */ EventBus)
/* harmony export */ });
class EventBus {
    constructor() {
        // Memory storage for all the events
        this.listeners = {};
    }
    // creates an event that can be triggered any number of times
    /**
     * creates an event that can be triggered any number of times
     * @method on
     * @param {string} eventName - The name of the event
     * @param {function} callback - The callback to execute
     * @return {void}
     * @example eventBus.on('event.name', function() { console.log('event.name was triggered') })
     */
    on(eventName, callback) {
        this.registerListener(eventName, callback);
    }
    /**
     * creates an event that can be triggered only once. If it is emitted twice, the callback will only be executed once!
     * @method once
     * @param {string} eventName - The name of the event
     * @param {function} callback - The callback to execute
     * @return {void}
     * @example eventBus.once('event.name', function() { console.log('event.name was triggered only once') })
     */
    once(eventName, callback) {
        this.registerListener(eventName, callback, 1);
    }
    /**
     * reates an event that can be triggered only a number of times. If it is emitted more than that, the callback will not be be executed anymore!
     * @method exactly
     * @param {string} eventName - The name of the event
     * @return {void}
     * @example eventBus.exactly('event.name', function() { console.log('event.name was triggered 3 times') }, 3)
     */
    exactly(eventName, callback, capacity) {
        this.registerListener(eventName, callback, capacity);
    }
    /**
     * kill an event with all it's callbacks
     * @method off
     * @param {string} eventName - The name of the event
     * @return {void}
     * @example eventBus.off('event.name')
     */
    off(eventName) {
        delete this.listeners[eventName];
    }
    /**
     * removes the given callback for the given event
     * @method detach
     * @param {string} eventName - The name of the event
     * @param {function} callback - The callback to remove
     * @return {void|boolean} - Returns true if the event was found and removed, void otherwise
     * @example eventBus.detach('event.name', callback)
     */
    detach(eventName, callback) {
        const listeners = this.listeners[eventName] || [];
        const filteredListeners = listeners.filter(function (value) {
            return value.callback !== callback;
        });
        if (eventName in this.listeners) {
            this.listeners[eventName] = filteredListeners;
            return true; // Event was found and removed
        }
        return false; // Event was not found
    }

    /**
     * emits an event with the given name and arguments
     * @param {string} eventName - The name of the event
     * @param {any} args - The arguments to pass to the callback
     * @return {void}
     * @use {__context: this|Instance} to pass the context to the callback
     * @example eventBus.emit('event.name', arg1, arg2, arg3)
     * @example eventBus.emit('event.name', arg1, arg2, arg3, {__context: YourInstance})
     */
    emit(eventName, ...args) {
        let queueListeners = [];
        let matches = null;
        const allArgs = this.extractContextFromArgs(args);
        const context = allArgs[0];
        args = allArgs[1];
        // name exact match
        if (this.hasListener(eventName)) {
            queueListeners = this.listeners[eventName];
        } else {
            // -----------------------------------------
            // Wildcard support
            if (eventName.includes('*')) {
                // case 1, if the incoming string has * or ** in it
                // which will suppport emit("name*") or emit("name**") or emit("name.*name**")
                matches = this.patternSearch(eventName, Object.keys(this.listeners));
                if (matches) {
                    matches.forEach((match) => {
                        queueListeners = queueListeners.concat(this.listeners[match]);
                    });
                }
            } else {
                // case 2, if the incoming string matches a registered pattern
                // which will support on("name*") | on("name**") | on("name.*name**")
                for (const key in this.listeners) {
                    matches = this.patternSearch(key, [eventName]);
                    if (matches) {
                        queueListeners = queueListeners.concat(this.listeners[key]);
                    }
                }
            }
        }
        queueListeners.forEach((listener, k) => {
            let callback = listener.callback;
            if (context) {
                callback = callback.bind(context);
            }
            callback(...args);
            if (listener.triggerCapacity !== undefined) {
                listener.triggerCapacity--;
                queueListeners[k].triggerCapacity = listener.triggerCapacity;
            }
            if (this.checkToRemoveListener(listener)) {
                this.listeners[eventName].splice(k, 1);
            }
        });
    }
    /**
     * Search for a pattern in a list of strings
     * @method patternSearch
     * @private
     * @param {string} pattern - The pattern to search for
     * @param {string[]} list - The list of strings to search in
     * @return {string[]|null} - Returns a list of strings that match the pattern, or null if no match is found
     * @example patternSearch('name.*', ['name.a', 'name.b', 'name.c']) // returns ['name.a', 'name.b', 'name.c']
     */
    patternSearch(pattern, list) {
        let filteredList = [];
        // console.log('__testLogHere__', pattern, this.setWildCardString(pattern));
        const regex = new RegExp(this.setWildCardString(pattern));
        filteredList = list.filter((item) => regex.test(item));
        return filteredList.length === 0 ? null : filteredList;
    }
    setWildCardString(string) {
        // eslint-disable-next-line
        let regexStr = string.replace(/([.+?^${}()|\[\]\/\\])/g, '\\$&'); // escape all regex special chars
        regexStr = regexStr
            // eslint-disable-next-line
            .replace(/\*\*/g, '[_g_]') // Replace wildcard patterns with temporary markers
            // eslint-disable-next-line
            .replace(/\*/g, '(.*?)')
            .replace(/\[_g_\]/g, '.*');
        return `^${regexStr}$`;
    }
    /**
     * Extract the context from the arguments
     * @method extractContextFromArgs
     * @private
     * @param {any[]} args - The arguments to extract the context from
     * @return {any[]} - Returns an array with the context as the first element and the arguments as the second element
     */
    extractContextFromArgs(args) {
        let context = null;
        for (let i = 0; i < args.length; i++) {
            const arg = args[i];
            // eslint-disable-next-line
            if (arg && typeof arg === 'object' && arg.hasOwnProperty('__context')) {
                context = arg.__context;
                args.splice(i, 1);
                break;
            }
        }
        return [context, args];
    }
    registerListener(eventName, callback, triggerCapacity) {
        if (!this.hasListener(eventName)) {
            this.listeners[eventName] = [];
        }
        this.listeners[eventName].push({ callback, triggerCapacity });
    }
    checkToRemoveListener(eventInformation) {
        if (eventInformation.triggerCapacity !== undefined) {
            return eventInformation.triggerCapacity <= 0;
        }
        return false;
    }
    hasListener(eventName) {
        return eventName in this.listeners;
    }
}
function _eventBus() {
    // support for browser
    if (typeof window !== 'undefined') {
        if (!window.eventBus) {
            window.eventBus = new EventBus();
        }
        return window.eventBus;
    }
    if (typeof global !== 'undefined') {
        if (!global.eventBus) {
            global.eventBus = new EventBus();
        }
        return global.eventBus;
    }
    // if none of the above is available, return a new instance
    return new EventBus();
}




/***/ }),

/***/ "./node_modules/knighttower/packages/utility/dist/esm/PowerHelpers.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/knighttower/packages/utility/dist/esm/PowerHelpers.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PowerHelper: () => (/* binding */ powerHelper),
/* harmony export */   addQuotes: () => (/* binding */ addQuotes),
/* harmony export */   cleanStr: () => (/* binding */ cleanStr),
/* harmony export */   convertKeysToSymbols: () => (/* binding */ convertKeysToSymbols),
/* harmony export */   "default": () => (/* binding */ powerHelper),
/* harmony export */   findAndReplaceInArray: () => (/* binding */ findAndReplaceInArray),
/* harmony export */   findNested: () => (/* binding */ findNested),
/* harmony export */   fixQuotes: () => (/* binding */ fixQuotes),
/* harmony export */   getArrObjFromString: () => (/* binding */ getArrObjFromString),
/* harmony export */   getChunks: () => (/* binding */ getChunks),
/* harmony export */   getDirectivesFromString: () => (/* binding */ getDirectivesFromString),
/* harmony export */   getMatchBlock: () => (/* binding */ getMatchBlock),
/* harmony export */   getMatchInBetween: () => (/* binding */ getMatchInBetween),
/* harmony export */   powerHelper: () => (/* binding */ powerHelper),
/* harmony export */   removeQuotes: () => (/* binding */ removeQuotes),
/* harmony export */   setExpString: () => (/* binding */ setExpString),
/* harmony export */   setLookUpExp: () => (/* binding */ setLookUpExp),
/* harmony export */   setWildCardString: () => (/* binding */ setWildCardString),
/* harmony export */   startAndEndWith: () => (/* binding */ startAndEndWith),
/* harmony export */   wildCardStringSearch: () => (/* binding */ wildCardStringSearch)
/* harmony export */ });
// // -----------------------------------------
// /**
//  * @knighttower
//  * @url knighttower.io
//  * @git https://github.com/knighttower/
//  */
// // -----------------------------------------

// -----------------------------
// METHODS
// -----------------------------

/**
 * Convert a value to bool
 * @param {String|Boolean|Int|Number} val
 * @return {Boolean}
 * @usage convertToBool('true') // true
 * @usage convertToBool('false') // false
 * @usage convertToBool('0') // false
 * @usage convertToBool('1') // true
 * @usage convertToBool('') // false
 * @usage convertToBool('true') // true
 * @usage convertToBool('false') // false
 */
function convertToBool(val) {
    switch (typeof val) {
        case 'boolean':
            return val;
        case 'string':
            return val === 'false' || val === '0' ? false : true;
        case 'number':
            return val !== 0;
        default:
            return Boolean(val);
    }
}

/**
 * Converts a given variable to a number if possible.
 * @param {string|number} input - The input variable to convert.
 * @returns {string|number} - The converted number or the original variable.
 * @example convertToNumber(123) // Output: 123 (number)
 * @example convertToNumber(123.45) // Output: 123.45 (number)
 * @example convertToNumber("123") // Output: 123 (number)
 * @example convertToNumber("123.45") // Output: 123.45 (number)
 * @example convertToNumber("abc") // Output: "abc" (original string)
 * @example convertToNumber("123abc") // Output: "123abc" (original string)
 * @example convertToNumber(null) // Output: null (original)
 */
function convertToNumber(input) {
    const isNum = isNumber(input);

    if (isNum !== null) {
        return isNum;
    }
    // Case: String that cannot be converted to a number
    return input;
}

/**
 * Check if there is a value, if not return null or the default value
 * It can test strings, arrays, objects, numbers, booleans
 * @function emptyOrValue
 * @memberof Utility
 * @param {String|Number} value If the value is not empty, returns it
 * @param {String|Number} _default The default value if empty
 * @return mixed
 * @example emptyOrValue('test', 'default') // 'test'
 * @example emptyOrValue('', 'default') // 'default'
 * @example emptyOrValue('test') // 'test'
 * @example emptyOrValue('') // null
 * @example emptyOrValue(0) // 0
 * @example var hello = ''; emptyOrValue(hello) // Null
 * @example var hello = 'test'; emptyOrValue(hello) // 'test'
 * @example var hello = 'test'; emptyOrValue(hello, 'default') // 'test'
 * @example var hello = ''; emptyOrValue(hello, 'default') // 'default'
 * @example var hello = []; emptyOrValue(hello, 'default') // null
 * @example var hello = {}; emptyOrValue(hello, 'default') // null
 * @example var hello = [...]; emptyOrValue(hello') // [...]
 */
function emptyOrValue(value, _default = null) {
    /**
     * Test sequence:
     * If it is a number 0> : true
     * If is not undefined: true
     * If it is boolean (true|false) prevents going to empty
     * If it is not Empty, [], null, {}, 0, true, false: true
     */

    if (isNumber(value) !== null || typeof value === 'boolean') {
        return value;
    } else if (!isEmpty(value)) {
        return value;
    }

    return _default;
}

/**
 * Generate unique ids
 * @function getDynamicId
 * @memberof Utility
 * @return string Format kn__000000__000
 */
function getDynamicId() {
    return 'kn__' + new Date().getTime() + '__' + Math.floor(Math.random() * (999 - 100));
}

/**
 * Alias to getDynamicId
 * @function getRandomId
 * @memberof Utility
 * @return string
 * @example getRandomId() // kn__000000__000
 */
const getRandomId = getDynamicId;

/**
 * Check if a value is empty
 * @function isEmpty
 * @memberof Utility
 * @param {string|array|object|map|set|number|boolean} value
 * @url https://moderndash.io/
 * @return {string}
 */
function isEmpty(value) {
    if (value === null || value === undefined) {
        return true;
    }

    if (typeof value === 'string' || Array.isArray(value)) {
        return value.length === 0;
    }

    if (value instanceof Map || value instanceof Set) {
        return value.size === 0;
    }

    if (ArrayBuffer.isView(value)) {
        return value.byteLength === 0;
    }

    if (typeof value === 'object') {
        return Object.keys(value).length === 0;
    }

    return false;
}

/**
 * Check if is a number or Int, if not return null
 * Integrates both Int and Number, or convert a string number to number to test
 * Note: this is not like Lodash isNumber since this one takes into consideration the 'string number'
 * @function isNumber
 * @memberof Utility
 * @param {String|Number} value
 * @return null|int
 * @example isNumber(123) // true
 * @example isNumber(123.45) // true
 * @example isNumber('123abc') // false
 * @example isNumber('abc') // false
 * @example isNumber('') // false
 * @example isNumber("123") // true
 * @example isNumber("123.45") // true
 */
function isNumber(value) {
    const isType = typeof value;
    switch (value) {
        case null:
        case undefined:
        case '':
            return null;
        case '0':
        case 0:
            return 0;
        default:
            if (isType === 'number' || isType === 'string') {
                if (typeof value === 'number' || !Number.isNaN(Number(value))) {
                    return +value;
                }
            }

            break;
    }

    return null;
}

/**
 * Check the type of a variable, and get the correct type for it. It also accepts simple comparisons
 * For more advance type checking see https://github.com/knighttower/JsTypeCheck
 * @param {any} input - The variable to check
 * @param {string} test - The types to check against, piped string
 * @return {string|boolean} - The type of the variable
 * @example typeOf('hello', 'string') // returns true
 * @example typeOf('hello', 'number') // returns false
 * @example typeOf('hello', 'string') // returns true
 * @example typeOf('hello') // returns 'string'
 * @example typeOf({}) // returns 'object'
 */
function typeOf(input, test) {
    // Special case for null since it can be treated as an object
    if (input === null) {
        if (test) {
            return test === null || test === 'null' ? true : false;
        }
        return 'null';
    }

    let inputType;

    switch (typeof input) {
        case 'number':
        case 'string':
        case 'boolean':
        case 'undefined':
        case 'bigint':
        case 'symbol':
        case 'function':
            inputType = typeof input;
            break;
        case 'object':
            inputType = Array.isArray(input) ? 'array' : 'object';

            break;
        default:
            inputType = 'unknown';
    }

    if (test) {
        if (test.includes('|')) {
            for (let type of test.split('|')) {
                if (inputType === type) {
                    return type;
                }
            }
            return false;
        }

        return test === inputType;
    }

    return inputType;
}

// Author Knighttower
// MIT License
// Copyright (c) [2022] [Knighttower] https://github.com/knighttower


// @private
function _removeBrackets(strExp) {
    const regex = /^(\[|\{)(.*?)(\]|\})$/; // Match brackets at start and end
    const match = strExp.match(regex);

    if (match) {
        return match[2].trim(); // Extract and trim the content between brackets
    }

    return strExp; // Return the original string if no brackets found at start and end
}

/**
 * Add quotes to a string
 * @function addQuotes
 * @param {String} str
 * @return {String}
 * @example addQuotes('hello') // "hello"
 */
function addQuotes(str, q = '"') {
    return `${q}${str}${q}`;
}

/**
 * Clean a string from delimeters or just trimmed if no delimeters given
 * @funtion cleanStr
 * @param {String} str - String to use
 * @param {String|Regex} p1 - Delimeter 1
 * @param {String|Regex} p2 - Delimeter 2
 * @return {String|void}
 * @example cleanStr('hello world', 'h', 'd') // 'ello worl'
 * @example cleanStr('  hello world  ') // 'hello world'
 * @example cleanStr('hello world', 'hello') // 'world'
 * @example cleanStr('Hello World. Sunshine is here!', '\..*!') // Hello World
 * @example cleanStr('Hello World. Sunshine is here!', /Hello/g) // ' World. Sunshine is here!'
 * @example cleanStr('Hello World. Sunshine is here!', /Hello/g, /Sunshine/g) // ' World.  is here!'
 */
function cleanStr(str, ...args) {
    if (!str) {
        return;
    }
    if (typeof str !== 'string') {
        return str;
    }

    return args
        .reduce((accStr, arg) => {
            const regex = arg instanceof RegExp ? arg : new RegExp(setExpString(arg));
            return accStr.replace(regex, '');
        }, str)
        .trim();
}

/**
 * convert all keys from an object to symbols
 * @function convertKeysToSymbols
 * @param {object} obj - The object to convert
 * @return {object} - The object with all keys converted to symbols
 * @example convertKeysToSymbols({a: 1, b: 2}) // returns {Symbol(a): 1, Symbol(b): 2, keyToSymbolMap: {a: Symbol(a), b: Symbol(b)}
 */
function convertKeysToSymbols(obj) {
    if (emptyOrValue(obj, null) === null) {
        return {};
    }
    const newObj = {};
    const keyToSymbolMap = {};
    for (const key in obj) {
        const symbolKey = Symbol(key);
        newObj[symbolKey] = obj[key];
        keyToSymbolMap[key] = symbolKey;
    }
    newObj.keyToSymbolMap = keyToSymbolMap;
    return newObj;
}

/**
 * Recursively will loop in array to find the desired target
 * @function findAndReplaceInArray
 * @param {Array} arr
 * @param {String} find The target (needle)
 * @param {Array|Object|String} value Replacer
 * @return {Null|Array}
 * @example findAndReplaceInArray([1,2,3,4,5], 3, 'three') // [1,2,'three',4,5]
 */
function findAndReplaceInArray(arr, find, value) {
    let replaced = false;

    const result = arr.map((prop) => {
        if (Array.isArray(prop)) {
            const replacedArray = findAndReplaceInArray(prop, find, value);
            if (replacedArray) {
                replaced = true;
                return replacedArray;
            }
            return prop;
        }
        if (prop === find) {
            replaced = true;
            if (Array.isArray(value)) {
                return value.map((p) => (Array.isArray(p) ? p : p.trim()));
            }
            return value;
        }
        return prop;
    });

    return replaced ? result : null;
}

/**
 * Find the last instance of nested pattern with delimeters
 * @function findNested
 * @param {string} str
 * @param {string} start - Delimeter 1
 * @param {string} end - Delimeter 2
 * @return {string|null}
 * @example findNested('[[]hello [world]]', '[', ']') // [world]
 */
function findNested(str, start = '[', end = ']') {
    if (typeof str !== 'string') {
        return str;
    }
    // Find the last index of '['
    const lastIndex = str.lastIndexOf(start);
    // If '[' is not found, return null or some default value
    if (lastIndex === -1) {
        return null;
    }

    // Extract the substring starting from the last '[' to the end
    const substring = str.substring(lastIndex);
    // Find the index of the first ']' in the substring
    const endIndex = substring.indexOf(end);
    // If ']' is not found, return null or some default value
    if (endIndex === -1) {
        return null;
    }
    // Extract and return the content between the last '[' and the next ']', including them
    return substring.substring(0, endIndex + 1);
}

/**
 * Fix quotes from a string
 * @function fixQuotes
 * @param {String} str
 * @return {String} q quote type
 * @return {String}
 * @example fixQuotes("'hello'") // "hello"
 * @example fixQuotes('"hello"') // "hello"
 */
function fixQuotes(str, q = '"') {
    if (typeof str !== 'string') {
        return str;
    }
    return str.replace(/`|'|"/g, q);
}

/**
 * Converts strings formats into objects or arrays
 * Note: quoted strings are not supported, use getDirectiveFromString instead
 * @param {string} strExp
 * @return {object|array|string}
 * @example getArrObjFromString('[[value,value],value]') // [['value', 'value'], 'value']
 * @example getArrObjFromString('[[value,value],value, { y: hello }, hello]') // [['value', 'value'], 'value', { y: 'hello' }, 'hello']
 * @example getArrObjFromString('{ y: hello, x: world, z: [value,value]}') // { y: 'hello', x: 'world', z: ['value', 'value'] }
 */
function getArrObjFromString(strExp) {
    // alredy typeof object or array just return it
    if (typeOf(strExp, 'object') || typeOf(strExp, 'array')) {
        return strExp;
    }
    const isObject = startAndEndWith(strExp, '{', '}');
    const isArray = startAndEndWith(strExp, '[', ']');
    // If it is other type of string, return it
    if (!isObject && !isArray) {
        return strExp;
    }

    const newCollection = isObject ? {} : [];
    const nestedElements = {};

    //remove the brackets
    let newStrExp = _removeBrackets(strExp);

    const loopNested = (objects = false) => {
        // ignore eslint comment
        // eslint-disable-next-line no-constant-condition
        while (true) {
            //find any nested arrays or objects
            let matched = objects ? findNested(newStrExp, '{', '}') : findNested(newStrExp);

            if (!matched) {
                break;
            }

            //replace the nested array or object with a marker so that we can safely split the string
            let marker = `__${getRandomId()}__`;
            nestedElements[marker] = matched;

            newStrExp = newStrExp.replace(matched, marker);
        }
    };

    loopNested();
    loopNested(true);

    getChunks(newStrExp).forEach((chunk, index) => {
        const isObjectKey = chunk.includes(':') && isObject;
        const chunkParts = isObjectKey ? getChunks(chunk, ':') : [];
        const chunkKey = removeQuotes(emptyOrValue(chunkParts[0], index));
        chunk = isObjectKey ? chunkParts[1] : chunk;
        if (chunk in nestedElements) {
            chunk = getArrObjFromString(nestedElements[chunk]);
        }
        chunk = convertToNumber(removeQuotes(chunk));
        // set back in the collection either as an object or array
        isObject ? (newCollection[chunkKey] = chunk) : newCollection.push(chunk);
    });
    // uncomment to debug
    // console.log('___ log ___', newCollection);
    return newCollection;
}

/**
 * handles the following patterns to get an object from string attributes
 * // Matches the JSON objects as string: {'directive':{key:value}} OR {key:value}
 * // Matches the Array as string: [value, value] OR ['value','value']
 * // Matches a multi-array string like [[value,value]],value]
 * // Matches object-style strings: directive.tablet(...values) OR directive[expression](...values)
 * // Matches string ID or class: literals Id(#) or class (.). Note that in Vue it needs to be in quotes attr="'#theId'"
 * // Mathes simple directive function style: directive(#idOr.Class)
 * Note: all the above with the exception of the Id/class will be converted into actual objects
 */
/**
 * Converts strings formats into objects
 * @function getDirectivesFromString
 * @param {String|Array|Object} stringDirective
 * @return {object|null|void}
 * @example getDirectivesFromString('directive.tablet(...values)') // {directive: {tablet: 'values'}}
 * @example getDirectivesFromString('[[value,value],value]') // {directive: 'values', directive2: 'values'}
 * @example getDirectivesFromString('directive.tablet|mobile(...values)') // {directive: {tablet: 'values', mobile: 'values'}}
 * @example getDirectivesFromString('directive.tablet(...values)') // {directive: {tablet: 'values'}}
 */
function getDirectivesFromString(stringDirective) {
    const str = stringDirective;
    if (!emptyOrValue(str)) {
        return null;
    }

    const results = (type = null, results = null) => {
        return {
            type: type,
            directive: results,
        };
    };
    const matchArrayTypes = /^\[((.|\n)*?)\]$/gm;
    // comment eslint to ignore
    // eslint-disable-next-line no-useless-escape
    const matchObjectTypes = /^\{((.|\n)*?)\:((.|\n)*?)\}/gm;
    // eslint-disable-next-line no-useless-escape
    const matchFunctionString = /^([a-zA-Z]+)(\()(\.|\#)(.*)(\))/g;
    const regexDotObjectString = /([a-zA-Z]+)\.(.*?)\(((.|\n)*?)\)/gm;
    const regexExObjectString = /([a-zA-Z]+)\[((.|\n)*?)\]\(((.|\n)*?)\)/gm;
    let type = typeof str;

    if (type === 'object' || type === 'array') {
        return results(type, str);
    } else {
        switch (true) {
            case !!str.match(matchArrayTypes):
                // Matches the Array as string: [value, value] OR ['value','value']
                // regexArrayLike = /^\[((.|\n)*?)\]$/gm;
                // Matches a multi-array string like [[value,value]],value]
                // regexMultiArrayString = /\[(\n|)(((.|\[)*)?)\](\,\n|)(((.|\])*)?)(\n|)\]/gm;

                type = 'array';
                break;
            case !!str.match(matchObjectTypes):
                // Matches the JSON objects as string: {'directive':{key:value}} OR {key:value}
                // regexObjectLike = /^\{((.|\n)*?)\:((.|\n)*?)\}/gm;
                type = 'object';
                break;
            case !!str.match(matchFunctionString):
                // Mathes simple directive function style: directive(#idOr.Class)
                // regexFunctionString
                // eslint-disable-next-line
                const directive = str.split('(')[0].trim();
                return results('idOrClassWithDirective', { [directive]: getMatchInBetween(str, '(', ')') });
            case !!str.match(regexDotObjectString):
                // Matches object-style strings: directive.tablet(...values) OR directive[expression](...values)
                // OR directive.breakdown|breakdown2(...values) OR directive.tablet(...values)&&directive.mobile(...values)
                type = 'dotObject';
                break;
            case !!str.match(regexExObjectString):
                type = 'dotObject';
                break;

            default:
                return results('string', str);
        }
    }

    if (type === 'array' || type === 'object') {
        let strQ = fixQuotes(str);
        try {
            return results(type, JSON.parse(strQ));
        } catch (error) {
            // uncomment to debug
            // console.log('___ parse error ___', error);
        }

        return results(type, getArrObjFromString(strQ));
    }

    if (type === 'dotObject') {
        let values, breakDownId, directive;
        const setObject = {};

        getChunks(str, '&&').forEach((command) => {
            if (command.match(regexExObjectString)) {
                // Matches object-style strings: directive[expression](...values)
                values = getMatchInBetween(command, '](', ')');
                breakDownId = getMatchInBetween(command, '[', ']');
                directive = command.split('[')[0].trim();
            } else {
                // Matches object-style strings: directive.tablet(...values)
                values = getMatchInBetween(command, '(', ')');
                command = command.replace(getMatchBlock(command, '(', ')'), '');
                [directive, breakDownId] = getChunks(command, '.');
            }

            values = getArrObjFromString(values);

            if (!setObject[directive]) {
                setObject[directive] = {};
            }

            getChunks(breakDownId, '|').forEach((id) => {
                setObject[directive][id] = values;
            });
        });

        return results('dotObject', setObject);
    }
}

/**
 * Find math by delimeters returns raw matches
 * @function getMatchBlock
 * @param {String} str
 * @param {String|Regex} p1
 * @param {String|Regex} p2
 * @param {Boolean} all If it should return all matches or single one (default)
 * @return {String|Array|Null}
 * @example getMatchBlock('is a hello world today', 'h', 'd') // 'hello world'
 * @example getMatchBlock('is a hello world today', 'h', 'd', true) // ['hello world']
 * @example getMatchBlock('is a <hello world/> today', '<', '/>') // '<hello world/>'
 */
function getMatchBlock(str, p1, p2, all = false) {
    if (typeof str !== 'string') {
        return str;
    }
    p1 = setExpString(p1);
    p2 = setExpString(p2);
    let regex = new RegExp(setLookUpExp(p1, p2), 'gm');
    const matches = str.match(regex);
    if (matches) {
        return all ? matches : matches[0];
    }
    return null;
}
/**
 * Splits a string into chunks by a given splitter and cleans the chunks
 * @param {string} str
 * @param {string} splitter - The string/character to split the string by. Defaults to ','
 * @return {string|array}
 */
function getChunks(str, splitter = ',') {
    if (typeof str !== 'string') {
        return str;
    }
    if (isEmpty(str)) {
        return [];
    }
    str = cleanStr(str);
    let chunks = str.split(splitter).map((t) => cleanStr(t));
    return chunks.length === 1 && chunks[0] === '' ? [str] : chunks;
}

/**
 * find a match in between two delimeters, either string or regex given, returns clean matches
 * @function getMatchBlock
 * @param {String} str
 * @param {String|Regex} p1
 * @param {String|Regex} p2
 * @param {Boolean} all If it should return all matches or single one (default)
 * @return {String|Array|Null}
 * @example getMatchInBetween('hello world', 'h', 'd') // 'ello worl'
 * @example getMatchInBetween('hello <world/>', '<', '/>', true) // ['world']
 * @example getMatchInBetween('hello <world/>', '<', '/>') // 'world'
 */
function getMatchInBetween(str, p1, p2, all = false) {
    if (typeof str !== 'string') {
        return str;
    }
    const matchBlock = getMatchBlock(str, p1, p2, all) ?? (all ? [] : str);
    return all ? matchBlock.map((match) => cleanStr(match, p1, p2)) : cleanStr(matchBlock, p1, p2);
}

/**
 * Remove quotes from a string
 * @function removeQuotes
 * @param {String} str
 * @return {String}
 * @example removeQuotes('"hello"') // hello
 * @example removeQuotes("'hello'") // hello
 */
function removeQuotes(str) {
    if (typeof str !== 'string') {
        return str;
    }
    return str.replace(/`|'|"/g, '');
}

/**
 * Checks if a string starts and ends with a given string
 * @param {string} strExp
 * @param {string} start - The string/character to check it starts with
 * @param {string} end - The string/character to check it ends with
 * @return {string}
 * @example startAndEndWith('hello world', 'h', 'd') // false
 * @example startAndEndWith('hello world', 'h', 'd') // true
 */
function startAndEndWith(strExp, start = null, end = null) {
    return (!start || strExp.startsWith(start)) && (!end || strExp.endsWith(end));
}

/**
 * Scapes a string to create a regex or returns the regex if it already is an expression
 * @function setExpString
 * @param {String|Regex} exp
 * @return {String|Regex}
 * @example setExpString('hello') // '\h\e\l\l\o'
 * @example setExpString(/hello/) // /hello/
 * @example setExpString([hello]) // \\[hello\\/ then use like new new RegExp(setExpString(StringOrRegex))
 */
function setExpString(exp) {
    if (exp instanceof RegExp) {
        return exp;
    } else {
        return exp
            .split('')
            .map((char) =>
                ['$', '^', '.', '*', '+', '?', '(', ')', '[', ']', '{', '}', '|', '\\'].includes(char)
                    ? `\\${char}`
                    : char
            )
            .join('');
    }
}

/**
 * Regex builder to get a match in between two delimeters
 * @function setLookUpExp
 * @param {String|Regex} args - minimun two arguments as delimeters
 * @return {String} - Regex
 * @example setLookUpExp('h', 'd') // 'h((.|\n)*?)d'
 * @example setLookUpExp('h', 'd', 'c') // 'h((.|\n)*?)d((.|\n)*?)c'
 * @usage:
 * const pattern = setLookUpExp(".", "!");
const regex = new RegExp(pattern, 'g');
const text = "Hello World. Sunshine is here! Have fun!";
const matches = text.match(regex);
console.log(matches);  // Output: [". Sunshine is here!"]
 */
function setLookUpExp(...args) {
    if (args.length < 2) {
        throw new Error('You need to pass at least two arguments');
    }
    let expression = '';
    // loop through args
    args.forEach((arg, index) => {
        // if arg is a regex, return the source
        if (arg instanceof RegExp) {
            arg = arg.source;
        }
        if (index === 0) {
            expression = arg;
        } else {
            expression += `((.|\n)*?)${arg}`;
        }
    });

    return expression;
}

/**
 * Set a string to be used as a wildcard pattern
 * @function setWildCardString
 * @param {string} string - The string to set as a wildcard pattern
 * @param {boolean} matchStart - If the pattern should match the start of the string
 * @param {boolean} matchEnd - If the pattern should match the end of the string
 * @return {string} - The wildcard pattern
 * @example setWildCardString('name.*', true) // returns '^name\.(.*?)'
 * @example setWildCardString('name.*', false, true) // returns 'name\.(.*?)$'
 * @example setWildCardString('name.**') // returns 'name\..*' greedy
 */
function setWildCardString(str, matchStart = false, matchEnd = false) {
    if (typeof str !== 'string') {
        return str;
    }
    if (!str) {
        return null;
    }
    matchStart = convertToBool(matchStart);
    matchEnd = convertToBool(matchEnd);
    // eslint-disable-next-line no-useless-escape
    let regexStr = str.replace(/([.+?^${}()|\[\]\/\\])/g, '\\$&'); // escape all regex special chars
    let regStart = matchStart ? '^' : '';
    let regEnd = matchEnd ? '$' : '';

    regexStr = regexStr
        .replace(/\*\*/g, '[_g_]') // Replace wildcard patterns with temporary markers
        .replace(/\*/g, '(.*?)')
        .replace(/\[_g_\]/g, '.*');

    return `${regStart}${regexStr}${regEnd}`;
}

/**
 * Search for a wildcard pattern in a list of strings or viceversa
 * @method wildCardStringSearch
 * @param {string} pattern - The pattern to search for
 * @param {array|string} list - The list of strings to search in
 * @param {boolean} matchStart - If the pattern should match the start of the string (optional)
 * @param {boolean} matchEnd - If the pattern should match the end of the string optional)
 * @return {string[]|null} - Returns a list of strings that match the pattern, or null if no match is found
 * @example wildCardStringSearch('name.*', ['name.a', 'name.b', 'name.c']) // returns ['name.a', 'name.b', 'name.c']
 */
function wildCardStringSearch(pattern, listOrString, matchStart = false, matchEnd = false) {
    if (!pattern || !listOrString) {
        return null;
    }

    const regex = new RegExp(setWildCardString(pattern, matchStart, matchEnd));

    if (typeof listOrString === 'string') {
        const matches = listOrString.match(regex);
        return emptyOrValue(matches);
    }

    let filteredList = [];
    filteredList = listOrString.filter((item) => regex.test(item));

    return emptyOrValue(filteredList);
}

const powerHelper = {
    addQuotes,
    cleanStr,
    convertKeysToSymbols,
    findAndReplaceInArray,
    findNested,
    fixQuotes,
    getArrObjFromString,
    getChunks,
    getDirectivesFromString,
    getMatchBlock,
    getMatchInBetween,
    removeQuotes,
    startAndEndWith,
    setExpString,
    setLookUpExp,
    setWildCardString,
    wildCardStringSearch,
};




/***/ }),

/***/ "./node_modules/knighttower/packages/utility/dist/esm/PromiseQueue.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/knighttower/packages/utility/dist/esm/PromiseQueue.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PromisePool: () => (/* binding */ promisePool),
/* harmony export */   PromiseQueue: () => (/* binding */ PromiseQueue),
/* harmony export */   doPoll: () => (/* binding */ doPoll),
/* harmony export */   promisePool: () => (/* binding */ promisePool),
/* harmony export */   promiseQueue: () => (/* binding */ PromiseQueue)
/* harmony export */ });
class EventBus {
    constructor() {
        // Memory storage for all the events
        this.listeners = {};
    }
    // creates an event that can be triggered any number of times
    /**
     * creates an event that can be triggered any number of times
     * @method on
     * @param {string} eventName - The name of the event
     * @param {function} callback - The callback to execute
     * @return {void}
     * @example eventBus.on('event.name', function() { console.log('event.name was triggered') })
     */
    on(eventName, callback) {
        this.registerListener(eventName, callback);
    }
    /**
     * creates an event that can be triggered only once. If it is emitted twice, the callback will only be executed once!
     * @method once
     * @param {string} eventName - The name of the event
     * @param {function} callback - The callback to execute
     * @return {void}
     * @example eventBus.once('event.name', function() { console.log('event.name was triggered only once') })
     */
    once(eventName, callback) {
        this.registerListener(eventName, callback, 1);
    }
    /**
     * reates an event that can be triggered only a number of times. If it is emitted more than that, the callback will not be be executed anymore!
     * @method exactly
     * @param {string} eventName - The name of the event
     * @return {void}
     * @example eventBus.exactly('event.name', function() { console.log('event.name was triggered 3 times') }, 3)
     */
    exactly(eventName, callback, capacity) {
        this.registerListener(eventName, callback, capacity);
    }
    /**
     * kill an event with all it's callbacks
     * @method off
     * @param {string} eventName - The name of the event
     * @return {void}
     * @example eventBus.off('event.name')
     */
    off(eventName) {
        delete this.listeners[eventName];
    }
    /**
     * removes the given callback for the given event
     * @method detach
     * @param {string} eventName - The name of the event
     * @param {function} callback - The callback to remove
     * @return {void|boolean} - Returns true if the event was found and removed, void otherwise
     * @example eventBus.detach('event.name', callback)
     */
    detach(eventName, callback) {
        const listeners = this.listeners[eventName] || [];
        const filteredListeners = listeners.filter(function (value) {
            return value.callback !== callback;
        });
        if (eventName in this.listeners) {
            this.listeners[eventName] = filteredListeners;
            return true; // Event was found and removed
        }
        return false; // Event was not found
    }

    /**
     * emits an event with the given name and arguments
     * @param {string} eventName - The name of the event
     * @param {any} args - The arguments to pass to the callback
     * @return {void}
     * @use {__context: this|Instance} to pass the context to the callback
     * @example eventBus.emit('event.name', arg1, arg2, arg3)
     * @example eventBus.emit('event.name', arg1, arg2, arg3, {__context: YourInstance})
     */
    emit(eventName, ...args) {
        let queueListeners = [];
        let matches = null;
        const allArgs = this.extractContextFromArgs(args);
        const context = allArgs[0];
        args = allArgs[1];
        // name exact match
        if (this.hasListener(eventName)) {
            queueListeners = this.listeners[eventName];
        } else {
            // -----------------------------------------
            // Wildcard support
            if (eventName.includes('*')) {
                // case 1, if the incoming string has * or ** in it
                // which will suppport emit("name*") or emit("name**") or emit("name.*name**")
                matches = this.patternSearch(eventName, Object.keys(this.listeners));
                if (matches) {
                    matches.forEach((match) => {
                        queueListeners = queueListeners.concat(this.listeners[match]);
                    });
                }
            } else {
                // case 2, if the incoming string matches a registered pattern
                // which will support on("name*") | on("name**") | on("name.*name**")
                for (const key in this.listeners) {
                    matches = this.patternSearch(key, [eventName]);
                    if (matches) {
                        queueListeners = queueListeners.concat(this.listeners[key]);
                    }
                }
            }
        }
        queueListeners.forEach((listener, k) => {
            let callback = listener.callback;
            if (context) {
                callback = callback.bind(context);
            }
            callback(...args);
            if (listener.triggerCapacity !== undefined) {
                listener.triggerCapacity--;
                queueListeners[k].triggerCapacity = listener.triggerCapacity;
            }
            if (this.checkToRemoveListener(listener)) {
                this.listeners[eventName].splice(k, 1);
            }
        });
    }
    /**
     * Search for a pattern in a list of strings
     * @method patternSearch
     * @private
     * @param {string} pattern - The pattern to search for
     * @param {string[]} list - The list of strings to search in
     * @return {string[]|null} - Returns a list of strings that match the pattern, or null if no match is found
     * @example patternSearch('name.*', ['name.a', 'name.b', 'name.c']) // returns ['name.a', 'name.b', 'name.c']
     */
    patternSearch(pattern, list) {
        let filteredList = [];
        // console.log('__testLogHere__', pattern, this.setWildCardString(pattern));
        const regex = new RegExp(this.setWildCardString(pattern));
        filteredList = list.filter((item) => regex.test(item));
        return filteredList.length === 0 ? null : filteredList;
    }
    setWildCardString(string) {
        // eslint-disable-next-line
        let regexStr = string.replace(/([.+?^${}()|\[\]\/\\])/g, '\\$&'); // escape all regex special chars
        regexStr = regexStr
            // eslint-disable-next-line
            .replace(/\*\*/g, '[_g_]') // Replace wildcard patterns with temporary markers
            // eslint-disable-next-line
            .replace(/\*/g, '(.*?)')
            .replace(/\[_g_\]/g, '.*');
        return `^${regexStr}$`;
    }
    /**
     * Extract the context from the arguments
     * @method extractContextFromArgs
     * @private
     * @param {any[]} args - The arguments to extract the context from
     * @return {any[]} - Returns an array with the context as the first element and the arguments as the second element
     */
    extractContextFromArgs(args) {
        let context = null;
        for (let i = 0; i < args.length; i++) {
            const arg = args[i];
            // eslint-disable-next-line
            if (arg && typeof arg === 'object' && arg.hasOwnProperty('__context')) {
                context = arg.__context;
                args.splice(i, 1);
                break;
            }
        }
        return [context, args];
    }
    registerListener(eventName, callback, triggerCapacity) {
        if (!this.hasListener(eventName)) {
            this.listeners[eventName] = [];
        }
        this.listeners[eventName].push({ callback, triggerCapacity });
    }
    checkToRemoveListener(eventInformation) {
        if (eventInformation.triggerCapacity !== undefined) {
            return eventInformation.triggerCapacity <= 0;
        }
        return false;
    }
    hasListener(eventName) {
        return eventName in this.listeners;
    }
}

// // -----------------------------------------
// /**
//  * @knighttower
//  * @url knighttower.io
//  * @git https://github.com/knighttower/
//  */
// // -----------------------------------------


/**
 * Make sure the the item is an array or convert it to an array
 * @function makeArray
 * @param {String|Array} item
 * @return array
 * @example makeArray('test') // ['test']
 */
const makeArray = (item) => (Array.isArray(item) ? item : [item]);

/**
 * Generate unique ids
 * @function getDynamicId
 * @memberof Utility
 * @return string Format kn__000000__000
 */
function getDynamicId() {
    return 'kn__' + new Date().getTime() + '__' + Math.floor(Math.random() * (999 - 100));
}

/**
 * @class promisePool
 * @description Class to manage a pool of promises with status tracking.
 * @methods
 * add: Adds a promise to the pool and sets up handling for resolution.
 * status: Returns the overall status of the promise pool.
 * isDone: Returns true if the pool is done processing all promises.
 * clear: Clears all promises from the pool.
 */
const promisePool = () => {
    let _status = 'in-progress'; // 'in progress' or 'done'
    let promises = {};
    let rejectedPromises = [];

    return new (class extends EventBus {
        constructor() {
            super();
        }
        /**
         * Adds a promise to the pool and sets up handling for resolution.
         * @param {Promise|Array} promise The promise to add to the pool.
         */
        add(promise) {
            // console.log(promise instanceof Promise !== true, !Array.isArray(promise));
            const isValid =
                promise instanceof Promise !== true ||
                !(Array.isArray(promise) && promise.every((item) => item instanceof Promise));

            if (!isValid) {
                throw new Error('promisePool: The first argument must be a promise or an array of promises.');
            }
            const $this = this;
            const promiseCollection = makeArray(promise);
            promiseCollection.forEach((promise) => {
                const promiseBag = Promise.all([promise]);
                const promiseId = getDynamicId();
                promises[promiseId] = {
                    promiseBag,
                    status: 'in-progress',
                };
                promiseBag
                    .then(() => {
                        promises[promiseId].status = 'completed';
                        $this._updateStatus();
                    })
                    .catch(() => {
                        promises[promiseId].status = 'rejected';
                        $this._updateStatus();
                    });
            });
        }

        /**
         * Returns the overall status of the promise pool.
         * @returns {String} The current status of the pool.
         */
        status() {
            return _status;
        }

        isDone() {
            return _status === 'done';
        }

        _updateStatus() {
            if (_status === 'done') {
                return;
            }

            const instances = Object.values(promises);
            instances.forEach((promise) => {
                if (promise.status === 'rejected') {
                    rejectedPromises.push(promise);
                }
            });

            const statuses = instances.every(
                (promise) => promise.status === 'completed' || promise.status === 'rejected'
            );

            _status = statuses ? 'done' : 'in-progress';

            this.emit('stats', {
                completed: instances.filter((promise) => promise.status === 'completed').length,
                rejected: rejectedPromises.length,
                pending: instances.filter((promise) => promise.status === 'in-progress').length,
                total: instances.length,
            });

            if (_status === 'done') {
                this.emit('completed');
                this.emit('rejected', rejectedPromises);
                this.clear();
            }
        }

        /**
         * Clears all promises from the pool.
         */
        clear() {
            promises = {};
            rejectedPromises = [];
        }
    })();
};

/**
 * @class PromiseQueue
 * Class to manage a queue of promises, executing them sequentially with status tracking for each promise.
 * @extends EventBus
 * @methods
 * add: Adds a promise to the queue and starts the queue processing if not already started.
 * clear: Clears the promise queue.
 * status: Returns the current status of all promises in the queue.
 */
const PromiseQueue = class extends EventBus {
    constructor() {
        super();
        this.queue = [];
        this.inProgress = false;
        this._timer = null;
    }

    /**
     * Adds a promise to the queue and starts the queue processing if not already started.
     * @param {Function} promiseFunction A function that returns a promise.
     */
    add(promises) {
        makeArray(promises).forEach((promiseFunction) => {
            this.queue.push({
                promiseFunction,
                status: 'pending', // 'pending', 'fulfilled', or 'rejected'
            });
        });

        if (!this.inProgress) {
            this._next();
        }
        this._setTimer();
    }

    /**
     * Clears the promise queue.
     */
    clear() {
        this.queue = [];
    }

    _setTimer() {
        if (this._timer) {
            clearInterval(this._timer);
        }
        this._timer = setInterval(() => {
            if (this.status() === 'done') {
                this.emit('completed');
                clearInterval(this._timer);
                this._timer = null;
            }
        }, 10);
    }

    /**
     * Processes the next promise in the queue, if any.
     * @private
     */
    _next() {
        if (this.queue.length === 0) {
            this.inProgress = false;
            return;
        }

        this.inProgress = true;
        const { promiseFunction } = this.queue[0];
        promiseFunction()
            .then(() => {
                this.queue[0].status = 'fulfilled';
            })
            .catch(() => {
                this.queue[0].status = 'rejected';
            })
            .finally(() => {
                this.queue.shift(); // Remove the processed promise from the queue
                this._next(); // Process the next promise
            });
    }

    /**
     * Returns the current status of all promises in the queue.
     * @returns {Array<Object>} An array of objects with the status of each promise.
     */
    status() {
        return this.queue.length === 0 ? 'done' : 'in-progress';
    }
};

/**
 * Creates a poll function that continuously calls a given function until it returns true or a promise resolves.
 * @param {Function} fn - The function to be polled. It can return a promise or a boolean.
 * @param {Object} options - Configuration options for polling.
 * @param {number} [options.interval=200] - The interval in milliseconds between each poll.
 * @param {number} [options.timeout=1000] - The maximum time in milliseconds to continue polling.
 * @returns {Object} { promise, stop } - An object containing the polling promise and a cancel function.
 * @fails returns 'failed' if the polling times out or is cancelled.
 * @options: {}
 * - interval: The interval in milliseconds between each poll.
 * - timeout: The maximum time in milliseconds to continue polling.
 * @example
 * const { promise, stop } = doPoll(() => {
 *    // Polling logic here
 *   return true; // or return a promise
 * }
 */
const doPoll = (fn, options = {}) => {
    if (typeof fn !== 'function') {
        throw new Error('doPoll: The first argument must be a function.');
    }
    const { interval = 200, timeout = 1000 } = options;
    let timeoutId, intervalId;
    let resolvePromise, rejectPromise;
    let stopped = false;

    const stop = () => {
        clearTimers();
        rejectPromise(console.info('===> doPoll: cancelled or timed out.'));
    };

    const done = (result) => {
        clearTimers();
        resolvePromise(result);
    };

    function clearTimers() {
        stopped = true;
        clearTimeout(timeoutId);
        clearInterval(intervalId);
    }

    const promise = new Promise((resolve, reject) => {
        resolvePromise = resolve;
        rejectPromise = reject;
        const isPromise = fn instanceof Promise;

        const poll = () => {
            if (stopped) {
                return;
            }

            const pollThis = isPromise ? fn : fn();

            if (isPromise) {
                pollThis
                    .then((resolvedValue) => {
                        if (resolvedValue) {
                            done(resolvedValue);
                        }
                    })
                    .catch(rejectPromise);
            } else {
                if (Boolean(pollThis) || pollThis) {
                    done(pollThis);
                }
            }
        };

        intervalId = setInterval(poll, interval);
        poll(); // Initial call to handle any immediate resolution

        timeoutId = setTimeout(() => {
            if (!stopped) {
                stop();
            }
        }, timeout);
    });

    return { promise, stop };
};




/***/ }),

/***/ "./node_modules/knighttower/packages/utility/dist/esm/ProxyClass.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/knighttower/packages/utility/dist/esm/ProxyClass.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ProxyClass: () => (/* binding */ proxyClass),
/* harmony export */   "default": () => (/* binding */ proxyClass),
/* harmony export */   proxyClass: () => (/* binding */ proxyClass)
/* harmony export */ });
/**
 * Enhances a class with proxy functionality to enforce access and mutation rules for its properties.
 * This approach utilizes a higher-order function to wrap the class with a Proxy.
 */

/**
 * Wraps a class with a Proxy to enforce private, protected, and mutable properties.
 * @param {Function} BaseClass - The class to be wrapped.
 * @returns {Proxy} A proxy-wrapped class enforcing the specified access controls.
 * @usage
 * // Example class to use with proxyClass
    class MyClass {
        constructor() {
            this.publicProp = 'This can be accessed and modified.';
            this.protectedProp = 'This cannot be modified.';
            this.privateProp = 'This cannot be accessed or modified.';
            this.mutableProp = 'This can be modified.';
            this._protected = ['protectedProp'];
            this._private = ['privateProp'];
            this._mutable = ['mutableProp'];
        }
    }

    // Enhanced class with proxyClass
    const ProxyEnhancedMyClass = proxyClass(MyClass);

    // Example usage
    const instance = new ProxyEnhancedMyClass();
    console.log(instance.publicProp); // Accessible
    instance.publicProp = 'New value'; // Modifiable
    console.log(instance.privateProp); // Attempt to access private property: privateProp
    instance.mutableProp = 'Changed'; // Modifiable, even if protected
    console.log(instance.mutableProp);
    delete instance.privateProp;
 */
function proxyClass(BaseClass) {
    return new Proxy(BaseClass, {
        construct(target, args) {
            const instance = new target(...args);
            const _private = new Set(instance._private || []);
            const _protected = new Set([..._private, ...(instance._protected || [])]);
            const _mutable = new Set(instance._mutable || []);

            const canMutate = (prop) => {
                if (_protected.has(prop) && !_mutable.has(prop)) {
                    console.error(`Attempt to modify protected property: ${prop}`);
                    return false;
                }
                if (_private.has(prop) && !_mutable.has(prop)) {
                    console.error(`Attempt to modify private property: ${prop}`);
                    return false;
                }
                return true;
            };

            return new Proxy(instance, {
                get(target, prop, receiver) {
                    if (_private.has(prop)) {
                        console.error('Attempt to access private property:', prop);
                        return undefined; // Or throw an Error
                    }
                    return Reflect.get(target, prop, receiver);
                },
                set(target, prop, value) {
                    if (!canMutate(prop)) {
                        return false; // Or throw an Error
                    }
                    return Reflect.set(target, prop, value);
                },
                deleteProperty(target, prop) {
                    if (!canMutate(prop)) {
                        return false; // Or throw an Error
                    }
                    return Reflect.deleteProperty(target, prop);
                },
                defineProperty(target, prop, descriptor) {
                    if (!canMutate(prop)) {
                        return false; // Or throw an Error
                    }
                    return Reflect.defineProperty(target, prop, descriptor);
                },
                ownKeys(target) {
                    const keys = Reflect.ownKeys(target);
                    return keys.filter((key) => !_private.has(key));
                },
                enumerate(target) {
                    const keys = Reflect.enumerate(target);
                    return keys.filter((key) => !_private.has(key));
                },
                has(target, prop) {
                    return !_private.has(prop) && Reflect.has(target, prop);
                },
                getOwnPropertyDescriptor(target, prop) {
                    if (_private.has(prop)) {
                        return undefined;
                    }
                    return Reflect.getOwnPropertyDescriptor(target, prop);
                },
            });
        },
    });
}




/***/ }),

/***/ "./node_modules/knighttower/packages/utility/dist/esm/ProxyObject.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/knighttower/packages/utility/dist/esm/ProxyObject.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ProxyObject: () => (/* binding */ proxyObject),
/* harmony export */   "default": () => (/* binding */ proxyObject),
/* harmony export */   proxyObject: () => (/* binding */ proxyObject)
/* harmony export */ });
// [2023] [Knighttower] https://github.com/knighttower

/**
 * @module proxyObject
 * Convert to proxy to protect objects
 * Allows to declare _private, _protected and _mutable - all arrays with prop names
 * @example proxyObject({objectProps..., _protected: array(...)})
 * @param {Object} object
 * @return {Proxy}
 * @usage const proxy = proxyObject({objectProps..., _protected: array(...), _private: array(...), _mutable: array(...)})
 * @usage _protected: array(...) -> Cannot be modified
 * @usage _private: array(...) -> Cannot be accessed
 * @usage _mutable: array(...) -> Can be modified
 */
function proxyObject(object) {

    // Initialize property access control sets
    const _private = new Set(object._private || ['_private']);
    const _protected = new Set([..._private, ...(object._protected || [])]);
    const _mutable = new Set(object._mutable || []);

    const canMutate = (prop) => {
        if (_protected.has(prop) && !_mutable.has(prop)) {
            console.error(`Attempt to modify protected property: ${prop}`);
            return false;
        }
        if (_private.has(prop) && !_mutable.has(prop)) {
            console.error(`Attempt to modify private property: ${prop}`);
            return false;
        }
        return true;
    };

    return new Proxy(object, {
        get(target, prop, receiver) {
            if (_private.has(prop)) {
                console.error(`Attempt to access private property: ${prop}`);
                return undefined;
            }
            return Reflect.get(target, prop, receiver);
        },
        set(target, prop, value, receiver) {
            if (!canMutate(prop)) {
                return false;
            }
            return Reflect.set(target, prop, value, receiver);
        },
        deleteProperty(target, prop) {
            if (!canMutate(prop)) {
                return false;
            }
            return Reflect.deleteProperty(target, prop);
        },
        defineProperty(target, prop, descriptor) {
            if (!canMutate(prop)) {
                return false;
            }
            return Reflect.defineProperty(target, prop, descriptor);
        },
        ownKeys(target) {
            return Reflect.ownKeys(target).filter((key) => !_private.has(key));
        },
        enumerate(target) {
            const keys = Reflect.enumerate(target);
            return keys.filter((key) => !_private.has(key));
        },
        has(target, prop) {
            return !_private.has(prop) && Reflect.has(target, prop);
        },
        getOwnPropertyDescriptor(target, prop) {
            if (_private.has(prop)) {
                return undefined;
            }
            return Reflect.getOwnPropertyDescriptor(target, prop);
        },
    });
}




/***/ }),

/***/ "./node_modules/knighttower/packages/utility/dist/esm/UrlHelper.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/knighttower/packages/utility/dist/esm/UrlHelper.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UrlHelper: () => (/* binding */ UrlHelper),
/* harmony export */   "default": () => (/* binding */ UrlHelper),
/* harmony export */   urlHelper: () => (/* binding */ UrlHelper)
/* harmony export */ });
/**
 * URL Object Class with public methods for URL functions and manipulation.
 *
 * @module urlHelper
 */
function UrlHelper(__u) {

    /**
     * Reference to the global window object.
     * @type {Window}
     */
    const win = window;

    /**
     * Reference to the global document object.
     * @type {Document}
     */
    const doc = document;

    /**
     * Get the host value, check if template head has defined this variable.
     * @type {string|boolean}
     */
    const $H = win.$HOST || false;

    /**
     * Get the template value, check if template head has defined this variable.
     * @type {string|boolean}
     */
    const $TMP = win.$TEMPLATE || false;

    /**
     * Server Protocol.
     * @type {string}
     */
    const PROTOCOL = win.location.protocol.replace(':', '');

    /**
     * Hostname.
     * @type {string}
     */
    const HOST = $H || win.location.host;

    /**
     * Template URL.
     * @type {string}
     */
    const TEMPLATE = $TMP || '';

    /**
     * Current Pathname.
     * @type {string}
     */
    const PATH = location.pathname;

    /**
     * Site URL.
     * @type {string}
     */
    const SITE_URL = $H ? $H : `${PROTOCOL}://${HOST}`;

    /**
     * Full URL.
     * @type {string}
     */
    const FULL_URL = $H ? `${$H}${PATH}` : `${PROTOCOL}://${HOST}${PATH}`;

    /**
     * Cached URL parameters.
     * @type {Object|null}
     */
    let cachedURLParams = null;

    /**
     * Parse and return URL parameters.
     *
     * @return {Object} with params, queryString, search, keys, values, and collection.
     * @private
     */
    const parseURLParams = () => {
        if (cachedURLParams) {
            return cachedURLParams;
        }

        const params = new URLSearchParams(win.location.search);
        const vars = {};

        for (const [key, value] of params.entries()) {
            vars[key] = value;
        }

        cachedURLParams = {
            params,
            queryString: params.toString(),
            search: win.location.search,
            keys: Array.from(params.keys()),
            values: Array.from(params.values()),
            collection: vars,
        };

        return cachedURLParams;
    };

    /**
     * Get the current page name (Last part of the URL).
     *
     * @return {string} Current page name.
     */
    __u.getPage = () => {
        const cURL = doc.location.toString().toLowerCase();
        const page = cURL.split('/').pop().split('.')[0];
        return page || 'index'; // assuming 'index' as the default page name
    };

    /**
     * Get the query object info from the current URL.
     *
     * @return {Object} with params, queryString, search, keys, values, and collection.
     */
    __u.getParams = () => {
        return parseURLParams();
    };

    /**
     * Get the query string from the current URL.
     *
     * @return {string} Query string.
     */
    __u.getQuery = () => {
        return parseURLParams().queryString;
    };

    /**
     * Add params to the current query string from the current URL.
     *
     * @param {Object} query - The query object to add.
     * @return {Object} with collection and queryString.
     */
    __u.addToQuery = (query) => {
        const currentQuery = parseURLParams().collection;
        Object.assign(currentQuery, query);
        const qString = Object.entries(currentQuery)
            .map(([key, value]) => `${key}=${value}`)
            .join('&');

        return {
            collection: currentQuery,
            queryString: qString,
        };
    };

    /**
     * Get only the URL hash.
     *
     * @return {string} Current hash.
     */
    __u.getHash = () => win.location.hash.substring(1);

    /**
     * Set the URL hash.
     *
     * @param {string} h - The hash to set.
     */
    __u.setHash = (h) => {
        doc.location.hash = h;
    };

    /**
     * Remove the URL hash.
     */
    __u.deleteHash = () => {
        history.pushState('', doc.title, win.location.pathname);
    };

    /**
     * Go to a specific URL on the same page.
     *
     * @param {string} url - The URL to go to.
     * @return {boolean} Always returns false to prevent browser default behavior.
     */
    __u.goTo = (url) => {
        win.location.href = url;
        return false;
    };

    /**
     * Open a URL in the browser.
     *
     * @param {string} url - The URL to open.
     * @param {string} [name='_blank'] - The name attribute for the new window.
     * @param {string} [params=''] - The window parameters.
     * @return {Window} The window object of the opened URL.
     */
    __u.open = (url, name = '_blank', params = '') => {
        return win.open(url, name, params);
    };

    /**
     * Execute a function if the current URL changes.
     *
     * @param {function} callback - The callback function to execute.
     */
    __u.onChange = (callback) => {
        if (typeof callback === 'function') {
            win.addEventListener('hashchange', callback);
        }
    };

    // Expose constants
    __u.fullUrl = FULL_URL;
    __u.siteUrl = SITE_URL;
    __u.template = TEMPLATE;
    __u.protocol = PROTOCOL;
    __u.host = HOST;
    __u.path = PATH;
    __u.readUrl = doc.URL;
}




/***/ }),

/***/ "./node_modules/knighttower/packages/utility/dist/esm/Utility.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/knighttower/packages/utility/dist/esm/Utility.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Utility: () => (/* binding */ Utility),
/* harmony export */   convertToBool: () => (/* binding */ convertToBool),
/* harmony export */   convertToNumber: () => (/* binding */ convertToNumber),
/* harmony export */   currencyToDecimal: () => (/* binding */ currencyToDecimal),
/* harmony export */   dateFormat: () => (/* binding */ dateFormat),
/* harmony export */   decimalToCurrency: () => (/* binding */ decimalToCurrency),
/* harmony export */   "default": () => (/* binding */ Utility),
/* harmony export */   emptyOrValue: () => (/* binding */ emptyOrValue),
/* harmony export */   formatPhoneNumber: () => (/* binding */ formatPhoneNumber),
/* harmony export */   getDynamicId: () => (/* binding */ getDynamicId),
/* harmony export */   getGoogleMapsAddress: () => (/* binding */ getGoogleMapsAddress),
/* harmony export */   getRandomId: () => (/* binding */ getRandomId),
/* harmony export */   includes: () => (/* binding */ includes),
/* harmony export */   instanceOf: () => (/* binding */ instanceOf),
/* harmony export */   isEmpty: () => (/* binding */ isEmpty),
/* harmony export */   isNumber: () => (/* binding */ isNumber),
/* harmony export */   makeArray: () => (/* binding */ makeArray),
/* harmony export */   openGoogleMapsAddress: () => (/* binding */ openGoogleMapsAddress),
/* harmony export */   randomId: () => (/* binding */ randomId),
/* harmony export */   toCurrency: () => (/* binding */ toCurrency),
/* harmony export */   toDollarString: () => (/* binding */ toDollarString),
/* harmony export */   typeOf: () => (/* binding */ typeOf),
/* harmony export */   uniqueId: () => (/* binding */ uniqueId),
/* harmony export */   utility: () => (/* binding */ Utility),
/* harmony export */   utils: () => (/* binding */ Utility),
/* harmony export */   uuid: () => (/* binding */ uuid),
/* harmony export */   validateEmail: () => (/* binding */ validateEmail),
/* harmony export */   validatePhone: () => (/* binding */ validatePhone)
/* harmony export */ });
// // -----------------------------------------
// /**
//  * @knighttower
//  * @url knighttower.io
//  * @git https://github.com/knighttower/
//  */
// // -----------------------------------------

// -----------------------------
// METHODS
// -----------------------------

/**
 * Convert a value to bool
 * @param {String|Boolean|Int|Number} val
 * @return {Boolean}
 * @usage convertToBool('true') // true
 * @usage convertToBool('false') // false
 * @usage convertToBool('0') // false
 * @usage convertToBool('1') // true
 * @usage convertToBool('') // false
 * @usage convertToBool('true') // true
 * @usage convertToBool('false') // false
 */
function convertToBool(val) {
    switch (typeof val) {
        case 'boolean':
            return val;
        case 'string':
            return val === 'false' || val === '0' ? false : true;
        case 'number':
            return val !== 0;
        default:
            return Boolean(val);
    }
}

/**
 * Converts a given variable to a number if possible.
 * @param {string|number} input - The input variable to convert.
 * @returns {string|number} - The converted number or the original variable.
 * @example convertToNumber(123) // Output: 123 (number)
 * @example convertToNumber(123.45) // Output: 123.45 (number)
 * @example convertToNumber("123") // Output: 123 (number)
 * @example convertToNumber("123.45") // Output: 123.45 (number)
 * @example convertToNumber("abc") // Output: "abc" (original string)
 * @example convertToNumber("123abc") // Output: "123abc" (original string)
 * @example convertToNumber(null) // Output: null (original)
 */
function convertToNumber(input) {
    const isNum = isNumber(input);

    if (isNum !== null) {
        return isNum;
    }
    // Case: String that cannot be converted to a number
    return input;
}

/**
 * Translate dollar amounts to decimal notation
 * @function currencyToDecimal
 * @memberof Utility
 * @param {String|Number} amount
 * @return number
 * @example currencyToDecimal('$123.45') // 123.45
 */
function currencyToDecimal(amount) {
    return Number(amount.replace(/[^0-9.-]+/g, ''));
}

/**
 * Format dates to standard US, with or w/out time
 * @function dateFormat
 * @memberof Utility
 * @param {String} dateTime Raw format 2201-01-01 16:15PM or unix or object
 * @param {Boolean} wTime If set, returns date with time as H:MM A
 * @return string
 * @example dateFormat('2201-01-01 16:15PM') // 01/01/2201
 * @example dateFormat('2201-01-01 16:15PM', true) // 01/01/2201 @ 4:15 PM
 * @example dateFormat('2201-01-01 16:15PM', false) // 01/01/2201
 * @example dateFormat('2201-01-01') // 01/01/2201
 */
function dateFormat(dateTime, wTime) {
    if (!dateTime || isNaN(new Date(dateTime).getTime())) {
        return null;
    }

    const date = new Date(dateTime);

    // Ensuring that the time zone is taken into account.
    const optionsDate = { year: 'numeric', month: '2-digit', day: '2-digit', timeZone: 'UTC' };
    const formattedDate = new Intl.DateTimeFormat('en-US', optionsDate).format(date);

    if (wTime) {
        const optionsTime = { hour: '2-digit', minute: '2-digit', hour12: true, timeZone: 'UTC' };
        const formattedTime = new Intl.DateTimeFormat('en-US', optionsTime).format(date);
        return `${formattedDate} @ ${formattedTime}`;
    }

    return formattedDate;
}

/**
 * Translate decimal notation to dollar amount
 * @function decimalToCurrency
 * @memberof Utility
 * @param {String|Number} amount
 * @return number
 * @example decimalToCurrency(123.45) // 123.45
 * @example decimalToCurrency(2123.46) // 2,123.46
 */
function decimalToCurrency(amount) {
    const formatConfig = {
        minimumFractionDigits: 2,
    };
    return new Intl.NumberFormat('en-GB', formatConfig).format(amount);
}

/**
 * Check if there is a value, if not return null or the default value
 * It can test strings, arrays, objects, numbers, booleans
 * @function emptyOrValue
 * @memberof Utility
 * @param {String|Number} value If the value is not empty, returns it
 * @param {String|Number} _default The default value if empty
 * @return mixed
 * @example emptyOrValue('test', 'default') // 'test'
 * @example emptyOrValue('', 'default') // 'default'
 * @example emptyOrValue('test') // 'test'
 * @example emptyOrValue('') // null
 * @example emptyOrValue(0) // 0
 * @example var hello = ''; emptyOrValue(hello) // Null
 * @example var hello = 'test'; emptyOrValue(hello) // 'test'
 * @example var hello = 'test'; emptyOrValue(hello, 'default') // 'test'
 * @example var hello = ''; emptyOrValue(hello, 'default') // 'default'
 * @example var hello = []; emptyOrValue(hello, 'default') // null
 * @example var hello = {}; emptyOrValue(hello, 'default') // null
 * @example var hello = [...]; emptyOrValue(hello') // [...]
 */
function emptyOrValue(value, _default = null) {
    /**
     * Test sequence:
     * If it is a number 0> : true
     * If is not undefined: true
     * If it is boolean (true|false) prevents going to empty
     * If it is not Empty, [], null, {}, 0, true, false: true
     */

    if (isNumber(value) !== null || typeof value === 'boolean') {
        return value;
    } else if (!isEmpty(value)) {
        return value;
    }

    return _default;
}

/**
 * Format a phone number based on a given template.
 * @param {string} phoneNumber - The phone number to format.
 * @param {string} template - The template to use for formatting.
 * @returns {string} - The formatted phone number.
 * @example console.log(formatPhoneNumber('1234567890', '(000) 000-0000')); // Output: (123) 456-7890
 * @example console.log(formatPhoneNumber('1234567890', '000-000-0000')); // Output: 123-456-7890
 * @example console.log(formatPhoneNumber('123-456-7890', '(000) 000-0000')); // Output: (123) 456-7890
 * @example console.log(formatPhoneNumber('(123) 456-7890', '000-0000-0000')); // Output: 123-4567-890
 */
function formatPhoneNumber(phoneNumber, template) {
    // Remove all non-numeric characters from the phone number
    const cleaned = phoneNumber.replace(/\D/g, '');

    // Verify the length of the cleaned phone number
    if (cleaned.length !== 10) {
        throw new Error('Invalid phone number length');
    }

    // Initialize an array to hold the formatted phone number
    let formatted = [];

    // Initialize a pointer for the cleaned phone number
    let cleanedPointer = 0;

    // Loop through the template and replace placeholders with actual numbers
    for (let i = 0; i < template.length; i++) {
        if (template[i] === '0') {
            formatted.push(cleaned[cleanedPointer]);
            cleanedPointer++;
        } else {
            formatted.push(template[i]);
        }
    }

    return formatted.join('');
}

/**
 * Make sure the the item is an array or convert it to an array
 * @function makeArray
 * @param {String|Array} item
 * @return array
 * @example makeArray('test') // ['test']
 */
const makeArray = (item) => (Array.isArray(item) ? item : [item]);

/**
 * Generate unique ids
 * @function getDynamicId
 * @memberof Utility
 * @return string Format kn__000000__000
 */
function getDynamicId() {
    return 'kn__' + new Date().getTime() + '__' + Math.floor(Math.random() * (999 - 100));
}

/**
 * Alias to getDynamicId
 * @function getRandomId
 * @memberof Utility
 * @return string
 * @example getRandomId() // kn__000000__000
 */
const getRandomId = getDynamicId;
const randomId = getDynamicId;

const uuid = (max = 20) => {
    const rnd = () => Math.random().toString(36).substring(2, 15);
    max = max || 40;
    var str = '';
    for (var i = 0; i < max / 3 + 1; i++) {
        str += rnd();
    }
    return str.substring(0, max);
};
const uniqueId = uuid;

/**
 * Form a valid Google search address
 * @function getGoogleMapsAddress
 * @memberof Utility
 * @param {String|Object} address
 * @return string
 * @example getGoogleMapsAddress('New York') // 'https://maps.google.it/maps?q=New+York'
 * @example getGoogleMapsAddress({ address: 'New York', zip: '10001' }) // 'https://maps.google.it/maps?q=New+York+10001'
 * @example getGoogleMapsAddress({ address: 'New York', city: 'New York', state: 'NY' }) // 'https://maps.google.it/maps?q=New+York+New+York+NY'
 */
function getGoogleMapsAddress(address) {
    if (!address) {
        return false;
    }

    let search = '';

    if (typeOf(address, 'string')) {
        search = address;
    } else {
        const keys = ['address', 'address1', 'city', 'state', 'zip', 'zipcode'];

        search = keys.reduce((acc, key) => {
            const value = Object.keys(address).find((aKey) => aKey.includes(key) && address[aKey]);
            return value ? `${acc} ${address[value]}` : acc;
        }, '');
    }

    search = search.trim().replace(/\s+|,/g, '+');
    return `https://maps.google.it/maps?q=${search}`;
}

/**
 * Check if a value is in a collection (array, string, object)
 * @param {collection} collection - The collection to search in
 * @param {value} value - The value to search for
 * @param {fromIndex} fromIndex - The index to start searching from
 * @return {boolean} - True if the value is in the collection, false otherwise
 */
function includes(collection, value, fromIndex = 0) {
    if (Array.isArray(collection) || typeof collection === 'string') {
        // Use native includes for arrays and strings
        return collection.includes(value, fromIndex);
    }

    if (typeof collection === 'object') {
        // Search in object values
        for (let key in collection) {
            if (collection[key] === value) {
                return true;
            }
        }
    }

    return false;
}

/**
 * Check if a value is empty
 * @function isEmpty
 * @memberof Utility
 * @param {string|array|object|map|set|number|boolean} value
 * @url https://moderndash.io/
 * @return {string}
 */
function isEmpty(value) {
    if (value === null || value === undefined) {
        return true;
    }

    if (typeof value === 'string' || Array.isArray(value)) {
        return value.length === 0;
    }

    if (value instanceof Map || value instanceof Set) {
        return value.size === 0;
    }

    if (ArrayBuffer.isView(value)) {
        return value.byteLength === 0;
    }

    if (typeof value === 'object') {
        return Object.keys(value).length === 0;
    }

    return false;
}

/**
 * Check if is a number or Int, if not return null
 * Integrates both Int and Number, or convert a string number to number to test
 * Note: this is not like Lodash isNumber since this one takes into consideration the 'string number'
 * @function isNumber
 * @memberof Utility
 * @param {String|Number} value
 * @return null|int
 * @example isNumber(123) // true
 * @example isNumber(123.45) // true
 * @example isNumber('123abc') // false
 * @example isNumber('abc') // false
 * @example isNumber('') // false
 * @example isNumber("123") // true
 * @example isNumber("123.45") // true
 */
function isNumber(value) {
    const isType = typeof value;
    switch (value) {
        case null:
        case undefined:
        case '':
            return null;
        case '0':
        case 0:
            return 0;
        default:
            if (isType === 'number' || isType === 'string') {
                if (typeof value === 'number' || !Number.isNaN(Number(value))) {
                    return +value;
                }
            }

            break;
    }

    return null;
}

/**
 * Check the instance of a variable, and get the correct type for it. It also accepts simple comparisons
 * For more advance type checking see https://github.com/knighttower/JsTypeCheck
 * @param {any} input - The variable to check
 * @param {string|instance} test - The types to check against, piped string
 * @return {string|boolean} - The type of the variable or boolean when test is provided
 */
function instanceOf(input, test) {
    let inputType = 'unknown';
    const isValid = typeof input === 'function' || typeof input === 'object';
    if (input === null || !isValid) {
        return false;
    }

    const instanceMapping = [Date, RegExp, Promise, Map, Set, WeakMap, WeakSet, ArrayBuffer, DataView];
    let instTotal = instanceMapping.length;
    while (instTotal--) {
        if (input instanceof instanceMapping[instTotal]) {
            inputType = instanceMapping[instTotal].name;
            break;
        }
    }

    if (test) {
        test = typeof test === 'string' ? test.toLowerCase() : test.name.toLowerCase();
        // In case that the input is a custom instance
        if (inputType === 'unknown') {
            inputType = input.name;
        }
        return test === inputType.toLowerCase();
    }

    return inputType;
}

/**
 * Open a Google Map using a provided address
 * @function openGoogleMapsAddress
 * @memberof Utility
 * @param {String|Object} object - Address information either as a string or as an object
 * @throws {Error} Throws an error if the address is invalid or if it's not a string or object.
 * @return {void}
 * @example openGoogleMapsAddress('New York'); // Opens Google Maps with the address 'New York'
 * @example openGoogleMapsAddress({ address: 'New York', zip: '10001' }); // Opens Google Maps with the address 'New York 10001'
 */
function openGoogleMapsAddress(object) {
    if (!typeOf(object, 'string') || !typeOf(object, 'object')) {
        throw new Error('The input must be a string or an object.');
    }

    const address = getGoogleMapsAddress(object);

    if (!isEmpty(address) || !typeOf(address, 'string')) {
        throw new Error('The address you are trying to open is invalid.');
    }

    return window.open(address, '_blank');
}

/**
 * Alias to getDynamicId
 * @function toCurrency
 * @memberof Utility
 * @param {String|Number} amount
 * @return number
 * @example toCurrency(123.45) // 123.45
 * @example toCurrency(2123.46) // 2,123.46
 */
function toCurrency(amount) {
    return decimalToCurrency(amount);
}

/**
 * Covert to dollar string
 * @function toDollarString
 * @memberof Utility
 * @param {String|Number} amount
 * @return number
 * @example toDollarString(2,000) // 2K
 * @example toDollarString(2,000,000) // 2M
 * @example toDollarString(2,500,000) // 2.5M
 */
function toDollarString(amount) {
    if (typeOf(amount, 'string')) {
        amount = currencyToDecimal(amount);
    }

    if (Math.abs(amount) > 999 && Math.abs(amount) < 999999) {
        return Math.sign(amount) * (Math.abs(amount) / 1000).toFixed(1) + 'K';
    }
    if (Math.abs(amount) > 999999) {
        return Math.sign(amount) * (Math.abs(amount) / 1000000).toFixed(1) + 'M';
    }

    return Math.sign(amount) * Math.abs(amount);
}

/**
 * Check the type of a variable, and get the correct type for it. It also accepts simple comparisons
 * For more advance type checking see https://github.com/knighttower/JsTypeCheck
 * @param {any} input - The variable to check
 * @param {string} test - The types to check against, piped string
 * @return {string|boolean} - The type of the variable
 * @example typeOf('hello', 'string') // returns true
 * @example typeOf('hello', 'number') // returns false
 * @example typeOf('hello', 'string') // returns true
 * @example typeOf('hello') // returns 'string'
 * @example typeOf({}) // returns 'object'
 */
function typeOf(input, test) {
    // Special case for null since it can be treated as an object
    if (input === null) {
        if (test) {
            return test === null || test === 'null' ? true : false;
        }
        return 'null';
    }

    let inputType;

    switch (typeof input) {
        case 'number':
        case 'string':
        case 'boolean':
        case 'undefined':
        case 'bigint':
        case 'symbol':
        case 'function':
            inputType = typeof input;
            break;
        case 'object':
            inputType = Array.isArray(input) ? 'array' : 'object';

            break;
        default:
            inputType = 'unknown';
    }

    if (test) {
        if (test.includes('|')) {
            for (let type of test.split('|')) {
                if (inputType === type) {
                    return type;
                }
            }
            return false;
        }

        return test === inputType;
    }

    return inputType;
}

/**
 * Validate emails
 * @function validateEmail
 * @memberof Utility
 * @param {String} email
 * @return Boolean
 * @example validateEmail('<EMAIL>') // false
 * @example validateEmail('test@test') // false
 * @example validateEmail('test@test.') // false
 * @example validateEmail('test@test.c') // false
 * @example validateEmail('test@test.com') // true
 */
function validateEmail(email) {
    var emailRegex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}$/;
    return emailRegex.test(email);
}

/**
 * Validate a phone number
 * @function validatePhone
 * @memberof Utility
 * @param {String} phone
 * @return void|Toast
 * @example validatePhone('1234567890') // true
 * @example validatePhone('(123) 456-7890') // true
 * @example validatePhone('123-456-7890') // true
 * @example validatePhone('123 456 7890') // false
 * @example validatePhone('123-4567-89') // false
 */
function validatePhone(phone) {
    var phoneRegex = /^\(?(\d{3})\)?[- ]?(\d{3})[- ]?(\d{4})$/;
    return phoneRegex.test(phone);
}

// export default Utility;
const Utility = {
    convertToBool,
    currencyToDecimal,
    convertToNumber,
    dateFormat,
    decimalToCurrency,
    emptyOrValue,
    formatPhoneNumber,
    getDynamicId,
    getGoogleMapsAddress,
    getRandomId,
    includes,
    isEmpty, // from https://moderndash.io/
    isNumber,
    instanceOf,
    openGoogleMapsAddress,
    toCurrency,
    toDollarString,
    typeOf,
    validateEmail,
    validatePhone,
    makeArray,
    uuid,
    uniqueId,
};




/***/ }),

/***/ "./node_modules/knighttower/packages/utility/index.js":
/*!************************************************************!*\
  !*** ./node_modules/knighttower/packages/utility/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DomObserver: () => (/* reexport safe */ _dist_esm_DomObserver_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   ElementHelper: () => (/* reexport safe */ _dist_esm_ElementHelper_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   EventBus: () => (/* reexport safe */ _dist_esm_EventBus_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   PowerHelper: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.PowerHelper),
/* harmony export */   PromisePool: () => (/* reexport safe */ _dist_esm_PromiseQueue_mjs__WEBPACK_IMPORTED_MODULE_4__.PromisePool),
/* harmony export */   PromiseQueue: () => (/* reexport safe */ _dist_esm_PromiseQueue_mjs__WEBPACK_IMPORTED_MODULE_4__.PromiseQueue),
/* harmony export */   ProxyClass: () => (/* reexport safe */ _dist_esm_ProxyClass_mjs__WEBPACK_IMPORTED_MODULE_5__.ProxyClass),
/* harmony export */   ProxyObject: () => (/* reexport safe */ _dist_esm_ProxyObject_mjs__WEBPACK_IMPORTED_MODULE_6__.ProxyObject),
/* harmony export */   UrlHelper: () => (/* reexport safe */ _dist_esm_UrlHelper_mjs__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   Utility: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   _eventBus: () => (/* reexport safe */ _dist_esm_EventBus_mjs__WEBPACK_IMPORTED_MODULE_2__._eventBus),
/* harmony export */   addQuotes: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.addQuotes),
/* harmony export */   cleanStr: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.cleanStr),
/* harmony export */   convertKeysToSymbols: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.convertKeysToSymbols),
/* harmony export */   convertToBool: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.convertToBool),
/* harmony export */   convertToNumber: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.convertToNumber),
/* harmony export */   currencyToDecimal: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.currencyToDecimal),
/* harmony export */   dateFormat: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.dateFormat),
/* harmony export */   decimalToCurrency: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.decimalToCurrency),
/* harmony export */   doPoll: () => (/* reexport safe */ _dist_esm_PromiseQueue_mjs__WEBPACK_IMPORTED_MODULE_4__.doPoll),
/* harmony export */   domObserver: () => (/* reexport safe */ _dist_esm_DomObserver_mjs__WEBPACK_IMPORTED_MODULE_0__.domObserver),
/* harmony export */   elementHelper: () => (/* reexport safe */ _dist_esm_ElementHelper_mjs__WEBPACK_IMPORTED_MODULE_1__.elementHelper),
/* harmony export */   emptyOrValue: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.emptyOrValue),
/* harmony export */   findAndReplaceInArray: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.findAndReplaceInArray),
/* harmony export */   findNested: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.findNested),
/* harmony export */   fixQuotes: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.fixQuotes),
/* harmony export */   formatPhoneNumber: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.formatPhoneNumber),
/* harmony export */   getArrObjFromString: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.getArrObjFromString),
/* harmony export */   getChunks: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.getChunks),
/* harmony export */   getDirectivesFromString: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.getDirectivesFromString),
/* harmony export */   getDynamicId: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.getDynamicId),
/* harmony export */   getGoogleMapsAddress: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.getGoogleMapsAddress),
/* harmony export */   getMatchBlock: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.getMatchBlock),
/* harmony export */   getMatchInBetween: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.getMatchInBetween),
/* harmony export */   getRandomId: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.getRandomId),
/* harmony export */   includes: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.includes),
/* harmony export */   instanceOf: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.instanceOf),
/* harmony export */   isEmpty: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.isEmpty),
/* harmony export */   isNumber: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.isNumber),
/* harmony export */   makeArray: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.makeArray),
/* harmony export */   openGoogleMapsAddress: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.openGoogleMapsAddress),
/* harmony export */   powerHelper: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   promisePool: () => (/* reexport safe */ _dist_esm_PromiseQueue_mjs__WEBPACK_IMPORTED_MODULE_4__.promisePool),
/* harmony export */   promiseQueue: () => (/* reexport safe */ _dist_esm_PromiseQueue_mjs__WEBPACK_IMPORTED_MODULE_4__.promiseQueue),
/* harmony export */   proxyClass: () => (/* reexport safe */ _dist_esm_ProxyClass_mjs__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   proxyObject: () => (/* reexport safe */ _dist_esm_ProxyObject_mjs__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   randomId: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.randomId),
/* harmony export */   removeQuotes: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.removeQuotes),
/* harmony export */   selectElement: () => (/* reexport safe */ _dist_esm_ElementHelper_mjs__WEBPACK_IMPORTED_MODULE_1__.selectElement),
/* harmony export */   setExpString: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.setExpString),
/* harmony export */   setLookUpExp: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.setLookUpExp),
/* harmony export */   setWildCardString: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.setWildCardString),
/* harmony export */   startAndEndWith: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.startAndEndWith),
/* harmony export */   toCurrency: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.toCurrency),
/* harmony export */   toDollarString: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.toDollarString),
/* harmony export */   typeOf: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.typeOf),
/* harmony export */   uniqueId: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.uniqueId),
/* harmony export */   urlHelper: () => (/* reexport safe */ _dist_esm_UrlHelper_mjs__WEBPACK_IMPORTED_MODULE_7__.urlHelper),
/* harmony export */   utility: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.utility),
/* harmony export */   utils: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.utils),
/* harmony export */   uuid: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.uuid),
/* harmony export */   validateEmail: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.validateEmail),
/* harmony export */   validatePhone: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.validatePhone),
/* harmony export */   wildCardStringSearch: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.wildCardStringSearch)
/* harmony export */ });
/* harmony import */ var _dist_esm_DomObserver_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/esm/DomObserver.mjs */ "./node_modules/knighttower/packages/utility/dist/esm/DomObserver.mjs");
/* harmony import */ var _dist_esm_ElementHelper_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dist/esm/ElementHelper.mjs */ "./node_modules/knighttower/packages/utility/dist/esm/ElementHelper.mjs");
/* harmony import */ var _dist_esm_EventBus_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dist/esm/EventBus.mjs */ "./node_modules/knighttower/packages/utility/dist/esm/EventBus.mjs");
/* harmony import */ var _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dist/esm/PowerHelpers.mjs */ "./node_modules/knighttower/packages/utility/dist/esm/PowerHelpers.mjs");
/* harmony import */ var _dist_esm_PromiseQueue_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dist/esm/PromiseQueue.mjs */ "./node_modules/knighttower/packages/utility/dist/esm/PromiseQueue.mjs");
/* harmony import */ var _dist_esm_ProxyClass_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dist/esm/ProxyClass.mjs */ "./node_modules/knighttower/packages/utility/dist/esm/ProxyClass.mjs");
/* harmony import */ var _dist_esm_ProxyObject_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dist/esm/ProxyObject.mjs */ "./node_modules/knighttower/packages/utility/dist/esm/ProxyObject.mjs");
/* harmony import */ var _dist_esm_UrlHelper_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./dist/esm/UrlHelper.mjs */ "./node_modules/knighttower/packages/utility/dist/esm/UrlHelper.mjs");
/* harmony import */ var _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./dist/esm/Utility.mjs */ "./node_modules/knighttower/packages/utility/dist/esm/Utility.mjs");
// Single Modules and Aliases from: DomObserver

// Default Module from: DomObserver

// Single Modules and Aliases from: ElementHelper

// Default Module from: ElementHelper

// Single Modules and Aliases from: EventBus

// Default Module from: EventBus

// Single Modules and Aliases from: PowerHelpers

// Default Module from: PowerHelpers

// Single Modules and Aliases from: PromiseQueue

// Single Modules and Aliases from: ProxyClass

// Default Module from: ProxyClass

// Single Modules and Aliases from: ProxyObject

// Default Module from: ProxyObject

// Single Modules and Aliases from: UrlHelper

// Default Module from: UrlHelper

// Single Modules and Aliases from: Utility

// Default Module from: Utility





/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!*******************************!*\
  !*** ./examples/react/app.js ***!
  \*******************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var Adaptive_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Adaptive.js */ "./src/Adaptive.js");
/* harmony import */ var _hello_jsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hello.jsx */ "./examples/react/hello.jsx");
/**
* @author Knighttower
    MIT License

    Copyright (c) [2022] [Knighttower] https://github.com/knighttower

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/
// We are using the React tag, but when using import...
// import React from 'react';
// import ReactDom from 'react-dom';

// When, in actual use, this should be: import Adaptive from 'Adaptive';

//Optional | Add custom media query (min px, max px) settings (min max)
Adaptive_js__WEBPACK_IMPORTED_MODULE_0__["default"].addQueryMinMax('kitty', 900, 1400);
// Optional | Add a custom media query expression (it accepts any valid media query)
Adaptive_js__WEBPACK_IMPORTED_MODULE_0__["default"].addQueryExpression('doggy', '(min-width: 900px)');
// Register react object and use in Hybrid mode (default is false)
Adaptive_js__WEBPACK_IMPORTED_MODULE_0__["default"].useReact(React, true);

// Do components and other stuff right after

Adaptive_js__WEBPACK_IMPORTED_MODULE_0__["default"].init();
})();

/******/ })()
;