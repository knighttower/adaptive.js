/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./examples/vue/compApiSample.vue?vue&type=script&lang=js":
/*!********************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./examples/vue/compApiSample.vue?vue&type=script&lang=js ***!
  \********************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "vue");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  setup: function setup() {
    var Adaptive = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)('Adaptive');
    // console.log($Adaptive);
    var count = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(0);
    Adaptive["if"]('mobile', function () {
      console.log(555);
    });
    Adaptive["if"]('desktop', function () {
      console.log(33);
    })["else"](function () {
      console.log(44);
    });
    return {
      count: count
    };
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./examples/vue/hello.vue?vue&type=script&lang=js":
/*!************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./examples/vue/hello.vue?vue&type=script&lang=js ***!
  \************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  data: function data() {
    return {
      greeting: 'Example Vue component Hello World!',
      show: false,
      tablet: null
    };
  },
  mounted: function mounted() {
    // Example using the ref and custom registered media query (see the app.js)
    this.Adaptive.registerElement(this.$refs.six, {
      addClass: {
        doggy: 'seven'
      }
    });

    // can use this...
    this.Adaptive.registerElement(this.$refs.callmeback, {
      execute: {
        mobile: function mobile(element) {
          console.log('This is a callback at mobile breakdown');
          console.log(element);
        }
      }
    });
    // or
    this.Adaptive["if"]('tablet', [this, 'tablet']);
    // or
    this.Adaptive["if"]('tablet', function () {
      // code
    });
    // or
    this.Adaptive["if"]('tablet', this.changeText);
  },
  methods: {
    changeText: function changeText() {
      this.greeting = Math.floor(Math.random() * 10);
    },
    toggle: function toggle() {
      this.show = !this.show;
    }
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./examples/vue/compApiSample.vue?vue&type=template&id=ce9613d8":
/*!************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./examples/vue/compApiSample.vue?vue&type=template&id=ce9613d8 ***!
  \************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "vue");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);

function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)(" Composition Api component "), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("button", {
    onClick: _cache[0] || (_cache[0] = function ($event) {
      return $setup.count++;
    })
  }, "You clicked me " + (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($setup.count) + " times.", 1 /* TEXT */)]);
}

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./examples/vue/hello.vue?vue&type=template&id=d78c255e":
/*!****************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./examples/vue/hello.vue?vue&type=template&id=d78c255e ***!
  \****************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "vue");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);

var _hoisted_1 = {
  "class": "sample"
};
var _hoisted_2 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("h4", null, "Start Hello component", -1 /* HOISTED */);
var _hoisted_3 = {
  "class": "greeting"
};
var _hoisted_4 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("br", null, null, -1 /* HOISTED */);
var _hoisted_5 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("br", null, null, -1 /* HOISTED */);
var _hoisted_6 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("br", null, null, -1 /* HOISTED */);
var _hoisted_7 = {
  ref: "six"
};
var _hoisted_8 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("br", null, null, -1 /* HOISTED */);
var _hoisted_9 = {
  key: 0,
  "class": "lazy"
};
var _hoisted_10 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("br", null, null, -1 /* HOISTED */);
var _hoisted_11 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("br", null, null, -1 /* HOISTED */);
var _hoisted_12 = {
  style: {
    "background-color": "white"
  }
};
var _hoisted_13 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("br", null, null, -1 /* HOISTED */);
var _hoisted_14 = {
  ref: "callmeback"
};
var _hoisted_15 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("br", null, null, -1 /* HOISTED */);
var _hoisted_16 = {
  key: 1
};
var _hoisted_17 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("br", null, null, -1 /* HOISTED */);
var _hoisted_18 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", {
  id: "hitTarget"
}, null, -1 /* HOISTED */);
var _hoisted_19 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("h4", null, "End Hello component", -1 /* HOISTED */);
function render(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_teleport_to = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("teleport-to");
  var _directive_adaptive = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveDirective)("adaptive");
  var _directive_teleport_to = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveDirective)("teleport-to");
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_1, [_hoisted_2, (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_teleport_to, {
    target: "#hitTarget"
  }, {
    "default": (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(function () {
      return [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)("Hola")];
    }),
    _: 1 /* STABLE */
  }), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("p", _hoisted_3, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($data.greeting), 1 /* TEXT */), _hoisted_4, (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("button", {
    onClick: _cache[0] || (_cache[0] = function () {
      return $options.changeText && $options.changeText.apply($options, arguments);
    })
  }, "Test Vue component is working"), _hoisted_5, (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(" Example of directive binding with Adaptive "), (0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)(((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)("Using Directive inside Vue component")])), [[_directive_adaptive, {
    addClass: {
      desktop: 'cinco'
    }
  }]]), _hoisted_6, (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(" Example of use as a ref element with plugin style "), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", _hoisted_7, "Using Ref element inside component for Vue Plugin mode and custom media query expression", 512 /* NEED_PATCH */), _hoisted_8, (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(" Example of a later insertion "), $data.show ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_9, "Using (observer) After load inside component")) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("v-if", true), _hoisted_10, (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("button", {
    onClick: _cache[1] || (_cache[1] = function () {
      return $options.toggle && $options.toggle.apply($options, arguments);
    })
  }, "Show hide Lazy element"), _hoisted_11, (0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)(((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_12, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)(" this is a VUE component... Getting teleported (teleport) from the component to \"inside of static Hello\" ")])), [[_directive_teleport_to, '#hello']]), _hoisted_13, (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", _hoisted_14, "Has a callback function at a defined breakdown", 512 /* NEED_PATCH */), _hoisted_15, $data.tablet ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", _hoisted_16, "Has a conditional IF tablet")) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("v-if", true), _hoisted_17, _hoisted_18, _hoisted_19]);
}

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-8.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-8.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./examples/vue/hello.vue?vue&type=style&index=0&id=d78c255e&lang=css":
/*!*************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??clonedRuleSet-8.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-8.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./examples/vue/hello.vue?vue&type=style&index=0&id=d78c255e&lang=css ***!
  \*************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);
// Imports

var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});
// Module
___CSS_LOADER_EXPORT___.push([module.id, "\n.greeting {\n    color: red;\n    font-weight: bold;\n}\n", ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {



/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join("");
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === "string") {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, ""]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-8.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-8.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./examples/vue/hello.vue?vue&type=style&index=0&id=d78c255e&lang=css":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-8.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-8.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./examples/vue/hello.vue?vue&type=style&index=0&id=d78c255e&lang=css ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_clonedRuleSet_8_use_1_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_8_use_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_hello_vue_vue_type_style_index_0_id_d78c255e_lang_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-8.use[1]!../../node_modules/vue-loader/dist/stylePostLoader.js!../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-8.use[2]!../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./hello.vue?vue&type=style&index=0&id=d78c255e&lang=css */ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-8.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-8.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./examples/vue/hello.vue?vue&type=style&index=0&id=d78c255e&lang=css");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_clonedRuleSet_8_use_1_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_8_use_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_hello_vue_vue_type_style_index_0_id_d78c255e_lang_css__WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_clonedRuleSet_8_use_1_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_8_use_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_hello_vue_vue_type_style_index_0_id_d78c255e_lang_css__WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : 0;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && typeof btoa !== 'undefined') {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/vue-loader/dist/exportHelper.js":
/*!******************************************************!*\
  !*** ./node_modules/vue-loader/dist/exportHelper.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
// runtime helper for setting properties on components
// in a tree-shakable way
exports["default"] = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
        target[key] = val;
    }
    return target;
};


/***/ }),

/***/ "./examples/vue/compApiSample.vue":
/*!****************************************!*\
  !*** ./examples/vue/compApiSample.vue ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _compApiSample_vue_vue_type_template_id_ce9613d8__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compApiSample.vue?vue&type=template&id=ce9613d8 */ "./examples/vue/compApiSample.vue?vue&type=template&id=ce9613d8");
/* harmony import */ var _compApiSample_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./compApiSample.vue?vue&type=script&lang=js */ "./examples/vue/compApiSample.vue?vue&type=script&lang=js");
/* harmony import */ var _node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../node_modules/vue-loader/dist/exportHelper.js */ "./node_modules/vue-loader/dist/exportHelper.js");




;
const __exports__ = /*#__PURE__*/(0,_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__["default"])(_compApiSample_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__["default"], [['render',_compApiSample_vue_vue_type_template_id_ce9613d8__WEBPACK_IMPORTED_MODULE_0__.render],['__file',"examples/vue/compApiSample.vue"]])
/* hot reload */
if (false) {}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__exports__);

/***/ }),

/***/ "./examples/vue/hello.vue":
/*!********************************!*\
  !*** ./examples/vue/hello.vue ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _hello_vue_vue_type_template_id_d78c255e__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hello.vue?vue&type=template&id=d78c255e */ "./examples/vue/hello.vue?vue&type=template&id=d78c255e");
/* harmony import */ var _hello_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hello.vue?vue&type=script&lang=js */ "./examples/vue/hello.vue?vue&type=script&lang=js");
/* harmony import */ var _hello_vue_vue_type_style_index_0_id_d78c255e_lang_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hello.vue?vue&type=style&index=0&id=d78c255e&lang=css */ "./examples/vue/hello.vue?vue&type=style&index=0&id=d78c255e&lang=css");
/* harmony import */ var _node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../node_modules/vue-loader/dist/exportHelper.js */ "./node_modules/vue-loader/dist/exportHelper.js");




;


const __exports__ = /*#__PURE__*/(0,_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_3__["default"])(_hello_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__["default"], [['render',_hello_vue_vue_type_template_id_d78c255e__WEBPACK_IMPORTED_MODULE_0__.render],['__file',"examples/vue/hello.vue"]])
/* hot reload */
if (false) {}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__exports__);

/***/ }),

/***/ "./examples/vue/compApiSample.vue?vue&type=script&lang=js":
/*!****************************************************************!*\
  !*** ./examples/vue/compApiSample.vue?vue&type=script&lang=js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_compApiSample_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_compApiSample_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./compApiSample.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./examples/vue/compApiSample.vue?vue&type=script&lang=js");
 

/***/ }),

/***/ "./examples/vue/hello.vue?vue&type=script&lang=js":
/*!********************************************************!*\
  !*** ./examples/vue/hello.vue?vue&type=script&lang=js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_hello_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_hello_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./hello.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./examples/vue/hello.vue?vue&type=script&lang=js");
 

/***/ }),

/***/ "./examples/vue/compApiSample.vue?vue&type=template&id=ce9613d8":
/*!**********************************************************************!*\
  !*** ./examples/vue/compApiSample.vue?vue&type=template&id=ce9613d8 ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_compApiSample_vue_vue_type_template_id_ce9613d8__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_compApiSample_vue_vue_type_template_id_ce9613d8__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./compApiSample.vue?vue&type=template&id=ce9613d8 */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./examples/vue/compApiSample.vue?vue&type=template&id=ce9613d8");


/***/ }),

/***/ "./examples/vue/hello.vue?vue&type=template&id=d78c255e":
/*!**************************************************************!*\
  !*** ./examples/vue/hello.vue?vue&type=template&id=d78c255e ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_hello_vue_vue_type_template_id_d78c255e__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_hello_vue_vue_type_template_id_d78c255e__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./hello.vue?vue&type=template&id=d78c255e */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./examples/vue/hello.vue?vue&type=template&id=d78c255e");


/***/ }),

/***/ "./examples/vue/hello.vue?vue&type=style&index=0&id=d78c255e&lang=css":
/*!****************************************************************************!*\
  !*** ./examples/vue/hello.vue?vue&type=style&index=0&id=d78c255e&lang=css ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_8_use_1_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_8_use_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_hello_vue_vue_type_style_index_0_id_d78c255e_lang_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/style-loader/dist/cjs.js!../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-8.use[1]!../../node_modules/vue-loader/dist/stylePostLoader.js!../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-8.use[2]!../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./hello.vue?vue&type=style&index=0&id=d78c255e&lang=css */ "./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-8.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-8.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./examples/vue/hello.vue?vue&type=style&index=0&id=d78c255e&lang=css");


/***/ }),

/***/ "vue":
/*!**********************!*\
  !*** external "Vue" ***!
  \**********************/
/***/ ((module) => {

module.exports = Vue;

/***/ }),

/***/ "./src/Adaptive.js":
/*!*************************!*\
  !*** ./src/Adaptive.js ***!
  \*************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Adaptive: () => (/* binding */ _adaptive),
/* harmony export */   adaptive: () => (/* binding */ _adaptive),
/* harmony export */   "default": () => (/* binding */ _adaptive)
/* harmony export */ });
/* harmony import */ var knighttower_utility__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! knighttower/utility */ "./node_modules/knighttower/packages/utility/index.js");
/* harmony import */ var _classes_AdaptiveElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./classes/AdaptiveElement.js */ "./src/classes/AdaptiveElement.js");
/* harmony import */ var _Teleport_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Teleport.js */ "./src/Teleport.js");
/* harmony import */ var _QueryHandler_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./QueryHandler.js */ "./src/QueryHandler.js");
/* harmony import */ var _vue_components_TeleportTo_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./vue-components/TeleportTo.js */ "./src/vue-components/TeleportTo.js");
/* harmony import */ var _web_components_TeleportTo_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./web-components/TeleportTo.js */ "./src/web-components/TeleportTo.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
// Author Knighttower
// MIT License
// Copyright (c) [2022] [knighttower] https://github.com/knighttower

// Inspired by http://wicky.nillia.ms/enquire.js

// Import the Element DOM helper

// -----------------------------------------








// =========================================
// --> ADAPTIVE JS
// --------------------------

/**
 * @module Adaptive
 * Add/remove classes/styles or teleport an element
 * @return {Object}
 * @example Adaptive(window, Adaptive)
 * @example Adaptive(this, Adaptive)
 * @example Adaptive.registerElement(element)
 * @see "example" folder for more
 */
var _adaptive = function () {
  'use strict';

  var $window = typeof window !== 'undefined' ? window : {};

  // -----------------------------------------
  // This will make it reuse the same instance if already imported without overwrites
  if ($window.$adaptive) {
    return $window.$adaptive;
  }
  // -----------------------------------------

  /**
   * Register this library into the $window
   * @private
   * @return {Object}
   */
  var $this = {
    _mutable: ['registerElement', 'addQueryMinMax', 'addQueryExpression']
  };
  var Adaptive = (0,knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.proxyObject)($this);

  /**
   * All the elements that will be part of the grid
   * @private
   */
  var domElements = {};

  /**
   * Flag for isMounted
   * @private
   */
  var isMounted = false;

  /**
   * Flag for using Vue
   * @private
   */
  var useVue = false;

  /**
   * Flag for using React
   * @private
   */
  var useReact = false;

  /**
   * Flag for using React
   * @private
   */
  var useWeb = false;

  /**
   * Flag for using Hybrid
   * @private
   */
  var isHybrid = false;

  /**
   * queries possible sizes
   * @private
   */
  var screens = {
    320: [1, 379],
    480: [380, 519],
    520: [520, 599] /* up to : mobiles */,
    600: [600, 699] /* up to : mid-size-tables */,
    700: [700, 799] /* up to : tablets / ipad */,
    800: [800, 919] /* transition in between tablets and desktop */,
    920: [920, 999] /* from here on for desktops */,
    1000: [1000, 1199],
    1200: [1200, 1439],
    1440: [1440, 1599],
    1600: [1600, 1700]
  };

  /**
   * break the 3 major device types
   * @private
   */
  var devices = {
    mobile: [1, 599] /* Actual phones */,
    tablet: [600, 799] /* tablets in portrait or below */,
    odd: [800, 1023] /* small Laptops and Ipads in landscape */,
    desktop: [1024, 1920] /* Most common resolutions below 1920 */
  };

  /**
   * break the 3 major device types
   * @private
   */
  var broadMediaQueries = {
    'non-desktop': [100, 1023],
    nondesktop: [100, 1023],
    fullscreen: [1920, 6000] /* Large monitos and fullscreen in 1920 res */
  };

  /**
   * To register additional custom queries add the key:[min, max]
   * @private
   */
  var customMinMaxQueries = {};

  /**
   * To register additional custom queries add the key:'Query Expression'
   * @private
   */
  var customExpressionQueries = {};

  // =========================================
  // --> Utility
  // --------------------------

  /**
   * Get all the available queries
   * @private
   * @return {Object}
   */
  $this.getAllQueries = function () {
    return Object.assign({}, screens, devices, broadMediaQueries, customMinMaxQueries, customExpressionQueries);
  };

  /**
   * @memberof Adaptive
   * @inner
   * Get all the available min max queries
   * @return {Object}
   */
  $this.getMinMaxQueries = function () {
    return Object.assign({}, screens, devices, broadMediaQueries, customMinMaxQueries);
  };

  /**
   * @memberof Adaptive
   * @inner
   * Get all the available "expression" queries
   * @return {Object}
   */
  $this.getExpQueries = function () {
    return Object.assign({}, customExpressionQueries);
  };

  /**
   * @memberof Adaptive
   * @inner
   * Register an element
   * @param {String|Object} elementOrSelector
   * @param {Object} data Optional used directly to add the directives, but is mostly for VUe
   * @return {Void}
   */
  $this.registerElement = function (elementOrSelector, data) {
    var helper = (0,knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.selectElement)(elementOrSelector);
    if (helper.isInDom()) {
      return registerThis(helper, data);
    } else {
      helper.whenInDom().then(function (element) {
        return registerThis(element, data);
      });
    }
  };

  /**
   * Register an element
   * @private
   * @param {String|Object} elementOrSelector
   * @param {Object} data Optional used directly to add the directives, but is mostly for VUe
   * @return {Void}
   */
  function registerThis(element, data) {
    // Register only unique non indexed elements
    if (!element.getAttribute('data-adaptive-id')) {
      var uniqueId = element.getHash();
      var settings = (0,knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.getDirectivesFromString)(data || element.getAttribute('data-adaptive')).directive;

      //set the unique id to the element for later use
      element.domElement.setAttribute('data-adaptive-id', uniqueId);
      domElements[uniqueId] = new _classes_AdaptiveElement_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
        adaptiveId: uniqueId,
        helper: element,
        domElement: element.domElement,
        xpath: element.getXpathTo(),
        settings: settings,
        useVue: useVue,
        useReact: useReact
      }, $this);
      return uniqueId;
    }
  }

  /**
   * @memberof Adaptive
   * @inner
   * Register A custom Query Min, Max
   * @param {String} id Identifier
   * @param {Number} min Number only, no units attached as it only handles pixels here
   * @param {Number} max Number only, no units attached as it only handles pixels here
   * @return {Void}
   */
  $this.addQueryMinMax = function (id, min, max) {
    if (!customMinMaxQueries[id]) {
      if (!min || !max) {
        throw new Error('Min or Max must be passed (id, min, max)', 1);
      }
      customMinMaxQueries[id] = [min, max];
    }
  };

  /**
   * @memberof Adaptive
   * @inner
   * Register A custom Query Expression
   * @param {String} id Identifier
   * @param {String} query Media query, example "screen and (max-width: 500em) and (orientation: landscape)"
   * @param {Number} max Number only, no units attached as it only handles pixels here
   * @return {Void}
   */
  $this.addQueryExpression = function (id, query) {
    if (!customExpressionQueries[id]) {
      customExpressionQueries[id] = query;
    }
  };

  /**
   * @memberof Adaptive
   * @inner
   * Register A custom Query Expression
   * @param {String} breakdownId Identifier like "tablet" or "mobile", etc
   * @param {Fucntion|Array} callback Function/Method or Array with object and property to set
   * @example Adaptive.if('mobile', [object, propertyId]) || Adaptive.if('mobile', () => {})
   * @return {Object} Proxy
   */
  $this["if"] = function (breakdownId) {
    var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var isFunction = callback && typeof callback === 'function';
    var isArray = callback && Array.isArray(callback);
    var observer = {};
    observer[breakdownId] = {
      _private: ['breakdownId', 'match', 'ifElse', 'do', 'removeAfterExec'],
      _mutable: ['ifElse', 'match', 'removeAfterExec'],
      uid: (0,knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.getDynamicId)(),
      breakdownId: breakdownId,
      match: false,
      executed: false,
      removeAfterExec: false,
      ifElse: null,
      "else": function _else(ifElse) {
        if (ifElse && typeof ifElse === 'function') {
          this.ifElse = ifElse;
        }
      },
      onlyOnce: function onlyOnce() {
        this.removeAfterExec = true;
        if (this.executed) {
          _QueryHandler_js__WEBPACK_IMPORTED_MODULE_3__["default"].remove(this.uid, 'uid');
        }
      },
      "do": function _do() {
        if (this.match) {
          if (isFunction) {
            callback();
          }
          if (isArray) {
            callback[0][callback[1]] = true;
          }
          if (this.removeAfterExec) {
            _QueryHandler_js__WEBPACK_IMPORTED_MODULE_3__["default"].remove(this.uid, 'uid');
          }
          this.executed = true;
          return true;
        }
        if (isArray) {
          callback[0][callback[1]] = false;
        }
        if (this.ifElse) {
          this.ifElse();
        }
        return false;
      }
    };
    _QueryHandler_js__WEBPACK_IMPORTED_MODULE_3__["default"].add(observer, function (o) {
      o.match = true;
      o["do"]();
    }, function (o) {
      o.match = false;
      o["do"]();
    }, $this);
    return (0,knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.proxyObject)(observer[breakdownId]);
  };

  /**
   * Full reset, handle with care
   * @private
   * @return {Void}
   */
  $this.reset = function () {
    Object.keys(domElements).forEach(function (key) {
      return delete domElements[key];
    });
    knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.DomObserver.cleanup();
    _QueryHandler_js__WEBPACK_IMPORTED_MODULE_3__["default"].reset();
    isMounted = false;
  };

  // =========================================
  // --> DomReady and INIT
  // --------------------------

  /**
   * Real init for the app
   * @private
   */
  function _init() {
    isMounted = true;
    document.querySelectorAll('[data-adaptive]:not([data-adaptive-id])').forEach(function (element) {
      $this.registerElement(element);
    });
    _QueryHandler_js__WEBPACK_IMPORTED_MODULE_3__["default"].init();
    if (useVue || useReact) {
      // hybrid mode
      // support for static and dynamic elements
      if (isHybrid) {
        (0,_Teleport_js__WEBPACK_IMPORTED_MODULE_2__.TeleportGlobal)();
      }
    } else {
      // vanilla js
      (0,_Teleport_js__WEBPACK_IMPORTED_MODULE_2__.TeleportGlobal)();
    }
  }

  /**
   * @memberof Adaptive
   * @inner
   * Initialization, cam be called externally to reinitialized after dom loaded
   * @return {Void}
   */
  $this.init = function () {
    if (isMounted) {
      return false;
    }
    if (document.readyState === 'complete' || document.readyState !== 'loading' && !document.documentElement.doScroll) {
      return domIsReady();
    } else {
      // Use the handy event callback
      document.addEventListener('DOMContentLoaded', domIsReady);
      // A fallback to $window.onload, that will always work
      $window.addEventListener('load', domIsReady);
    }
    return;
  };

  /**
   * When ready trigger the initialization
   * @private
   */
  function domIsReady() {
    document.removeEventListener('DOMContentLoaded', domIsReady);
    $window.removeEventListener('load', domIsReady);
    _init();
    return;
  }

  /**
   * @memberof Adaptive
   * @inner
   * For use with Vue
   * @param {Vue} Vue Vue instance
   * @param {Boolean} hybrid Allow support when using static and dynamic
   * @return {Vue}
   */
  $this.useVue = function (Vue) {
    var hybrid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (hybrid) {
      isHybrid = true;
    }
    if (_typeof(Vue) === 'object' && typeof Vue.mixin === 'function') {
      useVue = true;
      var installer = {
        install: function install(app) {
          // For Options API
          app.config.globalProperties.Adaptive = Adaptive;
          // For composition API
          app.provide('Adaptive', Adaptive);
        }
      };

      /**
       * Adaptive used as vue.$Adaptive
       * @private
       */
      Vue.use(installer);
      /**
       * Adaptive used as v-adaptive
       * @private
       */
      Vue.directive('adaptive', {
        mounted: function mounted(element, binding) {
          Adaptive.registerElement(element, binding.value);
        }
      });

      /**
       * Adaptive used as v-teleport-to
       * @private
       */
      Vue.directive('teleport-to', {
        mounted: function mounted(element, binding) {
          return new _Teleport_js__WEBPACK_IMPORTED_MODULE_2__.Teleport(element).beam(binding.value);
        }
      });
      Vue.component('TeleportTo', _vue_components_TeleportTo_js__WEBPACK_IMPORTED_MODULE_4__["default"]);

      /**
       * Adaptive used for non Vue elements register with data-adaptive attr
       * Hybrid mode
       * @private
       */
      Vue.mixin({
        mounted: function mounted() {
          return Adaptive.init();
        }
      });
    }
    return Vue;
  };

  //docs
  /**
   * For use with Web Components
   * @private
   * @return {Void}
   */
  $this.useWebComponent = function () {
    if (!useWeb && !useVue) {
      (0,_web_components_TeleportTo_js__WEBPACK_IMPORTED_MODULE_5__["default"])();
      useWeb = true;
    }
  };

  /**
   * @memberof Adaptive
   * @inner
   * For use with React
   * @param {React} React React instance
   * @param {Boolean} hybrid Allow support when using static and dynamic
   * @return {Void}
   */
  $this.useReact = function (React) {
    var hybrid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (hybrid) {
      isHybrid = true;
    }
    if (_typeof(React) === 'object') {
      $this.useWebComponent();
      useReact = true;
    }
  };
  $window.$adaptive = Adaptive;
  return $window.$adaptive;
}();


/***/ }),

/***/ "./src/QueryHandler.js":
/*!*****************************!*\
  !*** ./src/QueryHandler.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   QueryHandler: () => (/* binding */ QH),
/* harmony export */   "default": () => (/* binding */ QH),
/* harmony export */   queryHandler: () => (/* binding */ QH)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _readOnlyError(name) { throw new TypeError("\"" + name + "\" is read-only"); }
// Author Knighttower
// MIT License
// Copyright (c) [2022] [Knighttower] https://github.com/knighttower

/**
 * @class CSS Query Handler
 * @return QueryHandler
 */
var QH = function QueryHandler() {
  'use strict';
  var $window = typeof window !== 'undefined' ? window : {};
  /**
   * Query Handler Class Object
   * @private
   * @return {Object}
   */
  var $this = {};
  var QueryHandler = new Proxy($this, {
    get: function get(target, prop) {
      if (prop in target) {
        return target[prop];
      }
    }
  });

  /**
   * Holds memory of registered queries expressions
   * @private
   */
  var registeredQueries = {};

  /**
   * Holds memory of registered queries to match
   * @private
   */
  var domQueriesMatch = {};

  /**
   * Holds memory of registered queries to Unmatch
   * @private
   */
  var domQueriesUnMatch = {};

  /**
   * Flag
   * @private
   */
  var loaded = false;

  // =========================================
  // --> PUBLIC
  // --------------------------

  /**
   * Register a query
   * @param {Object} queries Media queries with breakdowns and directives
   * @param {Function} matchCallback Callback
   * @param {Function|Null} unMatchCallback Callback
   * @param {Object|Null} Adaptive When in use with Adaptive.js object
   * @return {Void}
   */
  $this.add = function (queries, matchCallback) {
    var unMatchCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var Adaptive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    for (var query in queries) {
      var _getPreset;
      // Values are the classes, styles, functions
      var values = queries[query];

      // Set a preset if found or just the query in case is custom
      var queryExpression = (_getPreset = getPreset(query, Adaptive)) !== null && _getPreset !== void 0 ? _getPreset : query;

      // If it does not exists, add it as an array
      if (!domQueriesMatch[queryExpression]) {
        domQueriesMatch[queryExpression] = [];
        domQueriesUnMatch[queryExpression] = [];
      }
      domQueriesMatch[queryExpression].push([matchCallback, values]);
      if (unMatchCallback) {
        domQueriesUnMatch[queryExpression].push([unMatchCallback, values]);
      }
      registerQueryListener(queryExpression);
    }
  };

  /**
   * Remove items from domQueriesMatch based on value and prop.
   *
   * @param {any} value - The value to be removed.
   * @param {string} prop - The property to look up in the object.
   */
  $this.remove = function (value, prop) {
    for (var _i = 0, _Object$entries = Object.entries(domQueriesMatch); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
        expression = _Object$entries$_i[0],
        collection = _Object$entries$_i[1];
      var _iterator = _createForOfIteratorHelper(collection),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var reg = _step.value;
          var type = _typeof(reg[1]);
          // LookUp by the prop value when the second array element is an object
          if (prop && type === 'object') {
            if (prop in reg[1] && reg[1][prop] === value) {
              console.log(domQueriesMatch[expression]);
              domQueriesMatch[expression] = domQueriesMatch[expression].filter(function (o) {
                return o[1][prop] !== value;
              });
            }
            // LookUp by the value (function) and prop when the second array element is a string
          } else if (type === 'string' && reg[1] === prop) {
            domQueriesMatch[expression] = domQueriesMatch[expression].filter(function (o) {
              return o[0] !== value;
            });
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  };

  /**
   * Initialization of the class functionality
   * @return {Void}
   */
  $this.init = function () {
    loaded = true;
    Object.keys(domQueriesMatch).forEach(function (queryExpression) {
      // Listener for after initial load
      registerQueryListener(queryExpression);
      // Run the queries on load once
      singleRun(queryExpression);
    });
  };

  /**
   * Reset the whole object | warning
   * @return {Void}
   */
  $this.reset = function () {
    Object.keys(registeredQueries).forEach(function (queryExpression) {
      $window.matchMedia(queryExpression).removeEventListener('change', registeredQueries[queryExpression]);
      delete registeredQueries[queryExpression];
    });
    Object.keys(domQueriesMatch).forEach(function (key) {
      return delete domQueriesMatch[key];
    });
    Object.keys(domQueriesUnMatch).forEach(function (key) {
      return delete domQueriesUnMatch[key];
    });
  };

  // =========================================
  // --> PRIVATE
  // --------------------------

  function singleRun(queryExpression) {
    var mq = $window.matchMedia(queryExpression);
    if (mq.matches) {
      domQueriesMatch[mq.media].forEach(function (callback) {
        return callback[0](callback[1]);
      });
    }
  }

  /**
   * Get the preset query values present in Adaptive object
   * @private
   */
  function getPreset(queryId) {
    var Adaptive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var presets = {
      q: null,
      // query min-max values preset
      e: null // custom expression preset
    };

    // -----------------------------------------
    // when working with Adaptive.Js
    if (Adaptive) {
      var _presetQs$queryId, _presetEs$queryId;
      var presetQs = Adaptive.getMinMaxQueries();
      var presetEs = Adaptive.getExpQueries();
      presets.q = (_presetQs$queryId = presetQs[queryId]) !== null && _presetQs$queryId !== void 0 ? _presetQs$queryId : null;
      presets.e = (_presetEs$queryId = presetEs[queryId]) !== null && _presetEs$queryId !== void 0 ? _presetEs$queryId : null;
      if (!presets.q && !presets.e) {
        if (queryId.includes('|')) {
          var qs = queryId.split('|');
          var qs1 = qs[0];
          var qs2 = qs[1];
          if (presetQs[qs1] && presetQs[qs2]) {
            return buildExpression(presetQs[qs1], presetQs[qs2], true);
          }
          if (presetEs[qs1] && presetEs[qs2]) {
            return buildExpression(presetEs[qs1], presetEs[qs2], true, true);
          }
        }
      } else {
        // Write the correct expression for the preset min-max
        if (presets.q) {
          return buildExpression(presets.q[0], presets.q[1]);
        }
        // No need to build the expression as it already is
        if (presets.e) {
          return presets.e;
        }
      }
    }
    return null;
  }

  /**
   * @private
   */
  function buildExpression(q1, q2) {
    var isCompound = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var isExpression = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var templateQuery = '(min-width: $1px) and (max-width: $2px)';
    if (isCompound) {
      if (!isExpression) {
        q1 = templateQuery.replace('$1', q1[0]).replace('$2', q1[1]);
        q2 = templateQuery.replace('$1', q2[0]).replace('$2', q2[1]);
      }
      return "".concat(q1, ", ").concat(q2);
    }
    return templateQuery.replace('$1', q1).replace('$2', q2);
  }
  function registerQueryListener(queryExpression) {
    // If not already registered
    // This helps to avoid too many Listeners created
    if (!registeredQueries[queryExpression]) {
      var matchQuery = $window.matchMedia(queryExpression);
      var callback = function callback(mq) {
        if (!mq.matches) {
          domQueriesUnMatch[mq.media].forEach(function (callback) {
            return callback[0](callback[1]);
          });
        } else {
          domQueriesMatch[mq.media].forEach(function (callback) {
            return callback[0](callback[1]);
          });
        }
      };
      registeredQueries[queryExpression] = callback;
      return matchQuery.addEventListener('change', callback);
    }
    // For those added after the loaded event
    if (loaded) {
      singleRun(queryExpression);
    }
  }
  $window.QueryHandler = QueryHandler;
  return $window.QueryHandler;
}();


/***/ }),

/***/ "./src/Teleport.js":
/*!*************************!*\
  !*** ./src/Teleport.js ***!
  \*************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Teleport: () => (/* binding */ Teleport),
/* harmony export */   TeleportGlobal: () => (/* binding */ TeleportGlobal),
/* harmony export */   "default": () => (/* binding */ Teleport),
/* harmony export */   teleport: () => (/* binding */ Teleport)
/* harmony export */ });
/* harmony import */ var knighttower_utility__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! knighttower/utility */ "./node_modules/knighttower/packages/utility/index.js");
/* harmony import */ var knighttower_type_check__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! knighttower/type-check */ "./node_modules/knighttower/packages/type-check/index.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// author Knighttower
//  MIT License
//  Copyright (c) [2022] [Knighttower] https://github.com/knighttower



/**
 * @module Teleport
 * Teleport an element to another place in the DOM before, inside or after a target
 * @param {Object|String} props || selector - props object (domElement: element, adaptiveId: null|uniqueId})
 * @example new Teleport({domElement: element, adaptiveId: uniqueId}).beam({to: selector})
 * @example new Teleport(domElement).beam({after: selector})
 * @example new Teleport(domElement).beam({before: selector})
 * @example new Teleport(domElement).beam(selector) // defaults to "to" which is inside the selector
 * @example const eleTeleport = new Teleport(domElement) // returns the object with eleTeleport{beam(String|Object), back(), cancel()}
 * @example Make it global so that is available in the browser and works as a 'window' library
 *   TeleportGlobal()
 *      - <div data-teleport="selector"></div>
 *      - <div data-teleport="{before: 'selector'}"></div>
 *     - <div data-teleport="{after: 'selector'}"></div>
 * @feature If the target (element where it will be sent to) is not in the DOM it will wait until it is and then it will beam the element
 * @return {Object} Teleport object
 */
var Teleport = /*#__PURE__*/function () {
  /**
   * Constructor
   * @param {String|Object} selector || props object (see AdaptiveElement)
   * @return {Object}
   */
  function Teleport(props) {
    _classCallCheck(this, Teleport);
    // Early exit if no props are provided
    if (!(0,knighttower_type_check__WEBPACK_IMPORTED_MODULE_1__.validType)(props, 'string|object')) {
      return;
    }
    this.props = props;
    if (!this.props.adaptiveId) {
      var _element$getAttribute;
      var element = (0,knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.selectElement)(this.props);
      var attrId = (_element$getAttribute = element.getAttribute('data-adaptive-id')) !== null && _element$getAttribute !== void 0 ? _element$getAttribute : null;
      // If adaptiveId is not present, create or retrieve it
      var uniqueId = attrId || element.getHash();
      if (!attrId) {
        element.domElement.setAttribute('data-adaptive-id', uniqueId);
      }

      // Update props with additional properties
      this.props = Object.assign({}, this.props, {
        adaptiveId: uniqueId,
        helper: element,
        domElement: element.domElement,
        xpath: element.getXpathTo()
      });
    }
    var placeholder = (0,knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.selectElement)("[name=\"adaptive\"][value=\"".concat(this.props.adaptiveId, "\""));
    if (!placeholder.isInDom()) {
      placeholder = document.createElement('param');
      placeholder.name = 'adaptive';
      placeholder.value = this.props.adaptiveId;
      this.props.domElement.insertAdjacentElement('beforebegin', placeholder);
    }
  }

  /**
   * Beam the element to another place in the DOM
   * This method will look for the "tagert" element if it is in the DOM and it will querying the DOM until it finds it
   * if the target is not found call the cancel() method to stop the observer
   * @param {String|Object} target (selector) directive defaults to "to" || {to|after|before: target}
   * @example new Teleport(domElement).beam({after: selector})
   * @example domElement.beam({after: selector})
   */
  _createClass(Teleport, [{
    key: "beam",
    value: function beam(settings) {
      var _this = this;
      settings = (0,knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.getDirectivesFromString)(settings).directive;

      // Transform settings to an array format
      switch ((0,knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.typeOf)(settings)) {
        case 'string':
          settings = ['default', settings];
          break;
        case 'object':
          // eslint-disable-next-line no-case-declarations
          var key = Object.keys(settings)[0];
          settings = [key, settings[key]];
          break;
        case 'array':
          if (settings.length === 1) {
            settings = ['default', settings[0]];
          }
          break;
      }
      var _settings = settings,
        _settings2 = _slicedToArray(_settings, 2),
        direction = _settings2[0],
        selector = _settings2[1];
      var target = (0,knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.selectElement)(selector);
      var position = 'beforeend';
      switch (direction) {
        case 'before':
          position = 'beforebegin';
          break;
        case 'after':
          position = 'afterend';
          break;
      }
      if (target.isInDom()) {
        target.domElement.insertAdjacentElement(position, this.props.domElement);
        return;
      }

      // Add observer if the target is not in the DOM
      knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.DomObserver.addOnNodeChange(this.props.adaptiveId, function () {
        var observedTarget = (0,knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.selectElement)(selector);
        if (observedTarget.isInDom()) {
          observedTarget.domElement.insertAdjacentElement(position, _this.props.domElement);
          knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.DomObserver.removeOnNodeChange(_this.props.adaptiveId);
        }
      });
    }

    /**
     * Return to its original place
     * @example new Teleport(domElement).back()
     * @example domElement.back()
     */
  }, {
    key: "back",
    value: function back() {
      var target = (0,knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.selectElement)("[name=\"adaptive\"][value=\"".concat(this.props.adaptiveId, "\""));
      if (target.isInDom()) {
        target.domElement.insertAdjacentElement('afterend', this.props.domElement);
        // target.domElement.remove();
      }
    }

    /**
     * If element target is no it the DOM and needs to cancel the observer
     * @example new Teleport(domElement).cancel()
     * @example domElement.cancel()
     */
  }, {
    key: "cancel",
    value: function cancel() {
      knighttower_utility__WEBPACK_IMPORTED_MODULE_0__.DomObserver.removeOnNodeChange(this.props.adaptiveId);
    }
  }]);
  return Teleport;
}(); // Storage
var TeleportIsGlobal = false;

/**
 * Warning, this will make it global and would work with data attr like data-teleport
 * @example new Teleport().global()
 */
function TeleportGlobal() {
  // Exit if already initialized
  if (TeleportIsGlobal) {
    return;
  }

  // Use forEach directly on NodeList
  document.querySelectorAll('[data-teleport]').forEach(function (element) {
    new Teleport(element).beam(element.getAttribute('data-teleport'));
  });

  // Mark as initialized
  TeleportIsGlobal = true;
}


/***/ }),

/***/ "./src/classes/AdaptiveElement.js":
/*!****************************************!*\
  !*** ./src/classes/AdaptiveElement.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AdaptiveElement)
/* harmony export */ });
/* harmony import */ var _Teleport_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Teleport.js */ "./src/Teleport.js");
/* harmony import */ var _QueryHandler_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../QueryHandler.js */ "./src/QueryHandler.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// Author Knighttower
//  MIT License
//  Copyright (c) [2022] [Knighttower] https://github.com/knighttower


// when it imports, it also registers itself as global


/**
 * @class Adds some extra functionality to interact with a DOM element
 * @param {Object} props
 * @param {Object} Adaptive Instance of
 * @return {Object}
 */
var AdaptiveElement = /*#__PURE__*/function () {
  /**
   * Constructor
   * @param {String|Object} selector
   * @return {Object}
   */
  function AdaptiveElement(props, Adaptive) {
    var _this = this;
    _classCallCheck(this, AdaptiveElement);
    _defineProperty(this, "_addClass", function ($classes) {
      $classes = $classes.split(' ');
      $classes.forEach(function ($class) {
        _this.props.domElement.classList.add($class);
      });
      return;
    });
    _defineProperty(this, "_removeClass", function ($classes) {
      $classes = $classes.split(' ');
      $classes.forEach(function ($class) {
        _this.props.domElement.classList.remove($class);
      });
      return;
    });
    this.props = props;
    this.Adaptive = Adaptive;
    for (var directive in props.settings) {
      // Matches the method name and passes the directives
      this[directive](props.settings[directive]);
    }
  }
  _createClass(AdaptiveElement, [{
    key: "addClass",
    value: function addClass(queries) {
      return _QueryHandler_js__WEBPACK_IMPORTED_MODULE_1__["default"].add(queries, this._addClass, this._removeClass, this.Adaptive);
    }
  }, {
    key: "removeClass",
    value: function removeClass(queries) {
      return _QueryHandler_js__WEBPACK_IMPORTED_MODULE_1__["default"].add(queries, this._removeClass, this._addClass, this.Adaptive);
    }
  }, {
    key: "addStyle",
    value: function addStyle(queries) {
      var _this2 = this;
      // Save the original style in memory to not discard them
      this.props.originalStyle = this.props.domElement.getAttribute('style');
      return _QueryHandler_js__WEBPACK_IMPORTED_MODULE_1__["default"].add(queries, function ($styles) {
        // eslint-disable-next-line no-return-assign
        return _this2.props.domElement.style.cssText += $styles;
      }, function () {
        // eslint-disable-next-line no-return-assign
        return _this2.props.domElement.style.cssText = _this2.props.originalStyle;
      }, this.Adaptive);
    }
  }, {
    key: "teleport",
    value: function teleport(queries) {
      var $element = new _Teleport_js__WEBPACK_IMPORTED_MODULE_0__["default"](this.props);
      return _QueryHandler_js__WEBPACK_IMPORTED_MODULE_1__["default"].add(queries, function ($directive) {
        return $element.beam($directive);
      }, function () {
        $element.back();
        return $element.cancel();
      }, this.Adaptive);
    }
  }, {
    key: "execute",
    value: function execute(queries) {
      var $element = this;
      var attrs = {
        adaptiveId: $element.props.uniqueId,
        helper: $element.props.helper,
        domElement: $element.props.domElement,
        xpath: $element.props.xpath
      };
      return _QueryHandler_js__WEBPACK_IMPORTED_MODULE_1__["default"].add(queries, function ($callback) {
        if ($callback && typeof $callback === 'function') {
          return $callback(attrs);
        }
      }, function ($callback) {
        if ($callback && typeof $callback === 'function') {
          return $callback(attrs);
        }
      }, this.Adaptive);
    }
  }]);
  return AdaptiveElement;
}();


/***/ }),

/***/ "./src/vue-components/TeleportTo.js":
/*!******************************************!*\
  !*** ./src/vue-components/TeleportTo.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Adaptive Teleport
 * @module
 * @example <teleport-to target="" position=""></teleport-to>
 * @property {String|Object} target
 * @property {String} target
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'TeleportTo',
  inheritAttrs: false,
  props: {
    target: {
      type: [String, Object],
      require: true
    },
    position: {
      type: String,
      "default": 'to',
      require: false
    }
  },
  setup: function setup(props) {
    var directive = "".concat(props.position, "(").concat(props.target, ")");
    return {
      directive: directive
    };
  },
  template: "\n        <div>\n            <div v-teleport-to=\"directive\">\n                <slot></slot>\n            </div>\n        </div>\n    "
});

/***/ }),

/***/ "./src/web-components/TeleportTo.js":
/*!******************************************!*\
  !*** ./src/web-components/TeleportTo.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ componentTeleportTo)
/* harmony export */ });
/* harmony import */ var _Teleport_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Teleport.js */ "./src/Teleport.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _isNativeFunction(fn) { try { return Function.toString.call(fn).indexOf("[native code]") !== -1; } catch (e) { return typeof fn === "function"; } }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var TeleportTo = /*#__PURE__*/function (_HTMLElement) {
  _inherits(TeleportTo, _HTMLElement);
  var _super = _createSuper(TeleportTo);
  function TeleportTo() {
    _classCallCheck(this, TeleportTo);
    return _super.call(this);
  }
  _createClass(TeleportTo, [{
    key: "connectedCallback",
    value: function connectedCallback() {
      var _this$getAttribute;
      var target = this.getAttribute('target');
      var position = (_this$getAttribute = this.getAttribute('position')) !== null && _this$getAttribute !== void 0 ? _this$getAttribute : 'to';
      var dId = this.getAttribute('data-adaptive-id');
      if (target && !dId) {
        return new _Teleport_js__WEBPACK_IMPORTED_MODULE_0__["default"](this).beam("".concat(position, "(").concat(target, ")"));
      }
    }
  }]);
  return TeleportTo;
}( /*#__PURE__*/_wrapNativeSuper(HTMLElement));
function componentTeleportTo() {
  customElements.define('teleport-to', TeleportTo);
}

/***/ }),

/***/ "./node_modules/knighttower/packages/type-check/dist/esm/TypeCheck.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/knighttower/packages/type-check/dist/esm/TypeCheck.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TypeCheck: () => (/* binding */ typeCheck),
/* harmony export */   _tc: () => (/* binding */ _tc),
/* harmony export */   _tcx: () => (/* binding */ _tcx),
/* harmony export */   _typeCheck: () => (/* binding */ _typeCheck),
/* harmony export */   addTypeTest: () => (/* binding */ addTypeTest),
/* harmony export */   "default": () => (/* binding */ typeCheck),
/* harmony export */   testBuilder: () => (/* binding */ testBuilder),
/* harmony export */   typeCheck: () => (/* binding */ typeCheck),
/* harmony export */   typesMap: () => (/* binding */ typesMap),
/* harmony export */   validType: () => (/* binding */ validType)
/* harmony export */ });
// Author Knighttower
// MIT License
// [2022] [Knighttower] https://github.com/knighttower
/**
 * @module DomObserver
 * Detect DOM changes
 * @name DomObserver
 * @param {window} selector
 * @param {Function}
 * @return DomObserver
 * @example DomObserver.addOnNodeChange('elementIdentifier', () => { console.log('Node changed') })
 * @example DomObserver.removeOnNodeChange('elementIdentifier')
 */
/**
 * Holds memory of registered functions
 * @private
 */
const executeOnNodeChanged$1 = {};
/**
 * Observer
 * @private
 * @return {MutationObserver}
 */
(() => {
    if (typeof window !== 'undefined') {
        const callback = (mutationList) => {
            for (const mutation of mutationList) {
                if (mutation.type === 'childList') {
                    for (const id in executeOnNodeChanged$1) {
                        executeOnNodeChanged$1[id]();
                    }
                }
            }
        };
        const config = {
            childList: true,
            subtree: true,
        };
        const observer = new MutationObserver(callback);
        observer.observe(document.body, config);
    }
})();

// Author Knighttower
// MIT License
// [2022] [Knighttower] https://github.com/knighttower
/**
 * @module DomObserver
 * Detect DOM changes
 * @name DomObserver
 * @param {window} selector
 * @param {Function}
 * @return DomObserver
 * @example DomObserver.addOnNodeChange('elementIdentifier', () => { console.log('Node changed') })
 * @example DomObserver.removeOnNodeChange('elementIdentifier')
 */
/**
 * Holds memory of registered functions
 * @private
 */
const executeOnNodeChanged = {};
/**
 * Observer
 * @private
 * @return {MutationObserver}
 */
(() => {
    if (typeof window !== 'undefined') {
        const callback = (mutationList) => {
            for (const mutation of mutationList) {
                if (mutation.type === 'childList') {
                    for (const id in executeOnNodeChanged) {
                        executeOnNodeChanged[id]();
                    }
                }
            }
        };
        const config = {
            childList: true,
            subtree: true,
        };
        const observer = new MutationObserver(callback);
        observer.observe(document.body, config);
    }
})();

// // -----------------------------------------
// /**
//  * @knighttower
//  * @url knighttower.io
//  * @git https://github.com/knighttower/
//  */
// // -----------------------------------------


/**
 * Converts a given variable to a number if possible.
 * @param {string|number} input - The input variable to convert.
 * @returns {string|number} - The converted number or the original variable.
 * @example convertToNumber(123) // Output: 123 (number)
 * @example convertToNumber(123.45) // Output: 123.45 (number)
 * @example convertToNumber("123") // Output: 123 (number)
 * @example convertToNumber("123.45") // Output: 123.45 (number)
 * @example convertToNumber("abc") // Output: "abc" (original string)
 * @example convertToNumber("123abc") // Output: "123abc" (original string)
 * @example convertToNumber(null) // Output: null (original)
 */
function convertToNumber(input) {
    const isNum = isNumber(input);

    if (isNum !== null) {
        return isNum;
    }
    // Case: String that cannot be converted to a number
    return input;
}

/**
 * Check if there is a value, if not return null or the default value
 * It can test strings, arrays, objects, numbers, booleans
 * @function emptyOrValue
 * @memberof Utility
 * @param {String|Number} value If the value is not empty, returns it
 * @param {String|Number} _default The default value if empty
 * @return mixed
 * @example emptyOrValue('test', 'default') // 'test'
 * @example emptyOrValue('', 'default') // 'default'
 * @example emptyOrValue('test') // 'test'
 * @example emptyOrValue('') // null
 * @example emptyOrValue(0) // 0
 * @example var hello = ''; emptyOrValue(hello) // Null
 * @example var hello = 'test'; emptyOrValue(hello) // 'test'
 * @example var hello = 'test'; emptyOrValue(hello, 'default') // 'test'
 * @example var hello = ''; emptyOrValue(hello, 'default') // 'default'
 * @example var hello = []; emptyOrValue(hello, 'default') // null
 * @example var hello = {}; emptyOrValue(hello, 'default') // null
 * @example var hello = [...]; emptyOrValue(hello') // [...]
 */
function emptyOrValue(value, _default = null) {
    /**
     * Test sequence:
     * If it is a number 0> : true
     * If is not undefined: true
     * If it is boolean (true|false) prevents going to empty
     * If it is not Empty, [], null, {}, 0, true, false: true
     */

    if (isNumber(value) !== null || typeof value === 'boolean') {
        return value;
    } else if (!isEmpty$1(value)) {
        return value;
    }

    return _default;
}

/**
 * Generate unique ids
 * @function getDynamicId
 * @memberof Utility
 * @return string Format kn__000000__000
 */
function getDynamicId() {
    return 'kn__' + new Date().getTime() + '__' + Math.floor(Math.random() * (999 - 100));
}

/**
 * Alias to getDynamicId
 * @function getRandomId
 * @memberof Utility
 * @return string
 * @example getRandomId() // kn__000000__000
 */
const getRandomId = getDynamicId;

/**
 * Check if a value is empty
 * @function isEmpty
 * @memberof Utility
 * @param {string|array|object|map|set|number|boolean} value
 * @url https://moderndash.io/
 * @return {string}
 */
function isEmpty$1(value) {
    if (value === null || value === undefined) {
        return true;
    }

    if (typeof value === 'string' || Array.isArray(value)) {
        return value.length === 0;
    }

    if (value instanceof Map || value instanceof Set) {
        return value.size === 0;
    }

    if (ArrayBuffer.isView(value)) {
        return value.byteLength === 0;
    }

    if (typeof value === 'object') {
        return Object.keys(value).length === 0;
    }

    return false;
}

/**
 * Check if is a number or Int, if not return null
 * Integrates both Int and Number, or convert a string number to number to test
 * Note: this is not like Lodash isNumber since this one takes into consideration the 'string number'
 * @function isNumber
 * @memberof Utility
 * @param {String|Number} value
 * @return null|int
 * @example isNumber(123) // true
 * @example isNumber(123.45) // true
 * @example isNumber('123abc') // false
 * @example isNumber('abc') // false
 * @example isNumber('') // false
 * @example isNumber("123") // true
 * @example isNumber("123.45") // true
 */
function isNumber(value) {
    const isType = typeof value;
    switch (value) {
        case null:
        case undefined:
        case '':
            return null;
        case '0':
        case 0:
            return 0;
        default:
            if (isType === 'number' || isType === 'string') {
                if (typeof value === 'number' || !Number.isNaN(Number(value))) {
                    return +value;
                }
            }

            break;
    }

    return null;
}

/**
 * Check the type of a variable, and get the correct type for it. It also accepts simple comparisons
 * For more advance type checking see https://github.com/knighttower/JsTypeCheck
 * @param {any} input - The variable to check
 * @param {string} test - The types to check against, piped string
 * @return {string|boolean} - The type of the variable
 * @example typeOf('hello', 'string') // returns true
 * @example typeOf('hello', 'number') // returns false
 * @example typeOf('hello', 'string') // returns true
 * @example typeOf('hello') // returns 'string'
 * @example typeOf({}) // returns 'object'
 */
function typeOf$1(input, test) {
    // Special case for null since it can be treated as an object
    if (input === null) {
        if (test) {
            return test === null || test === 'null' ? true : false;
        }
        return 'null';
    }

    let inputType;

    switch (typeof input) {
        case 'number':
        case 'string':
        case 'boolean':
        case 'undefined':
        case 'bigint':
        case 'symbol':
        case 'function':
            inputType = typeof input;
            break;
        case 'object':
            inputType = Array.isArray(input) ? 'array' : 'object';

            break;
        default:
            inputType = 'unknown';
    }

    if (test) {
        if (test.includes('|')) {
            for (let type of test.split('|')) {
                if (inputType === type) {
                    return type;
                }
            }
            return false;
        }

        return test === inputType;
    }

    return inputType;
}

// Author Knighttower
// MIT License
// Copyright (c) [2022] [Knighttower] https://github.com/knighttower


// @private
function _removeBrackets(strExp) {
    const regex = /^(\[|\{)(.*?)(\]|\})$/; // Match brackets at start and end
    const match = strExp.match(regex);

    if (match) {
        return match[2].trim(); // Extract and trim the content between brackets
    }

    return strExp; // Return the original string if no brackets found at start and end
}

/**
 * Clean a string from delimeters or just trimmed if no delimeters given
 * @funtion cleanStr
 * @param {String} str - String to use
 * @param {String|Regex} p1 - Delimeter 1
 * @param {String|Regex} p2 - Delimeter 2
 * @return {String|void}
 * @example cleanStr('hello world', 'h', 'd') // 'ello worl'
 * @example cleanStr('  hello world  ') // 'hello world'
 * @example cleanStr('hello world', 'hello') // 'world'
 * @example cleanStr('Hello World. Sunshine is here!', '\..*!') // Hello World
 * @example cleanStr('Hello World. Sunshine is here!', /Hello/g) // ' World. Sunshine is here!'
 * @example cleanStr('Hello World. Sunshine is here!', /Hello/g, /Sunshine/g) // ' World.  is here!'
 */
function cleanStr(str, ...args) {
    if (!str) {
        return;
    }
    if (typeof str !== 'string') {
        return str;
    }

    return args
        .reduce((accStr, arg) => {
            const regex = arg instanceof RegExp ? arg : new RegExp(setExpString(arg));
            return accStr.replace(regex, '');
        }, str)
        .trim();
}

/**
 * Find the last instance of nested pattern with delimeters
 * @function findNested
 * @param {string} str
 * @param {string} start - Delimeter 1
 * @param {string} end - Delimeter 2
 * @return {string|null}
 * @example findNested('[[]hello [world]]', '[', ']') // [world]
 */
function findNested(str, start = '[', end = ']') {
    if (typeof str !== 'string') {
        return str;
    }
    // Find the last index of '['
    const lastIndex = str.lastIndexOf(start);
    // If '[' is not found, return null or some default value
    if (lastIndex === -1) {
        return null;
    }

    // Extract the substring starting from the last '[' to the end
    const substring = str.substring(lastIndex);
    // Find the index of the first ']' in the substring
    const endIndex = substring.indexOf(end);
    // If ']' is not found, return null or some default value
    if (endIndex === -1) {
        return null;
    }
    // Extract and return the content between the last '[' and the next ']', including them
    return substring.substring(0, endIndex + 1);
}

/**
 * Converts strings formats into objects or arrays
 * Note: quoted strings are not supported, use getDirectiveFromString instead
 * @param {string} strExp
 * @return {object|array|string}
 * @example getArrObjFromString('[[value,value],value]') // [['value', 'value'], 'value']
 * @example getArrObjFromString('[[value,value],value, { y: hello }, hello]') // [['value', 'value'], 'value', { y: 'hello' }, 'hello']
 * @example getArrObjFromString('{ y: hello, x: world, z: [value,value]}') // { y: 'hello', x: 'world', z: ['value', 'value'] }
 */
function getArrObjFromString(strExp) {
    // alredy typeof object or array just return it
    if (typeOf$1(strExp, 'object') || typeOf$1(strExp, 'array')) {
        return strExp;
    }
    const isObject = startAndEndWith(strExp, '{', '}');
    const isArray = startAndEndWith(strExp, '[', ']');
    // If it is other type of string, return it
    if (!isObject && !isArray) {
        return strExp;
    }

    const newCollection = isObject ? {} : [];
    const nestedElements = {};

    //remove the brackets
    let newStrExp = _removeBrackets(strExp);

    const loopNested = (objects = false) => {
        // ignore eslint comment
        // eslint-disable-next-line no-constant-condition
        while (true) {
            //find any nested arrays or objects
            let matched = objects ? findNested(newStrExp, '{', '}') : findNested(newStrExp);

            if (!matched) {
                break;
            }

            //replace the nested array or object with a marker so that we can safely split the string
            let marker = `__${getRandomId()}__`;
            nestedElements[marker] = matched;

            newStrExp = newStrExp.replace(matched, marker);
        }
    };

    loopNested();
    loopNested(true);

    getChunks(newStrExp).forEach((chunk, index) => {
        const isObjectKey = chunk.includes(':') && isObject;
        const chunkParts = isObjectKey ? getChunks(chunk, ':') : [];
        const chunkKey = removeQuotes(emptyOrValue(chunkParts[0], index));
        chunk = isObjectKey ? chunkParts[1] : chunk;
        if (chunk in nestedElements) {
            chunk = getArrObjFromString(nestedElements[chunk]);
        }
        chunk = convertToNumber(removeQuotes(chunk));
        // set back in the collection either as an object or array
        isObject ? (newCollection[chunkKey] = chunk) : newCollection.push(chunk);
    });
    // uncomment to debug
    // console.log('___ log ___', newCollection);
    return newCollection;
}
/**
 * Splits a string into chunks by a given splitter and cleans the chunks
 * @param {string} str
 * @param {string} splitter - The string/character to split the string by. Defaults to ','
 * @return {string|array}
 */
function getChunks(str, splitter = ',') {
    if (typeof str !== 'string') {
        return str;
    }
    if (isEmpty$1(str)) {
        return [];
    }
    str = cleanStr(str);
    let chunks = str.split(splitter).map((t) => cleanStr(t));
    return chunks.length === 1 && chunks[0] === '' ? [str] : chunks;
}

/**
 * Remove quotes from a string
 * @function removeQuotes
 * @param {String} str
 * @return {String}
 * @example removeQuotes('"hello"') // hello
 * @example removeQuotes("'hello'") // hello
 */
function removeQuotes(str) {
    if (typeof str !== 'string') {
        return str;
    }
    return str.replace(/`|'|"/g, '');
}

/**
 * Checks if a string starts and ends with a given string
 * @param {string} strExp
 * @param {string} start - The string/character to check it starts with
 * @param {string} end - The string/character to check it ends with
 * @return {string}
 * @example startAndEndWith('hello world', 'h', 'd') // false
 * @example startAndEndWith('hello world', 'h', 'd') // true
 */
function startAndEndWith(strExp, start = null, end = null) {
    return (!start || strExp.startsWith(start)) && (!end || strExp.endsWith(end));
}

/**
 * Scapes a string to create a regex or returns the regex if it already is an expression
 * @function setExpString
 * @param {String|Regex} exp
 * @return {String|Regex}
 * @example setExpString('hello') // '\h\e\l\l\o'
 * @example setExpString(/hello/) // /hello/
 * @example setExpString([hello]) // \\[hello\\/ then use like new new RegExp(setExpString(StringOrRegex))
 */
function setExpString(exp) {
    if (exp instanceof RegExp) {
        return exp;
    } else {
        return exp
            .split('')
            .map((char) =>
                ['$', '^', '.', '*', '+', '?', '(', ')', '[', ']', '{', '}', '|', '\\'].includes(char)
                    ? `\\${char}`
                    : char
            )
            .join('');
    }
}

// // -----------------------------------------
// /**
//  * @knighttower
//  * @url knighttower.io
//  * @git https://github.com/knighttower/
//  */
// // -----------------------------------------


/**
 * Check if a value is empty
 * @function isEmpty
 * @memberof Utility
 * @param {string|array|object|map|set|number|boolean} value
 * @url https://moderndash.io/
 * @return {string}
 */
function isEmpty(value) {
    if (value === null || value === undefined) {
        return true;
    }

    if (typeof value === 'string' || Array.isArray(value)) {
        return value.length === 0;
    }

    if (value instanceof Map || value instanceof Set) {
        return value.size === 0;
    }

    if (ArrayBuffer.isView(value)) {
        return value.byteLength === 0;
    }

    if (typeof value === 'object') {
        return Object.keys(value).length === 0;
    }

    return false;
}

/**
 * Check the type of a variable, and get the correct type for it. It also accepts simple comparisons
 * For more advance type checking see https://github.com/knighttower/JsTypeCheck
 * @param {any} input - The variable to check
 * @param {string} test - The types to check against, piped string
 * @return {string|boolean} - The type of the variable
 * @example typeOf('hello', 'string') // returns true
 * @example typeOf('hello', 'number') // returns false
 * @example typeOf('hello', 'string') // returns true
 * @example typeOf('hello') // returns 'string'
 * @example typeOf({}) // returns 'object'
 */
function typeOf(input, test) {
    // Special case for null since it can be treated as an object
    if (input === null) {
        if (test) {
            return test === null || test === 'null' ? true : false;
        }
        return 'null';
    }

    let inputType;

    switch (typeof input) {
        case 'number':
        case 'string':
        case 'boolean':
        case 'undefined':
        case 'bigint':
        case 'symbol':
        case 'function':
            inputType = typeof input;
            break;
        case 'object':
            inputType = Array.isArray(input) ? 'array' : 'object';

            break;
        default:
            inputType = 'unknown';
    }

    if (test) {
        if (test.includes('|')) {
            for (let type of test.split('|')) {
                if (inputType === type) {
                    return type;
                }
            }
            return false;
        }

        return test === inputType;
    }

    return inputType;
}

// typeOf is used here insteand of the native typeof because it can handle better the identifications of arrays and objects

const typesMap = new Map([
    ['array', (_var_) => typeOf(_var_, 'array')],
    ['bigInt', (_var_) => typeof _var_ === 'bigint'],
    ['boolean', (_var_) => typeof _var_ === 'boolean'],
    ['date', (_var_) => _var_ instanceof Date],
    ['float', (_var_) => typeof _var_ === 'number' && !Number.isInteger(_var_)],
    ['function', (_var_) => typeof _var_ === 'function'],
    ['int', (_var_) => Number.isInteger(_var_)],
    ['map', (_var_) => _var_ instanceof Map],
    ['null', (_var_) => _var_ === null],
    ['number', (_var_) => typeof _var_ === 'number'],
    ['object', (_var_) => typeOf(_var_, 'object')],
    ['promise', (_var_) => _var_ instanceof Promise],
    ['regExp', (_var_) => _var_ instanceof RegExp],
    ['set', (_var_) => _var_ instanceof Set],
    ['string', (_var_) => typeof _var_ === 'string'],
    ['symbol', (_var_) => typeof _var_ === 'symbol'],
    ['undefined', (_var_) => typeof _var_ === 'undefined'],
    ['weakMap', (_var_) => _var_ instanceof WeakMap],
    ['weakSet', (_var_) => _var_ instanceof WeakSet],
]);

//  type definitions

// =========================================
// --> STORAGE
// --------------------------
// Cache storage for tests
const cachedTests = new Map();
const cachedPipedTypes = new Map();

// =========================================
// --> Utility functions
// --------------------------

/**
 * If the type is a union type, split it and return the tests for each type
 * @param {string} str
 * @return {array} tests
 */
function getPipedTypes(str) {
    if (cachedPipedTypes.has(str)) {
        return cachedPipedTypes.get(str);
    }
    return str.split('|').reduce((testsForKey, t) => {
        let itCanBeNull = false;
        let type = t.trim();

        if (type.endsWith('?')) {
            type = type.slice(0, -1);
            itCanBeNull = true;
        }
        // lookup the test for the type and add it to the testsForKey array
        const typeObj = typesMap.get(type);
        const test = typeObj ?? isNoType(type);
        if (test) {
            testsForKey.push(test);
        }
        // for optional types, add the tests for null and undefined
        if (itCanBeNull) {
            testsForKey.push(typesMap.get('null'), typesMap.get('undefined'));
        }
        cachedPipedTypes.set(str, testsForKey);
        return testsForKey;
    }, []);
}

/**
 * Get the tests for a type
 * @param {string} type
 * @return {function[]} tests
 * @throws {Error} if type is not supported
 */
function isNoType(type) {
    throw new Error(`Type Error: "${type}" is not supported`);
}

/**
 * Determine the type of the expression
 * @param {any} strExp
 * @return {string}
 */
function determineMethod(strExp) {
    if (typeOf(strExp, 'array') || typeOf(strExp, 'object')) {
        return typeOf(strExp);
    }
    const __str = strExp.trim();
    if (startAndEndWith(__str, '[', ']')) {
        return 'array';
    }
    if (startAndEndWith(__str, '{', '}')) {
        return 'object';
    }
    return 'basic';
}

// =========================================
// --> Handlers for different types
// --------------------------

/**
 * Basic single types
 * @param {string} typeStr
 * @return {object} tests
 */
const basicTypes = (typeStr) => {
    return getPipedTypes(typeStr);
};

/**
 * Handle array types
 * @param {string} strExp
 * @return {array} tests
 */
const arrayTypes = (strExp) => {
    const testUnit = [];
    const convertedObj = getArrObjFromString(strExp);

    convertedObj.forEach((test) => {
        testUnit.push(testBuilder(test));
    });
    return testUnit;
};

/**
 * Handle object types
 * @param {string} strExp
 * @return {object} tests
 */
const objectTypes = (strExp) => {
    return new (class handleObjects {
        constructor() {
            this.testUnit = new Map([
                ['tests', new Map()],
                ['optionalKeys', []],
                ['testFew', []],
                ['testAllAny', false],
                ['testOnly', false],
            ]);

            return this.handleObject();
        }

        checkOptionalKey(key) {
            if (key.endsWith('?')) {
                key = key.slice(0, -1);
                this.testUnit.get('optionalKeys').push(key);
            }
            return key;
        }

        checkTheAnyKey(obj) {
            if ('any' in obj) {
                const keys = Object.keys(obj);
                if (keys.length === 1) {
                    this.testUnit.set('testAllAny', true);
                } else {
                    this.testUnit.set(
                        'testFew',
                        keys.filter((key) => key !== 'any')
                    );
                }
            }
        }

        handleObject() {
            const convertedObj = getArrObjFromString(strExp);
            this.checkTheAnyKey(convertedObj);
            for (const key in convertedObj) {
                const cleanKey = this.checkOptionalKey(key);
                const value = convertedObj[key];

                if (value === '...') {
                    delete convertedObj[key];
                    this.testUnit.set('testOnly', true);
                    continue;
                }

                this.testUnit.get('tests').set(cleanKey, testBuilder(value));
            }

            return this.testUnit;
        }
    })();
};

/**
 * Build the test unit
 * @param {any} strExp String expression
 * @return {object} testUnit
 * @throws {Error} if type is not supported
 * @example testBuilder('number') // returns {testMethod: 'basic', tests: [function]}
 * @example testBuilder('[number]') // returns {testMethod: 'array', tests: [[function]]}
 * @example testBuilder('{any: number}') // returns {testMethod: 'object', tests: {any: [function]}}
 * @usage See more cases in the 'type-pattern.txt' file
 */
function testBuilder(strExp) {
    if (cachedTests.has(strExp)) {
        return cachedTests.get(strExp);
    }
    let testUnit = new Map([
        ['testMethod', determineMethod(strExp)],
        ['tests', null],
    ]);

    switch (testUnit.get('testMethod')) {
        case 'basic':
            testUnit.set('tests', basicTypes(strExp));
            break;
        case 'array':
            testUnit.set('tests', arrayTypes(strExp));
            break;
        case 'object':
            /* eslint-disable-next-line */
            const objTypes = objectTypes(strExp);
            testUnit = new Map([...testUnit, ...objTypes]);
            break;
        default:
            isNoType(strExp);
    }

    cachedTests.set(strExp, testUnit);
    return testUnit;
}

/**
 * Add a new type test
 * @param {string} name The name of the test to add
 * @param {function} testUnit The test function
 * @return {boolean} true if the test was added
 * @throws {Error} if the test already exists
 */
const addTypeTest = (name, testUnit) => {
    if (!typesMap.has(name)) {
        typesMap.set(name, testUnit);
        return true;
    }

    return `"${name}" already exists!`;
};

// Error collectot
const typeErrorLogs = [];
// Setting cache
const cachedSettings = new Map();

const runBasicTest = (inputVal, tests) => {
    return tests.some((test) => {
        const testResult = test(inputVal);

        if (!testResult) {
            pushToErrorLogs(inputVal, tests);
        }
        return testResult;
    });
};

const runArrayTest = (inputVal, tests) => {
    // If the input is not an array, return false
    if (!typeOf(inputVal, 'array') || inputVal.length === 0) {
        return false;
    }
    // Else, test each value in the array
    return tests.every((test, index) => {
        // console.log('is array: ', inputVal[index], test);
        return runRouteTest(inputVal[index], test);
    });
};

class HandleObjects {
    constructor(inputVal, unitTest) {
        // Extract all properties at once
        const { testOnly, testFew, testAllAny, optionalKeys, tests } = [...unitTest.entries()].reduce(
            (acc, [key, value]) => ({ ...acc, [key]: value }),
            {}
        );
        // Use destructured variables
        this.testUnitKeys = [...tests.keys()];
        this.testOnly = testOnly;
        this.testFew = testFew;
        this.testAllAny = testAllAny;
        this.optionalKeys = optionalKeys;
        this.testCollection = tests;
        // the input object to test
        this.inputObject = inputVal;
    }

    handleUnitTest() {
        switch (true) {
            case this.testAllAny:
                // '{any: type}' // any key
                return this.testObjAllAny();
            case !isEmpty(this.testFew):
                // '{key1: type, any: type}'; // specific key, and all other "any"
                // test the testFew fist so that we can remove them from the inputObject
                /* eslint-disable-next-line */
                const testFewResults = this.testObjFew();
                // remove the testFew from the inputObject
                this.filterOutFew();
                return testFewResults && this.testObjAllAny();
            case !isEmpty(this.optionalKeys):
                // '{key1?: type, key2?: type}'; // optional keys
                // test the optionalKeys fist so that we can remove them from the inputObject
                /* eslint-disable-next-line */
                const optionalKeysResults = this.testObjOptionalKeys();
                // remove the optionalKeys from the inputObject
                this.filterOutOptionalKeys();
                return optionalKeysResults && this.defaultTest();
            case !this.testOnly:
                // '{key1: type, key2: type}'; // all keys
                for (const k in this.inputObject) {
                    if (!this.testCollection.has(k)) {
                        pushToErrorLogs(
                            this.inputObject,
                            `Key: "${k}" not found in the test collection, or use the "any" (any:[type]) key test or "..." after the last key in the test collection {key1: type, key2: type, ...} to only test a few keys.`
                        );
                        return false;
                    }
                }
                // when testOnly, it will bypass this and check only those found in the test collection
                // even if the test value has more keys
                break;
        }

        return this.defaultTest();
    }

    filterOutOptionalKeys() {
        this.testUnitKeys = this.testUnitKeys.filter((item) => !this.optionalKeys.includes(item));
    }

    filterOutFew() {
        this.inputObject = Object.fromEntries(
            Object.entries(this.inputObject).filter(([key]) => !this.testFew.includes(key))
        );
    }

    testObjOptionalKeys() {
        return this.optionalKeys.every((key) => {
            const test = this.testCollection.get(key);
            const testValue = this.inputObject[key];
            return !testValue ? true : runRouteTest(testValue, test);
        });
    }

    testObjFew() {
        return this.testFew.every((key) => {
            const test = this.testCollection.get(key);
            const testValue = this.inputObject[key];

            return runRouteTest(testValue, test);
        });
    }

    testObjAllAny() {
        const testValues = Object.values(this.inputObject);
        if (testValues.length === 0) {
            return runRouteTest(null, this.testCollection.get('any'));
        }
        return testValues.every((value) => {
            return runRouteTest(value, this.testCollection.get('any'));
        });
    }

    defaultTest() {
        return this.testUnitKeys.every((key) => {
            const test = this.testCollection.get(key);
            const testValue = this.inputObject[key];
            return runRouteTest(testValue, test);
        });
    }
}

const runObjectTest = (inputVal, unitTest) => {
    if (!typeOf(inputVal, 'object')) {
        return false;
    }
    return new HandleObjects(inputVal, unitTest).handleUnitTest();
};

function runRouteTest(inputVal, unitTest) {
    const testMethod = unitTest.get('testMethod');
    const tests = unitTest.get('tests');

    switch (testMethod) {
        case 'basic':
            return runBasicTest(inputVal, tests);
        case 'array':
            return runArrayTest(inputVal, tests);
        case 'object':
            return runObjectTest(inputVal, unitTest); // No change here as the entire Map is passed
        default:
            return false;
    }
}

/**
 * Get settings either from an object or a string keyword.
 * @param {Object | string} input - The settings object or keyword for predefined settings.
 * @return {object | null} - The settings object.
 */
function getSettings(input) {
    if (input) {
        if (cachedSettings.has(input)) {
            return cachedSettings.get(input);
        }
        // Check if input is an object
        const type = typeof input;
        let _val = null;
        switch (type) {
            case 'function':
                _val = { callback: input };
                break;
            case 'object':
                _val = input;
                break;
            case 'string':
                switch (input) {
                    case 'log':
                        _val = { log: true };
                        break;
                    case 'fail':
                        _val = { fail: true };
                        break;
                    case 'return':
                        _val = { return: true };
                        break;
                    case 'validOutput':
                        _val = { validOutput: input };
                        break;
                }
                break;
        }
        cachedSettings.set(input, _val);
        return _val;
    }

    return {
        log: false,
        fail: false,
        return: false,
        validOutput: false,
        callback: null,
    };
}

/**
 * Throw an error with the last typeErrorLogs
 */
function typeError(inputVal) {
    const errorLog = typeErrorLogs[typeErrorLogs.length - 1];

    console.log('\n::::::::::::: Type error or not valid ::::::::::::::');
    console.log('Input Value used: ', inputVal);
    console.log('---> Value Found:', errorLog.found);
    console.log('---> Test Permormed:', errorLog.tests);
    //clean the array of error logs
    typeErrorLogs.length = 0;
    throw new Error(
        `\n\n---------------------\nTypeCheck Error --->\n\n The value must not be of type (Type found) = "${errorLog.found}". \n\n The Type used is invalid for value: "${errorLog.value}". \n\n see logged error for details\n---------------------\n\n`
    );
}

function pushToErrorLogs(inputVal, tests) {
    typeErrorLogs.push({
        value: JSON.stringify(inputVal),
        tests: JSON.stringify(tests),
        found: typeOf(inputVal),
    });
}

/**
* _TypeCheck
* @param {any} inputVal
* @param {string} typeExp
* @param {object | string} params Parameters for the typeCheck function. 
* @return {bool | any} TypeChecker By default it returns boolean, but if '.return()' is used it will return the inputVal
* @example typeCheck(1, 'number') // true
* @example typeCheck([1], '[number]') // true
* @example typeCheck({x: 1, y: 2}, '{any: number}') // true
* @example typeCheck({ x: 'string', y: 10 }, '{y: number, x: string}', ($this) => {
        console.log('__testLogHere__', $this);
    }) // using call back function
* @usage (anyInputValue, stringTypeExpression, params: object | string)
* @usage params: object = { log: boolean, fail: boolean, callback: function }
* @usage params: string = 'log' | 'fail' | callback: function
* @usage chain Methods: log(), fail(), return() // returns the input value, test() returns the boolean
* @notes This function cannot validate the return value of a function when the validOutput is provided, use _tcx instead
* Params: log = true ; // logs the testData
* Params: fail = true ; // throws an error when the test fails
* Params: return = true ; // returns the inputVal
* Params: callback = function ; // callback function
* @see testUnit for more examples and test cases   
*/
const _typeCheck = (inputVal, typeExp, params) => {
    return new (class {
        constructor() {
            this.unitTest = testBuilder(typeExp);
            this.testResult = runRouteTest(inputVal, this.unitTest);
            this.bool = this.testResult;
            this.settings = getSettings(params);
            this.callback = this.settings.callback ?? null;
            this.testData = {
                typeExp,
                inputVal,
                inputType: typeOf(inputVal),
                callback: this.callback,
                unitTest: this.unitTest,
                testResult: this.testResult,
            };
            if (this.settings.log) {
                this.log();
            }

            if (this.settings.fail) {
                this.fail();
            }

            if (this.callback) {
                this.callback(this.testData);
            }
        }
        test() {
            return this.testResult;
        }
        log() {
            console.log('-------------------------- \n ::: Test Data Info :::');
            console.table(this.testData);
            return this;
        }
        fail() {
            if (!this.testResult) {
                this.log();
                this.settings?.error && console.log('\n\n-----> Error Message: ', this.settings.error);
                return typeError(inputVal);
            }
            return this;
        }
        return() {
            return inputVal;
        }
    })();
};

/**
* _tc is a helper function to wrap a function with typeCheck
* It is basic but faster the _tcx (neglible but if micro-optimization is needed)
* @param {array} typeExp array of types to test
* @param {function} __function Function to wrap
* @param {object | string} params Parameters for the typeCheck function.
* @return {function} Wrapped function
* @example _tc('[number]', function (myVar) {
        //code
        console.log(myVar);
    });
* @usage (stringTypeExpression, Function(), params: object | string)
* @usage params: object = { log: boolean, fail: boolean, return: boolean, validOutput: string }
* @usage params: string = 'log' | 'fail' | 'return' 
* @usage defaults: log = false, fail = true, return = false
* @notes this function does not accept callback arguments and when using shorthand arguments (string) it does not accept validOutput
* Params: log = true ; // logs the testData
* Params: fail = true ; // throws an error when the test fails
* Params: return = true ; // returns the inputVal
* Params: callback = function ; // callback function
* @see directory test for more information and examples
*/
const _tc = (typeExp, __function, params = {}) => {
    return (...args) => {
        params = { ...{ fail: true }, ...params };
        _typeCheck(args, typeExp, params);
        return __function(...args);
    };
};

/**
* _tcx is a helper function to wrap a function with typeCheck
* It is as performant as the _tc but it has a lot more features to offer
* @param {string} typeExp Expression to test
* @param {function} __function Function to wrap
* @param {object | string} params Parameters for the typeCheck function. 
* @return {function} Wrapped function
* @example _tcx('[number]', function (myVar) {
        //code
        console.log(myVar);
    });
* @usage (stringTypeExpression, Function(), params: object | string)
* @usage params: object = { log: boolean, fail: boolean, return: boolean, validOutput: stringTypeExpression }
* @usage params: string = 'log' | 'fail' | 'return'
* @notes This function can validate the return value of a function when the validOutput is provided
* @feature Return value validation
* @feature all instances accept individual fail, log, and return
* @feature all instances accept chaining parameters: myCoolFunction(44.5, 'yes!').log().fail().return()
* Params: log = true ; // logs the testData
* Params: fail = true ; // throws an error when the test fails
* Params: return = true ; // returns the inputVal
* Params: callback = function ; // callback function
* Params: validOutput = stringTypeExpression ; // validate the return value of the function
* @see directory test for more information and examples
*/
const _tcx = (typeExp, __function, params) => {
    let $settings = getSettings(params);
    //set default as true
    $settings = { ...{ fail: true }, ...$settings };
    return (...args) => {
        return new (class {
            constructor() {
                this.args = args;
                this.testResults = _typeCheck(args, typeExp, $settings);
                return this.default();
            }
            default() {
                this.returns = __function(...args);

                const validOutput = $settings.validOutput ?? false;
                if (validOutput) {
                    _typeCheck(this.returns, validOutput, 'fail');
                }
                return this;
            }
            log() {
                this.testResults.log();
                return this;
            }
            fail() {
                this.testResults.fail();
                return this;
            }
            return() {
                return this.returns;
            }
        })();
    };
};

/**
 * Test the type but does not throw an error, althought it can use the rest of the chain methods
 * @param {any} inputVal
 * @param {string} typeExp
 */
const validType = (inputVal, typeExp) => {
    return _typeCheck(inputVal, typeExp).test();
};

/**
* TypeCheck
* @param {any} inputVal
* @param {string} typeExp
* @example typeCheck(1, 'number') // true
* @example typeCheck([1], '[number]') // true
* @example typeCheck({x: 1, y: 2}, '{any: number}') // true
* @example typeCheck({ x: 'string', y: 10 }, '{y: number, x: string}', ($this) => {
        console.log('__testLogHere__', $this);
    }) // using call back function
* @see testUnit for more examples and test cases   
*/
const typeCheck = (inputVal, typeExp, params = null) => {
    return _typeCheck(inputVal, typeExp, params).fail();
};




/***/ }),

/***/ "./node_modules/knighttower/packages/type-check/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/knighttower/packages/type-check/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TypeCheck: () => (/* reexport safe */ _dist_esm_TypeCheck_mjs__WEBPACK_IMPORTED_MODULE_0__.TypeCheck),
/* harmony export */   _tc: () => (/* reexport safe */ _dist_esm_TypeCheck_mjs__WEBPACK_IMPORTED_MODULE_0__._tc),
/* harmony export */   _tcx: () => (/* reexport safe */ _dist_esm_TypeCheck_mjs__WEBPACK_IMPORTED_MODULE_0__._tcx),
/* harmony export */   _typeCheck: () => (/* reexport safe */ _dist_esm_TypeCheck_mjs__WEBPACK_IMPORTED_MODULE_0__._typeCheck),
/* harmony export */   addTypeTest: () => (/* reexport safe */ _dist_esm_TypeCheck_mjs__WEBPACK_IMPORTED_MODULE_0__.addTypeTest),
/* harmony export */   testBuilder: () => (/* reexport safe */ _dist_esm_TypeCheck_mjs__WEBPACK_IMPORTED_MODULE_0__.testBuilder),
/* harmony export */   typeCheck: () => (/* reexport safe */ _dist_esm_TypeCheck_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   typesMap: () => (/* reexport safe */ _dist_esm_TypeCheck_mjs__WEBPACK_IMPORTED_MODULE_0__.typesMap),
/* harmony export */   validType: () => (/* reexport safe */ _dist_esm_TypeCheck_mjs__WEBPACK_IMPORTED_MODULE_0__.validType)
/* harmony export */ });
/* harmony import */ var _dist_esm_TypeCheck_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/esm/TypeCheck.mjs */ "./node_modules/knighttower/packages/type-check/dist/esm/TypeCheck.mjs");
// Single Modules and Aliases from: TypeCheck

// Default Module from: TypeCheck





/***/ }),

/***/ "./node_modules/knighttower/packages/utility/dist/esm/DomObserver.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/knighttower/packages/utility/dist/esm/DomObserver.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DomObserver: () => (/* binding */ DomObserver),
/* harmony export */   "default": () => (/* binding */ DomObserver),
/* harmony export */   domObserver: () => (/* binding */ DomObserver)
/* harmony export */ });
// Author Knighttower
// MIT License
// [2022] [Knighttower] https://github.com/knighttower
/**
 * @module DomObserver
 * Detect DOM changes
 * @name DomObserver
 * @param {window} selector
 * @param {Function}
 * @return DomObserver
 * @example DomObserver.addOnNodeChange('elementIdentifier', () => { console.log('Node changed') })
 * @example DomObserver.removeOnNodeChange('elementIdentifier')
 */
/**
 * Holds memory of registered functions
 * @private
 */
const executeOnNodeChanged = {};
/**
 * When node change
 * @param {String} id
 * @param {Function} callback Callback when any node changes/ add/deleted/modified
 * @return {Void}
 */
const addOnNodeChange = (id, callback) => {
    if (callback) {
        executeOnNodeChanged[id] = callback;
    }
};
/**
 * Remove from node change
 * @param {String} id
 * @return {Void}
 */
const removeOnNodeChange = (id) => {
    if (id) {
        delete executeOnNodeChanged[id];
    }
};
/**
 * Deep cleanup
 * @return {Void}
 */
const cleanup = () => {
    Object.keys(executeOnNodeChanged).forEach((key) => delete executeOnNodeChanged[key]);
};
/**
 * Observer
 * @private
 * @return {MutationObserver}
 */
(() => {
    if (typeof window !== 'undefined') {
        const callback = (mutationList) => {
            for (const mutation of mutationList) {
                if (mutation.type === 'childList') {
                    for (const id in executeOnNodeChanged) {
                        executeOnNodeChanged[id]();
                    }
                }
            }
        };
        const config = {
            childList: true,
            subtree: true,
        };
        const observer = new MutationObserver(callback);
        observer.observe(document.body, config);
    }
})();
const DomObserver = {
    executeOnNodeChanged,
    addOnNodeChange,
    removeOnNodeChange,
    cleanup,
};




/***/ }),

/***/ "./node_modules/knighttower/packages/utility/dist/esm/ElementHelper.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/knighttower/packages/utility/dist/esm/ElementHelper.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ElementHelper: () => (/* binding */ ElementHelper),
/* harmony export */   "default": () => (/* binding */ ElementHelper),
/* harmony export */   elementHelper: () => (/* binding */ ElementHelper),
/* harmony export */   selectElement: () => (/* binding */ selectElement)
/* harmony export */ });
// Author Knighttower
// MIT License
// [2022] [Knighttower] https://github.com/knighttower
/**
 * @module DomObserver
 * Detect DOM changes
 * @name DomObserver
 * @param {window} selector
 * @param {Function}
 * @return DomObserver
 * @example DomObserver.addOnNodeChange('elementIdentifier', () => { console.log('Node changed') })
 * @example DomObserver.removeOnNodeChange('elementIdentifier')
 */
/**
 * Holds memory of registered functions
 * @private
 */
const executeOnNodeChanged = {};
/**
 * When node change
 * @param {String} id
 * @param {Function} callback Callback when any node changes/ add/deleted/modified
 * @return {Void}
 */
const addOnNodeChange = (id, callback) => {
    if (callback) {
        executeOnNodeChanged[id] = callback;
    }
};
/**
 * Remove from node change
 * @param {String} id
 * @return {Void}
 */
const removeOnNodeChange = (id) => {
    if (id) {
        delete executeOnNodeChanged[id];
    }
};
/**
 * Deep cleanup
 * @return {Void}
 */
const cleanup = () => {
    Object.keys(executeOnNodeChanged).forEach((key) => delete executeOnNodeChanged[key]);
};
/**
 * Observer
 * @private
 * @return {MutationObserver}
 */
(() => {
    if (typeof window !== 'undefined') {
        const callback = (mutationList) => {
            for (const mutation of mutationList) {
                if (mutation.type === 'childList') {
                    for (const id in executeOnNodeChanged) {
                        executeOnNodeChanged[id]();
                    }
                }
            }
        };
        const config = {
            childList: true,
            subtree: true,
        };
        const observer = new MutationObserver(callback);
        observer.observe(document.body, config);
    }
})();
const DomObserver = {
    executeOnNodeChanged,
    addOnNodeChange,
    removeOnNodeChange,
    cleanup,
};

// Author Knighttower
// MIT License
// Copyright (c) [2022] [Knighttower] https://github.com/knighttower


/**
 * @class Adds some extra functionality to interact with a DOM element
 * @param {String|Object} selector Class or ID or DOM element
 * @param {String} scope The scope to search in, window, document, dom element. Defaults to document
 * @return {Object}
 * @example new ElementHelper('elementSelector')
 * @example new ElementHelper('elementSelector', domElement|window|document)
 *
 */
class ElementHelper {
    /**
     * Constructor
     * @param {String|Object} selector
     * @return {Object}
     */
    constructor(selector, scope = document) {
        this.selector = selector;
        if (typeof selector === 'object') {
            this.domElement = selector;
        } else if (String(selector).includes('//')) {
            this.domElement = this.getElementByXpath(selector);
        } else {
            this.domElement = scope.querySelector(selector);
        }
    }

    // =========================================
    // --> Public
    // --------------------------

    /**
     * Check if the element exists or is visible. It will keep querying
     * @return {Boolean}
     */
    isInDom() {
        return Boolean(this.domElement?.outerHTML);
    }

    /**
     * Wait for element exists or is visible. It will keep querying
     * @function whenInDom
     * @return {Promise}
     */
    whenInDom() {
        let $this = this;
        let callbackId = Date.now() + Math.floor(Math.random() * 1000);

        return new Promise(function (resolveThis) {
            if (!$this.isInDom()) {
                DomObserver.addOnNodeChange(callbackId, () => {
                    let element = new ElementHelper($this.selector);
                    if (element.isInDom()) {
                        $this = element;
                        resolveThis($this);
                        DomObserver.removeOnNodeChange(callbackId);
                    }
                });
            } else {
                resolveThis($this);
            }
        });
    }

    /**
     * Find element by Xpath string
     * @param {String} xpath
     * @example getElementByXpath("//html[1]/body[1]/div[1]")
     * @return {Object} DOM element
     */
    getElementByXpath(xpath) {
        return document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
    }

    /**
     * Get the element xpath string
     * @author Based on https://stackoverflow.com/questions/2631820/how-do-i-ensure-saved-click-coordinates-can-be-reload-to-the-same-place-even-if/2631931#2631931
     * @return {String}
     */
    getXpathTo() {
        let element = this.domElement;

        if (element.id) {
            return `//*[@id='${element.id}']`;
        }
        if (element === document.body) {
            return '//' + element.tagName;
        }

        let ix = 0;
        let siblings = element.parentNode.childNodes;
        for (let i = 0; i < siblings.length; i++) {
            let sibling = siblings[i];
            if (sibling === element) {
                return (
                    new ElementHelper(element.parentNode).getXpathTo() + '/' + element.tagName + '[' + (ix + 1) + ']'
                );
            }
            if (sibling.nodeType === 1 && sibling.tagName === element.tagName) {
                ix++;
            }
        }
    }

    /**
     * Get the element attribute, but parse it if it is an object or array
     * @param {String} attr Atrribute name
     * @return {String|Array|Object|Null}
     */
    getAttribute(attr) {
        return this.domElement.getAttribute(attr) || null;
    }

    /**
     * Create a unique has for the element derived from its xpath
     * @author Based on https://www.geeksforgeeks.org/how-to-create-hash-from-string-in-javascript/
     * @return {String}
     */
    getHash() {
        let string = String(this.getXpathTo());
        let hash = 0;

        if (string.length === 0) {
            return hash;
        }

        for (let i = 0; i < string.length; i++) {
            let char = string.charCodeAt(i);
            hash = (hash << 5) - hash + char;
            hash = hash & hash;
        }

        return hash;
    }
}

// =========================================
// --> Utilities
// --------------------------
const selectElement = (selector, scope = document) => new ElementHelper(selector, scope);




/***/ }),

/***/ "./node_modules/knighttower/packages/utility/dist/esm/EventBus.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/knighttower/packages/utility/dist/esm/EventBus.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EventBus: () => (/* binding */ EventBus),
/* harmony export */   _eventBus: () => (/* binding */ _eventBus),
/* harmony export */   "default": () => (/* binding */ EventBus)
/* harmony export */ });
class EventBus {
    constructor() {
        // Memory storage for all the events
        this.listeners = {};
    }
    // creates an event that can be triggered any number of times
    /**
     * creates an event that can be triggered any number of times
     * @method on
     * @param {string} eventName - The name of the event
     * @param {function} callback - The callback to execute
     * @return {void}
     * @example eventBus.on('event.name', function() { console.log('event.name was triggered') })
     */
    on(eventName, callback) {
        this.registerListener(eventName, callback);
    }
    /**
     * creates an event that can be triggered only once. If it is emitted twice, the callback will only be executed once!
     * @method once
     * @param {string} eventName - The name of the event
     * @param {function} callback - The callback to execute
     * @return {void}
     * @example eventBus.once('event.name', function() { console.log('event.name was triggered only once') })
     */
    once(eventName, callback) {
        this.registerListener(eventName, callback, 1);
    }
    /**
     * reates an event that can be triggered only a number of times. If it is emitted more than that, the callback will not be be executed anymore!
     * @method exactly
     * @param {string} eventName - The name of the event
     * @return {void}
     * @example eventBus.exactly('event.name', function() { console.log('event.name was triggered 3 times') }, 3)
     */
    exactly(eventName, callback, capacity) {
        this.registerListener(eventName, callback, capacity);
    }
    /**
     * kill an event with all it's callbacks
     * @method off
     * @param {string} eventName - The name of the event
     * @return {void}
     * @example eventBus.off('event.name')
     */
    off(eventName) {
        delete this.listeners[eventName];
    }
    /**
     * removes the given callback for the given event
     * @method detach
     * @param {string} eventName - The name of the event
     * @param {function} callback - The callback to remove
     * @return {void|boolean} - Returns true if the event was found and removed, void otherwise
     * @example eventBus.detach('event.name', callback)
     */
    detach(eventName, callback) {
        const listeners = this.listeners[eventName] || [];
        const filteredListeners = listeners.filter(function (value) {
            return value.callback !== callback;
        });
        if (eventName in this.listeners) {
            this.listeners[eventName] = filteredListeners;
            return true; // Event was found and removed
        }
        return false; // Event was not found
    }

    /**
     * emits an event with the given name and arguments
     * @param {string} eventName - The name of the event
     * @param {any} args - The arguments to pass to the callback
     * @return {void}
     * @use {__context: this|Instance} to pass the context to the callback
     * @example eventBus.emit('event.name', arg1, arg2, arg3)
     * @example eventBus.emit('event.name', arg1, arg2, arg3, {__context: YourInstance})
     */
    emit(eventName, ...args) {
        let queueListeners = [];
        let matches = null;
        const allArgs = this.extractContextFromArgs(args);
        const context = allArgs[0];
        args = allArgs[1];
        // name exact match
        if (this.hasListener(eventName)) {
            queueListeners = this.listeners[eventName];
        } else {
            // -----------------------------------------
            // Wildcard support
            if (eventName.includes('*')) {
                // case 1, if the incoming string has * or ** in it
                // which will suppport emit("name*") or emit("name**") or emit("name.*name**")
                matches = this.patternSearch(eventName, Object.keys(this.listeners));
                if (matches) {
                    matches.forEach((match) => {
                        queueListeners = queueListeners.concat(this.listeners[match]);
                    });
                }
            } else {
                // case 2, if the incoming string matches a registered pattern
                // which will support on("name*") | on("name**") | on("name.*name**")
                for (const key in this.listeners) {
                    matches = this.patternSearch(key, [eventName]);
                    if (matches) {
                        queueListeners = queueListeners.concat(this.listeners[key]);
                    }
                }
            }
        }
        queueListeners.forEach((listener, k) => {
            let callback = listener.callback;
            if (context) {
                callback = callback.bind(context);
            }
            callback(...args);
            if (listener.triggerCapacity !== undefined) {
                listener.triggerCapacity--;
                queueListeners[k].triggerCapacity = listener.triggerCapacity;
            }
            if (this.checkToRemoveListener(listener)) {
                this.listeners[eventName].splice(k, 1);
            }
        });
    }
    /**
     * Search for a pattern in a list of strings
     * @method patternSearch
     * @private
     * @param {string} pattern - The pattern to search for
     * @param {string[]} list - The list of strings to search in
     * @return {string[]|null} - Returns a list of strings that match the pattern, or null if no match is found
     * @example patternSearch('name.*', ['name.a', 'name.b', 'name.c']) // returns ['name.a', 'name.b', 'name.c']
     */
    patternSearch(pattern, list) {
        let filteredList = [];
        // console.log('__testLogHere__', pattern, this.setWildCardString(pattern));
        const regex = new RegExp(this.setWildCardString(pattern));
        filteredList = list.filter((item) => regex.test(item));
        return filteredList.length === 0 ? null : filteredList;
    }
    setWildCardString(string) {
        // eslint-disable-next-line
        let regexStr = string.replace(/([.+?^${}()|\[\]\/\\])/g, '\\$&'); // escape all regex special chars
        regexStr = regexStr
            // eslint-disable-next-line
            .replace(/\*\*/g, '[_g_]') // Replace wildcard patterns with temporary markers
            // eslint-disable-next-line
            .replace(/\*/g, '(.*?)')
            .replace(/\[_g_\]/g, '.*');
        return `^${regexStr}$`;
    }
    /**
     * Extract the context from the arguments
     * @method extractContextFromArgs
     * @private
     * @param {any[]} args - The arguments to extract the context from
     * @return {any[]} - Returns an array with the context as the first element and the arguments as the second element
     */
    extractContextFromArgs(args) {
        let context = null;
        for (let i = 0; i < args.length; i++) {
            const arg = args[i];
            // eslint-disable-next-line
            if (arg && typeof arg === 'object' && arg.hasOwnProperty('__context')) {
                context = arg.__context;
                args.splice(i, 1);
                break;
            }
        }
        return [context, args];
    }
    registerListener(eventName, callback, triggerCapacity) {
        if (!this.hasListener(eventName)) {
            this.listeners[eventName] = [];
        }
        this.listeners[eventName].push({ callback, triggerCapacity });
    }
    checkToRemoveListener(eventInformation) {
        if (eventInformation.triggerCapacity !== undefined) {
            return eventInformation.triggerCapacity <= 0;
        }
        return false;
    }
    hasListener(eventName) {
        return eventName in this.listeners;
    }
}
function _eventBus() {
    // support for browser
    if (typeof window !== 'undefined') {
        if (!window.eventBus) {
            window.eventBus = new EventBus();
        }
        return window.eventBus;
    }
    if (typeof global !== 'undefined') {
        if (!global.eventBus) {
            global.eventBus = new EventBus();
        }
        return global.eventBus;
    }
    // if none of the above is available, return a new instance
    return new EventBus();
}




/***/ }),

/***/ "./node_modules/knighttower/packages/utility/dist/esm/PowerHelpers.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/knighttower/packages/utility/dist/esm/PowerHelpers.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PowerHelper: () => (/* binding */ powerHelper),
/* harmony export */   addQuotes: () => (/* binding */ addQuotes),
/* harmony export */   cleanStr: () => (/* binding */ cleanStr),
/* harmony export */   convertKeysToSymbols: () => (/* binding */ convertKeysToSymbols),
/* harmony export */   "default": () => (/* binding */ powerHelper),
/* harmony export */   findAndReplaceInArray: () => (/* binding */ findAndReplaceInArray),
/* harmony export */   findNested: () => (/* binding */ findNested),
/* harmony export */   fixQuotes: () => (/* binding */ fixQuotes),
/* harmony export */   getArrObjFromString: () => (/* binding */ getArrObjFromString),
/* harmony export */   getChunks: () => (/* binding */ getChunks),
/* harmony export */   getDirectivesFromString: () => (/* binding */ getDirectivesFromString),
/* harmony export */   getMatchBlock: () => (/* binding */ getMatchBlock),
/* harmony export */   getMatchInBetween: () => (/* binding */ getMatchInBetween),
/* harmony export */   powerHelper: () => (/* binding */ powerHelper),
/* harmony export */   removeQuotes: () => (/* binding */ removeQuotes),
/* harmony export */   setExpString: () => (/* binding */ setExpString),
/* harmony export */   setLookUpExp: () => (/* binding */ setLookUpExp),
/* harmony export */   setWildCardString: () => (/* binding */ setWildCardString),
/* harmony export */   startAndEndWith: () => (/* binding */ startAndEndWith),
/* harmony export */   wildCardStringSearch: () => (/* binding */ wildCardStringSearch)
/* harmony export */ });
// // -----------------------------------------
// /**
//  * @knighttower
//  * @url knighttower.io
//  * @git https://github.com/knighttower/
//  */
// // -----------------------------------------

// -----------------------------
// METHODS
// -----------------------------

/**
 * Convert a value to bool
 * @param {String|Boolean|Int|Number} val
 * @return {Boolean}
 * @usage convertToBool('true') // true
 * @usage convertToBool('false') // false
 * @usage convertToBool('0') // false
 * @usage convertToBool('1') // true
 * @usage convertToBool('') // false
 * @usage convertToBool('true') // true
 * @usage convertToBool('false') // false
 */
function convertToBool(val) {
    switch (typeof val) {
        case 'boolean':
            return val;
        case 'string':
            return val === 'false' || val === '0' ? false : true;
        case 'number':
            return val !== 0;
        default:
            return Boolean(val);
    }
}

/**
 * Converts a given variable to a number if possible.
 * @param {string|number} input - The input variable to convert.
 * @returns {string|number} - The converted number or the original variable.
 * @example convertToNumber(123) // Output: 123 (number)
 * @example convertToNumber(123.45) // Output: 123.45 (number)
 * @example convertToNumber("123") // Output: 123 (number)
 * @example convertToNumber("123.45") // Output: 123.45 (number)
 * @example convertToNumber("abc") // Output: "abc" (original string)
 * @example convertToNumber("123abc") // Output: "123abc" (original string)
 * @example convertToNumber(null) // Output: null (original)
 */
function convertToNumber(input) {
    const isNum = isNumber(input);

    if (isNum !== null) {
        return isNum;
    }
    // Case: String that cannot be converted to a number
    return input;
}

/**
 * Check if there is a value, if not return null or the default value
 * It can test strings, arrays, objects, numbers, booleans
 * @function emptyOrValue
 * @memberof Utility
 * @param {String|Number} value If the value is not empty, returns it
 * @param {String|Number} _default The default value if empty
 * @return mixed
 * @example emptyOrValue('test', 'default') // 'test'
 * @example emptyOrValue('', 'default') // 'default'
 * @example emptyOrValue('test') // 'test'
 * @example emptyOrValue('') // null
 * @example emptyOrValue(0) // 0
 * @example var hello = ''; emptyOrValue(hello) // Null
 * @example var hello = 'test'; emptyOrValue(hello) // 'test'
 * @example var hello = 'test'; emptyOrValue(hello, 'default') // 'test'
 * @example var hello = ''; emptyOrValue(hello, 'default') // 'default'
 * @example var hello = []; emptyOrValue(hello, 'default') // null
 * @example var hello = {}; emptyOrValue(hello, 'default') // null
 * @example var hello = [...]; emptyOrValue(hello') // [...]
 */
function emptyOrValue(value, _default = null) {
    /**
     * Test sequence:
     * If it is a number 0> : true
     * If is not undefined: true
     * If it is boolean (true|false) prevents going to empty
     * If it is not Empty, [], null, {}, 0, true, false: true
     */

    if (isNumber(value) !== null || typeof value === 'boolean') {
        return value;
    } else if (!isEmpty(value)) {
        return value;
    }

    return _default;
}

/**
 * Generate unique ids
 * @function getDynamicId
 * @memberof Utility
 * @return string Format kn__000000__000
 */
function getDynamicId() {
    return 'kn__' + new Date().getTime() + '__' + Math.floor(Math.random() * (999 - 100));
}

/**
 * Alias to getDynamicId
 * @function getRandomId
 * @memberof Utility
 * @return string
 * @example getRandomId() // kn__000000__000
 */
const getRandomId = getDynamicId;

/**
 * Check if a value is empty
 * @function isEmpty
 * @memberof Utility
 * @param {string|array|object|map|set|number|boolean} value
 * @url https://moderndash.io/
 * @return {string}
 */
function isEmpty(value) {
    if (value === null || value === undefined) {
        return true;
    }

    if (typeof value === 'string' || Array.isArray(value)) {
        return value.length === 0;
    }

    if (value instanceof Map || value instanceof Set) {
        return value.size === 0;
    }

    if (ArrayBuffer.isView(value)) {
        return value.byteLength === 0;
    }

    if (typeof value === 'object') {
        return Object.keys(value).length === 0;
    }

    return false;
}

/**
 * Check if is a number or Int, if not return null
 * Integrates both Int and Number, or convert a string number to number to test
 * Note: this is not like Lodash isNumber since this one takes into consideration the 'string number'
 * @function isNumber
 * @memberof Utility
 * @param {String|Number} value
 * @return null|int
 * @example isNumber(123) // true
 * @example isNumber(123.45) // true
 * @example isNumber('123abc') // false
 * @example isNumber('abc') // false
 * @example isNumber('') // false
 * @example isNumber("123") // true
 * @example isNumber("123.45") // true
 */
function isNumber(value) {
    const isType = typeof value;
    switch (value) {
        case null:
        case undefined:
        case '':
            return null;
        case '0':
        case 0:
            return 0;
        default:
            if (isType === 'number' || isType === 'string') {
                if (typeof value === 'number' || !Number.isNaN(Number(value))) {
                    return +value;
                }
            }

            break;
    }

    return null;
}

/**
 * Check the type of a variable, and get the correct type for it. It also accepts simple comparisons
 * For more advance type checking see https://github.com/knighttower/JsTypeCheck
 * @param {any} input - The variable to check
 * @param {string} test - The types to check against, piped string
 * @return {string|boolean} - The type of the variable
 * @example typeOf('hello', 'string') // returns true
 * @example typeOf('hello', 'number') // returns false
 * @example typeOf('hello', 'string') // returns true
 * @example typeOf('hello') // returns 'string'
 * @example typeOf({}) // returns 'object'
 */
function typeOf(input, test) {
    // Special case for null since it can be treated as an object
    if (input === null) {
        if (test) {
            return test === null || test === 'null' ? true : false;
        }
        return 'null';
    }

    let inputType;

    switch (typeof input) {
        case 'number':
        case 'string':
        case 'boolean':
        case 'undefined':
        case 'bigint':
        case 'symbol':
        case 'function':
            inputType = typeof input;
            break;
        case 'object':
            inputType = Array.isArray(input) ? 'array' : 'object';

            break;
        default:
            inputType = 'unknown';
    }

    if (test) {
        if (test.includes('|')) {
            for (let type of test.split('|')) {
                if (inputType === type) {
                    return type;
                }
            }
            return false;
        }

        return test === inputType;
    }

    return inputType;
}

// Author Knighttower
// MIT License
// Copyright (c) [2022] [Knighttower] https://github.com/knighttower


// @private
function _removeBrackets(strExp) {
    const regex = /^(\[|\{)(.*?)(\]|\})$/; // Match brackets at start and end
    const match = strExp.match(regex);

    if (match) {
        return match[2].trim(); // Extract and trim the content between brackets
    }

    return strExp; // Return the original string if no brackets found at start and end
}

/**
 * Add quotes to a string
 * @function addQuotes
 * @param {String} str
 * @return {String}
 * @example addQuotes('hello') // "hello"
 */
function addQuotes(str, q = '"') {
    return `${q}${str}${q}`;
}

/**
 * Clean a string from delimeters or just trimmed if no delimeters given
 * @funtion cleanStr
 * @param {String} str - String to use
 * @param {String|Regex} p1 - Delimeter 1
 * @param {String|Regex} p2 - Delimeter 2
 * @return {String|void}
 * @example cleanStr('hello world', 'h', 'd') // 'ello worl'
 * @example cleanStr('  hello world  ') // 'hello world'
 * @example cleanStr('hello world', 'hello') // 'world'
 * @example cleanStr('Hello World. Sunshine is here!', '\..*!') // Hello World
 * @example cleanStr('Hello World. Sunshine is here!', /Hello/g) // ' World. Sunshine is here!'
 * @example cleanStr('Hello World. Sunshine is here!', /Hello/g, /Sunshine/g) // ' World.  is here!'
 */
function cleanStr(str, ...args) {
    if (!str) {
        return;
    }
    if (typeof str !== 'string') {
        return str;
    }

    return args
        .reduce((accStr, arg) => {
            const regex = arg instanceof RegExp ? arg : new RegExp(setExpString(arg));
            return accStr.replace(regex, '');
        }, str)
        .trim();
}

/**
 * convert all keys from an object to symbols
 * @function convertKeysToSymbols
 * @param {object} obj - The object to convert
 * @return {object} - The object with all keys converted to symbols
 * @example convertKeysToSymbols({a: 1, b: 2}) // returns {Symbol(a): 1, Symbol(b): 2, keyToSymbolMap: {a: Symbol(a), b: Symbol(b)}
 */
function convertKeysToSymbols(obj) {
    if (emptyOrValue(obj, null) === null) {
        return {};
    }
    const newObj = {};
    const keyToSymbolMap = {};
    for (const key in obj) {
        const symbolKey = Symbol(key);
        newObj[symbolKey] = obj[key];
        keyToSymbolMap[key] = symbolKey;
    }
    newObj.keyToSymbolMap = keyToSymbolMap;
    return newObj;
}

/**
 * Recursively will loop in array to find the desired target
 * @function findAndReplaceInArray
 * @param {Array} arr
 * @param {String} find The target (needle)
 * @param {Array|Object|String} value Replacer
 * @return {Null|Array}
 * @example findAndReplaceInArray([1,2,3,4,5], 3, 'three') // [1,2,'three',4,5]
 */
function findAndReplaceInArray(arr, find, value) {
    let replaced = false;

    const result = arr.map((prop) => {
        if (Array.isArray(prop)) {
            const replacedArray = findAndReplaceInArray(prop, find, value);
            if (replacedArray) {
                replaced = true;
                return replacedArray;
            }
            return prop;
        }
        if (prop === find) {
            replaced = true;
            if (Array.isArray(value)) {
                return value.map((p) => (Array.isArray(p) ? p : p.trim()));
            }
            return value;
        }
        return prop;
    });

    return replaced ? result : null;
}

/**
 * Find the last instance of nested pattern with delimeters
 * @function findNested
 * @param {string} str
 * @param {string} start - Delimeter 1
 * @param {string} end - Delimeter 2
 * @return {string|null}
 * @example findNested('[[]hello [world]]', '[', ']') // [world]
 */
function findNested(str, start = '[', end = ']') {
    if (typeof str !== 'string') {
        return str;
    }
    // Find the last index of '['
    const lastIndex = str.lastIndexOf(start);
    // If '[' is not found, return null or some default value
    if (lastIndex === -1) {
        return null;
    }

    // Extract the substring starting from the last '[' to the end
    const substring = str.substring(lastIndex);
    // Find the index of the first ']' in the substring
    const endIndex = substring.indexOf(end);
    // If ']' is not found, return null or some default value
    if (endIndex === -1) {
        return null;
    }
    // Extract and return the content between the last '[' and the next ']', including them
    return substring.substring(0, endIndex + 1);
}

/**
 * Fix quotes from a string
 * @function fixQuotes
 * @param {String} str
 * @return {String} q quote type
 * @return {String}
 * @example fixQuotes("'hello'") // "hello"
 * @example fixQuotes('"hello"') // "hello"
 */
function fixQuotes(str, q = '"') {
    if (typeof str !== 'string') {
        return str;
    }
    return str.replace(/`|'|"/g, q);
}

/**
 * Converts strings formats into objects or arrays
 * Note: quoted strings are not supported, use getDirectiveFromString instead
 * @param {string} strExp
 * @return {object|array|string}
 * @example getArrObjFromString('[[value,value],value]') // [['value', 'value'], 'value']
 * @example getArrObjFromString('[[value,value],value, { y: hello }, hello]') // [['value', 'value'], 'value', { y: 'hello' }, 'hello']
 * @example getArrObjFromString('{ y: hello, x: world, z: [value,value]}') // { y: 'hello', x: 'world', z: ['value', 'value'] }
 */
function getArrObjFromString(strExp) {
    // alredy typeof object or array just return it
    if (typeOf(strExp, 'object') || typeOf(strExp, 'array')) {
        return strExp;
    }
    const isObject = startAndEndWith(strExp, '{', '}');
    const isArray = startAndEndWith(strExp, '[', ']');
    // If it is other type of string, return it
    if (!isObject && !isArray) {
        return strExp;
    }

    const newCollection = isObject ? {} : [];
    const nestedElements = {};

    //remove the brackets
    let newStrExp = _removeBrackets(strExp);

    const loopNested = (objects = false) => {
        // ignore eslint comment
        // eslint-disable-next-line no-constant-condition
        while (true) {
            //find any nested arrays or objects
            let matched = objects ? findNested(newStrExp, '{', '}') : findNested(newStrExp);

            if (!matched) {
                break;
            }

            //replace the nested array or object with a marker so that we can safely split the string
            let marker = `__${getRandomId()}__`;
            nestedElements[marker] = matched;

            newStrExp = newStrExp.replace(matched, marker);
        }
    };

    loopNested();
    loopNested(true);

    getChunks(newStrExp).forEach((chunk, index) => {
        const isObjectKey = chunk.includes(':') && isObject;
        const chunkParts = isObjectKey ? getChunks(chunk, ':') : [];
        const chunkKey = removeQuotes(emptyOrValue(chunkParts[0], index));
        chunk = isObjectKey ? chunkParts[1] : chunk;
        if (chunk in nestedElements) {
            chunk = getArrObjFromString(nestedElements[chunk]);
        }
        chunk = convertToNumber(removeQuotes(chunk));
        // set back in the collection either as an object or array
        isObject ? (newCollection[chunkKey] = chunk) : newCollection.push(chunk);
    });
    // uncomment to debug
    // console.log('___ log ___', newCollection);
    return newCollection;
}

/**
 * handles the following patterns to get an object from string attributes
 * // Matches the JSON objects as string: {'directive':{key:value}} OR {key:value}
 * // Matches the Array as string: [value, value] OR ['value','value']
 * // Matches a multi-array string like [[value,value]],value]
 * // Matches object-style strings: directive.tablet(...values) OR directive[expression](...values)
 * // Matches string ID or class: literals Id(#) or class (.). Note that in Vue it needs to be in quotes attr="'#theId'"
 * // Mathes simple directive function style: directive(#idOr.Class)
 * Note: all the above with the exception of the Id/class will be converted into actual objects
 */
/**
 * Converts strings formats into objects
 * @function getDirectivesFromString
 * @param {String|Array|Object} stringDirective
 * @return {object|null|void}
 * @example getDirectivesFromString('directive.tablet(...values)') // {directive: {tablet: 'values'}}
 * @example getDirectivesFromString('[[value,value],value]') // {directive: 'values', directive2: 'values'}
 * @example getDirectivesFromString('directive.tablet|mobile(...values)') // {directive: {tablet: 'values', mobile: 'values'}}
 * @example getDirectivesFromString('directive.tablet(...values)') // {directive: {tablet: 'values'}}
 */
function getDirectivesFromString(stringDirective) {
    const str = stringDirective;
    if (!emptyOrValue(str)) {
        return null;
    }

    const results = (type = null, results = null) => {
        return {
            type: type,
            directive: results,
        };
    };
    const matchArrayTypes = /^\[((.|\n)*?)\]$/gm;
    // comment eslint to ignore
    // eslint-disable-next-line no-useless-escape
    const matchObjectTypes = /^\{((.|\n)*?)\:((.|\n)*?)\}/gm;
    // eslint-disable-next-line no-useless-escape
    const matchFunctionString = /^([a-zA-Z]+)(\()(\.|\#)(.*)(\))/g;
    const regexDotObjectString = /([a-zA-Z]+)\.(.*?)\(((.|\n)*?)\)/gm;
    const regexExObjectString = /([a-zA-Z]+)\[((.|\n)*?)\]\(((.|\n)*?)\)/gm;
    let type = typeof str;

    if (type === 'object' || type === 'array') {
        return results(type, str);
    } else {
        switch (true) {
            case !!str.match(matchArrayTypes):
                // Matches the Array as string: [value, value] OR ['value','value']
                // regexArrayLike = /^\[((.|\n)*?)\]$/gm;
                // Matches a multi-array string like [[value,value]],value]
                // regexMultiArrayString = /\[(\n|)(((.|\[)*)?)\](\,\n|)(((.|\])*)?)(\n|)\]/gm;

                type = 'array';
                break;
            case !!str.match(matchObjectTypes):
                // Matches the JSON objects as string: {'directive':{key:value}} OR {key:value}
                // regexObjectLike = /^\{((.|\n)*?)\:((.|\n)*?)\}/gm;
                type = 'object';
                break;
            case !!str.match(matchFunctionString):
                // Mathes simple directive function style: directive(#idOr.Class)
                // regexFunctionString
                // eslint-disable-next-line
                const directive = str.split('(')[0].trim();
                return results('idOrClassWithDirective', { [directive]: getMatchInBetween(str, '(', ')') });
            case !!str.match(regexDotObjectString):
                // Matches object-style strings: directive.tablet(...values) OR directive[expression](...values)
                // OR directive.breakdown|breakdown2(...values) OR directive.tablet(...values)&&directive.mobile(...values)
                type = 'dotObject';
                break;
            case !!str.match(regexExObjectString):
                type = 'dotObject';
                break;

            default:
                return results('string', str);
        }
    }

    if (type === 'array' || type === 'object') {
        let strQ = fixQuotes(str);
        try {
            return results(type, JSON.parse(strQ));
        } catch (error) {
            // uncomment to debug
            // console.log('___ parse error ___', error);
        }

        return results(type, getArrObjFromString(strQ));
    }

    if (type === 'dotObject') {
        let values, breakDownId, directive;
        const setObject = {};

        getChunks(str, '&&').forEach((command) => {
            if (command.match(regexExObjectString)) {
                // Matches object-style strings: directive[expression](...values)
                values = getMatchInBetween(command, '](', ')');
                breakDownId = getMatchInBetween(command, '[', ']');
                directive = command.split('[')[0].trim();
            } else {
                // Matches object-style strings: directive.tablet(...values)
                values = getMatchInBetween(command, '(', ')');
                command = command.replace(getMatchBlock(command, '(', ')'), '');
                [directive, breakDownId] = getChunks(command, '.');
            }

            values = getArrObjFromString(values);

            if (!setObject[directive]) {
                setObject[directive] = {};
            }

            getChunks(breakDownId, '|').forEach((id) => {
                setObject[directive][id] = values;
            });
        });

        return results('dotObject', setObject);
    }
}

/**
 * Find math by delimeters returns raw matches
 * @function getMatchBlock
 * @param {String} str
 * @param {String|Regex} p1
 * @param {String|Regex} p2
 * @param {Boolean} all If it should return all matches or single one (default)
 * @return {String|Array|Null}
 * @example getMatchBlock('is a hello world today', 'h', 'd') // 'hello world'
 * @example getMatchBlock('is a hello world today', 'h', 'd', true) // ['hello world']
 * @example getMatchBlock('is a <hello world/> today', '<', '/>') // '<hello world/>'
 */
function getMatchBlock(str, p1, p2, all = false) {
    if (typeof str !== 'string') {
        return str;
    }
    p1 = setExpString(p1);
    p2 = setExpString(p2);
    let regex = new RegExp(setLookUpExp(p1, p2), 'gm');
    const matches = str.match(regex);
    if (matches) {
        return all ? matches : matches[0];
    }
    return null;
}
/**
 * Splits a string into chunks by a given splitter and cleans the chunks
 * @param {string} str
 * @param {string} splitter - The string/character to split the string by. Defaults to ','
 * @return {string|array}
 */
function getChunks(str, splitter = ',') {
    if (typeof str !== 'string') {
        return str;
    }
    if (isEmpty(str)) {
        return [];
    }
    str = cleanStr(str);
    let chunks = str.split(splitter).map((t) => cleanStr(t));
    return chunks.length === 1 && chunks[0] === '' ? [str] : chunks;
}

/**
 * find a match in between two delimeters, either string or regex given, returns clean matches
 * @function getMatchBlock
 * @param {String} str
 * @param {String|Regex} p1
 * @param {String|Regex} p2
 * @param {Boolean} all If it should return all matches or single one (default)
 * @return {String|Array|Null}
 * @example getMatchInBetween('hello world', 'h', 'd') // 'ello worl'
 * @example getMatchInBetween('hello <world/>', '<', '/>', true) // ['world']
 * @example getMatchInBetween('hello <world/>', '<', '/>') // 'world'
 */
function getMatchInBetween(str, p1, p2, all = false) {
    if (typeof str !== 'string') {
        return str;
    }
    const matchBlock = getMatchBlock(str, p1, p2, all) ?? (all ? [] : str);
    return all ? matchBlock.map((match) => cleanStr(match, p1, p2)) : cleanStr(matchBlock, p1, p2);
}

/**
 * Remove quotes from a string
 * @function removeQuotes
 * @param {String} str
 * @return {String}
 * @example removeQuotes('"hello"') // hello
 * @example removeQuotes("'hello'") // hello
 */
function removeQuotes(str) {
    if (typeof str !== 'string') {
        return str;
    }
    return str.replace(/`|'|"/g, '');
}

/**
 * Checks if a string starts and ends with a given string
 * @param {string} strExp
 * @param {string} start - The string/character to check it starts with
 * @param {string} end - The string/character to check it ends with
 * @return {string}
 * @example startAndEndWith('hello world', 'h', 'd') // false
 * @example startAndEndWith('hello world', 'h', 'd') // true
 */
function startAndEndWith(strExp, start = null, end = null) {
    return (!start || strExp.startsWith(start)) && (!end || strExp.endsWith(end));
}

/**
 * Scapes a string to create a regex or returns the regex if it already is an expression
 * @function setExpString
 * @param {String|Regex} exp
 * @return {String|Regex}
 * @example setExpString('hello') // '\h\e\l\l\o'
 * @example setExpString(/hello/) // /hello/
 * @example setExpString([hello]) // \\[hello\\/ then use like new new RegExp(setExpString(StringOrRegex))
 */
function setExpString(exp) {
    if (exp instanceof RegExp) {
        return exp;
    } else {
        return exp
            .split('')
            .map((char) =>
                ['$', '^', '.', '*', '+', '?', '(', ')', '[', ']', '{', '}', '|', '\\'].includes(char)
                    ? `\\${char}`
                    : char
            )
            .join('');
    }
}

/**
 * Regex builder to get a match in between two delimeters
 * @function setLookUpExp
 * @param {String|Regex} args - minimun two arguments as delimeters
 * @return {String} - Regex
 * @example setLookUpExp('h', 'd') // 'h((.|\n)*?)d'
 * @example setLookUpExp('h', 'd', 'c') // 'h((.|\n)*?)d((.|\n)*?)c'
 * @usage:
 * const pattern = setLookUpExp(".", "!");
const regex = new RegExp(pattern, 'g');
const text = "Hello World. Sunshine is here! Have fun!";
const matches = text.match(regex);
console.log(matches);  // Output: [". Sunshine is here!"]
 */
function setLookUpExp(...args) {
    if (args.length < 2) {
        throw new Error('You need to pass at least two arguments');
    }
    let expression = '';
    // loop through args
    args.forEach((arg, index) => {
        // if arg is a regex, return the source
        if (arg instanceof RegExp) {
            arg = arg.source;
        }
        if (index === 0) {
            expression = arg;
        } else {
            expression += `((.|\n)*?)${arg}`;
        }
    });

    return expression;
}

/**
 * Set a string to be used as a wildcard pattern
 * @function setWildCardString
 * @param {string} string - The string to set as a wildcard pattern
 * @param {boolean} matchStart - If the pattern should match the start of the string
 * @param {boolean} matchEnd - If the pattern should match the end of the string
 * @return {string} - The wildcard pattern
 * @example setWildCardString('name.*', true) // returns '^name\.(.*?)'
 * @example setWildCardString('name.*', false, true) // returns 'name\.(.*?)$'
 * @example setWildCardString('name.**') // returns 'name\..*' greedy
 */
function setWildCardString(str, matchStart = false, matchEnd = false) {
    if (typeof str !== 'string') {
        return str;
    }
    if (!str) {
        return null;
    }
    matchStart = convertToBool(matchStart);
    matchEnd = convertToBool(matchEnd);
    // eslint-disable-next-line no-useless-escape
    let regexStr = str.replace(/([.+?^${}()|\[\]\/\\])/g, '\\$&'); // escape all regex special chars
    let regStart = matchStart ? '^' : '';
    let regEnd = matchEnd ? '$' : '';

    regexStr = regexStr
        .replace(/\*\*/g, '[_g_]') // Replace wildcard patterns with temporary markers
        .replace(/\*/g, '(.*?)')
        .replace(/\[_g_\]/g, '.*');

    return `${regStart}${regexStr}${regEnd}`;
}

/**
 * Search for a wildcard pattern in a list of strings or viceversa
 * @method wildCardStringSearch
 * @param {string} pattern - The pattern to search for
 * @param {array|string} list - The list of strings to search in
 * @param {boolean} matchStart - If the pattern should match the start of the string (optional)
 * @param {boolean} matchEnd - If the pattern should match the end of the string optional)
 * @return {string[]|null} - Returns a list of strings that match the pattern, or null if no match is found
 * @example wildCardStringSearch('name.*', ['name.a', 'name.b', 'name.c']) // returns ['name.a', 'name.b', 'name.c']
 */
function wildCardStringSearch(pattern, listOrString, matchStart = false, matchEnd = false) {
    if (!pattern || !listOrString) {
        return null;
    }

    const regex = new RegExp(setWildCardString(pattern, matchStart, matchEnd));

    if (typeof listOrString === 'string') {
        const matches = listOrString.match(regex);
        return emptyOrValue(matches);
    }

    let filteredList = [];
    filteredList = listOrString.filter((item) => regex.test(item));

    return emptyOrValue(filteredList);
}

const powerHelper = {
    addQuotes,
    cleanStr,
    convertKeysToSymbols,
    findAndReplaceInArray,
    findNested,
    fixQuotes,
    getArrObjFromString,
    getChunks,
    getDirectivesFromString,
    getMatchBlock,
    getMatchInBetween,
    removeQuotes,
    startAndEndWith,
    setExpString,
    setLookUpExp,
    setWildCardString,
    wildCardStringSearch,
};




/***/ }),

/***/ "./node_modules/knighttower/packages/utility/dist/esm/PromiseQueue.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/knighttower/packages/utility/dist/esm/PromiseQueue.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PromisePool: () => (/* binding */ promisePool),
/* harmony export */   PromiseQueue: () => (/* binding */ PromiseQueue),
/* harmony export */   doPoll: () => (/* binding */ doPoll),
/* harmony export */   promisePool: () => (/* binding */ promisePool),
/* harmony export */   promiseQueue: () => (/* binding */ PromiseQueue)
/* harmony export */ });
class EventBus {
    constructor() {
        // Memory storage for all the events
        this.listeners = {};
    }
    // creates an event that can be triggered any number of times
    /**
     * creates an event that can be triggered any number of times
     * @method on
     * @param {string} eventName - The name of the event
     * @param {function} callback - The callback to execute
     * @return {void}
     * @example eventBus.on('event.name', function() { console.log('event.name was triggered') })
     */
    on(eventName, callback) {
        this.registerListener(eventName, callback);
    }
    /**
     * creates an event that can be triggered only once. If it is emitted twice, the callback will only be executed once!
     * @method once
     * @param {string} eventName - The name of the event
     * @param {function} callback - The callback to execute
     * @return {void}
     * @example eventBus.once('event.name', function() { console.log('event.name was triggered only once') })
     */
    once(eventName, callback) {
        this.registerListener(eventName, callback, 1);
    }
    /**
     * reates an event that can be triggered only a number of times. If it is emitted more than that, the callback will not be be executed anymore!
     * @method exactly
     * @param {string} eventName - The name of the event
     * @return {void}
     * @example eventBus.exactly('event.name', function() { console.log('event.name was triggered 3 times') }, 3)
     */
    exactly(eventName, callback, capacity) {
        this.registerListener(eventName, callback, capacity);
    }
    /**
     * kill an event with all it's callbacks
     * @method off
     * @param {string} eventName - The name of the event
     * @return {void}
     * @example eventBus.off('event.name')
     */
    off(eventName) {
        delete this.listeners[eventName];
    }
    /**
     * removes the given callback for the given event
     * @method detach
     * @param {string} eventName - The name of the event
     * @param {function} callback - The callback to remove
     * @return {void|boolean} - Returns true if the event was found and removed, void otherwise
     * @example eventBus.detach('event.name', callback)
     */
    detach(eventName, callback) {
        const listeners = this.listeners[eventName] || [];
        const filteredListeners = listeners.filter(function (value) {
            return value.callback !== callback;
        });
        if (eventName in this.listeners) {
            this.listeners[eventName] = filteredListeners;
            return true; // Event was found and removed
        }
        return false; // Event was not found
    }

    /**
     * emits an event with the given name and arguments
     * @param {string} eventName - The name of the event
     * @param {any} args - The arguments to pass to the callback
     * @return {void}
     * @use {__context: this|Instance} to pass the context to the callback
     * @example eventBus.emit('event.name', arg1, arg2, arg3)
     * @example eventBus.emit('event.name', arg1, arg2, arg3, {__context: YourInstance})
     */
    emit(eventName, ...args) {
        let queueListeners = [];
        let matches = null;
        const allArgs = this.extractContextFromArgs(args);
        const context = allArgs[0];
        args = allArgs[1];
        // name exact match
        if (this.hasListener(eventName)) {
            queueListeners = this.listeners[eventName];
        } else {
            // -----------------------------------------
            // Wildcard support
            if (eventName.includes('*')) {
                // case 1, if the incoming string has * or ** in it
                // which will suppport emit("name*") or emit("name**") or emit("name.*name**")
                matches = this.patternSearch(eventName, Object.keys(this.listeners));
                if (matches) {
                    matches.forEach((match) => {
                        queueListeners = queueListeners.concat(this.listeners[match]);
                    });
                }
            } else {
                // case 2, if the incoming string matches a registered pattern
                // which will support on("name*") | on("name**") | on("name.*name**")
                for (const key in this.listeners) {
                    matches = this.patternSearch(key, [eventName]);
                    if (matches) {
                        queueListeners = queueListeners.concat(this.listeners[key]);
                    }
                }
            }
        }
        queueListeners.forEach((listener, k) => {
            let callback = listener.callback;
            if (context) {
                callback = callback.bind(context);
            }
            callback(...args);
            if (listener.triggerCapacity !== undefined) {
                listener.triggerCapacity--;
                queueListeners[k].triggerCapacity = listener.triggerCapacity;
            }
            if (this.checkToRemoveListener(listener)) {
                this.listeners[eventName].splice(k, 1);
            }
        });
    }
    /**
     * Search for a pattern in a list of strings
     * @method patternSearch
     * @private
     * @param {string} pattern - The pattern to search for
     * @param {string[]} list - The list of strings to search in
     * @return {string[]|null} - Returns a list of strings that match the pattern, or null if no match is found
     * @example patternSearch('name.*', ['name.a', 'name.b', 'name.c']) // returns ['name.a', 'name.b', 'name.c']
     */
    patternSearch(pattern, list) {
        let filteredList = [];
        // console.log('__testLogHere__', pattern, this.setWildCardString(pattern));
        const regex = new RegExp(this.setWildCardString(pattern));
        filteredList = list.filter((item) => regex.test(item));
        return filteredList.length === 0 ? null : filteredList;
    }
    setWildCardString(string) {
        // eslint-disable-next-line
        let regexStr = string.replace(/([.+?^${}()|\[\]\/\\])/g, '\\$&'); // escape all regex special chars
        regexStr = regexStr
            // eslint-disable-next-line
            .replace(/\*\*/g, '[_g_]') // Replace wildcard patterns with temporary markers
            // eslint-disable-next-line
            .replace(/\*/g, '(.*?)')
            .replace(/\[_g_\]/g, '.*');
        return `^${regexStr}$`;
    }
    /**
     * Extract the context from the arguments
     * @method extractContextFromArgs
     * @private
     * @param {any[]} args - The arguments to extract the context from
     * @return {any[]} - Returns an array with the context as the first element and the arguments as the second element
     */
    extractContextFromArgs(args) {
        let context = null;
        for (let i = 0; i < args.length; i++) {
            const arg = args[i];
            // eslint-disable-next-line
            if (arg && typeof arg === 'object' && arg.hasOwnProperty('__context')) {
                context = arg.__context;
                args.splice(i, 1);
                break;
            }
        }
        return [context, args];
    }
    registerListener(eventName, callback, triggerCapacity) {
        if (!this.hasListener(eventName)) {
            this.listeners[eventName] = [];
        }
        this.listeners[eventName].push({ callback, triggerCapacity });
    }
    checkToRemoveListener(eventInformation) {
        if (eventInformation.triggerCapacity !== undefined) {
            return eventInformation.triggerCapacity <= 0;
        }
        return false;
    }
    hasListener(eventName) {
        return eventName in this.listeners;
    }
}

// // -----------------------------------------
// /**
//  * @knighttower
//  * @url knighttower.io
//  * @git https://github.com/knighttower/
//  */
// // -----------------------------------------


/**
 * Make sure the the item is an array or convert it to an array
 * @function makeArray
 * @param {String|Array} item
 * @return array
 * @example makeArray('test') // ['test']
 */
const makeArray = (item) => (Array.isArray(item) ? item : [item]);

/**
 * Generate unique ids
 * @function getDynamicId
 * @memberof Utility
 * @return string Format kn__000000__000
 */
function getDynamicId() {
    return 'kn__' + new Date().getTime() + '__' + Math.floor(Math.random() * (999 - 100));
}

/**
 * @class promisePool
 * @description Class to manage a pool of promises with status tracking.
 * @methods
 * add: Adds a promise to the pool and sets up handling for resolution.
 * status: Returns the overall status of the promise pool.
 * isDone: Returns true if the pool is done processing all promises.
 * clear: Clears all promises from the pool.
 */
const promisePool = () => {
    let _status = 'in-progress'; // 'in progress' or 'done'
    let promises = {};
    let rejectedPromises = [];

    return new (class extends EventBus {
        constructor() {
            super();
        }
        /**
         * Adds a promise to the pool and sets up handling for resolution.
         * @param {Promise|Array} promise The promise to add to the pool.
         */
        add(promise) {
            // console.log(promise instanceof Promise !== true, !Array.isArray(promise));
            const isValid =
                promise instanceof Promise !== true ||
                !(Array.isArray(promise) && promise.every((item) => item instanceof Promise));

            if (!isValid) {
                throw new Error('promisePool: The first argument must be a promise or an array of promises.');
            }
            const $this = this;
            const promiseCollection = makeArray(promise);
            promiseCollection.forEach((promise) => {
                const promiseBag = Promise.all([promise]);
                const promiseId = getDynamicId();
                promises[promiseId] = {
                    promiseBag,
                    status: 'in-progress',
                };
                promiseBag
                    .then(() => {
                        promises[promiseId].status = 'completed';
                        $this._updateStatus();
                    })
                    .catch(() => {
                        promises[promiseId].status = 'rejected';
                        $this._updateStatus();
                    });
            });
        }

        /**
         * Returns the overall status of the promise pool.
         * @returns {String} The current status of the pool.
         */
        status() {
            return _status;
        }

        isDone() {
            return _status === 'done';
        }

        _updateStatus() {
            if (_status === 'done') {
                return;
            }

            const instances = Object.values(promises);
            instances.forEach((promise) => {
                if (promise.status === 'rejected') {
                    rejectedPromises.push(promise);
                }
            });

            const statuses = instances.every(
                (promise) => promise.status === 'completed' || promise.status === 'rejected'
            );

            _status = statuses ? 'done' : 'in-progress';

            this.emit('stats', {
                completed: instances.filter((promise) => promise.status === 'completed').length,
                rejected: rejectedPromises.length,
                pending: instances.filter((promise) => promise.status === 'in-progress').length,
                total: instances.length,
            });

            if (_status === 'done') {
                this.emit('completed');
                this.emit('rejected', rejectedPromises);
                this.clear();
            }
        }

        /**
         * Clears all promises from the pool.
         */
        clear() {
            promises = {};
            rejectedPromises = [];
        }
    })();
};

/**
 * @class PromiseQueue
 * Class to manage a queue of promises, executing them sequentially with status tracking for each promise.
 * @extends EventBus
 * @methods
 * add: Adds a promise to the queue and starts the queue processing if not already started.
 * clear: Clears the promise queue.
 * status: Returns the current status of all promises in the queue.
 */
const PromiseQueue = class extends EventBus {
    constructor() {
        super();
        this.queue = [];
        this.inProgress = false;
        this._timer = null;
    }

    /**
     * Adds a promise to the queue and starts the queue processing if not already started.
     * @param {Function} promiseFunction A function that returns a promise.
     */
    add(promises) {
        makeArray(promises).forEach((promiseFunction) => {
            this.queue.push({
                promiseFunction,
                status: 'pending', // 'pending', 'fulfilled', or 'rejected'
            });
        });

        if (!this.inProgress) {
            this._next();
        }
        this._setTimer();
    }

    /**
     * Clears the promise queue.
     */
    clear() {
        this.queue = [];
    }

    _setTimer() {
        if (this._timer) {
            clearInterval(this._timer);
        }
        this._timer = setInterval(() => {
            if (this.status() === 'done') {
                this.emit('completed');
                clearInterval(this._timer);
                this._timer = null;
            }
        }, 10);
    }

    /**
     * Processes the next promise in the queue, if any.
     * @private
     */
    _next() {
        if (this.queue.length === 0) {
            this.inProgress = false;
            return;
        }

        this.inProgress = true;
        const { promiseFunction } = this.queue[0];
        promiseFunction()
            .then(() => {
                this.queue[0].status = 'fulfilled';
            })
            .catch(() => {
                this.queue[0].status = 'rejected';
            })
            .finally(() => {
                this.queue.shift(); // Remove the processed promise from the queue
                this._next(); // Process the next promise
            });
    }

    /**
     * Returns the current status of all promises in the queue.
     * @returns {Array<Object>} An array of objects with the status of each promise.
     */
    status() {
        return this.queue.length === 0 ? 'done' : 'in-progress';
    }
};

/**
 * Creates a poll function that continuously calls a given function until it returns true or a promise resolves.
 * @param {Function} fn - The function to be polled. It can return a promise or a boolean.
 * @param {Object} options - Configuration options for polling.
 * @param {number} [options.interval=200] - The interval in milliseconds between each poll.
 * @param {number} [options.timeout=1000] - The maximum time in milliseconds to continue polling.
 * @returns {Object} { promise, stop } - An object containing the polling promise and a cancel function.
 * @fails returns 'failed' if the polling times out or is cancelled.
 * @options: {}
 * - interval: The interval in milliseconds between each poll.
 * - timeout: The maximum time in milliseconds to continue polling.
 * @example
 * const { promise, stop } = doPoll(() => {
 *    // Polling logic here
 *   return true; // or return a promise
 * }
 */
const doPoll = (fn, options = {}) => {
    if (typeof fn !== 'function') {
        throw new Error('doPoll: The first argument must be a function.');
    }
    const { interval = 200, timeout = 1000 } = options;
    let timeoutId, intervalId;
    let resolvePromise, rejectPromise;
    let stopped = false;

    const stop = () => {
        clearTimers();
        rejectPromise(console.info('===> doPoll: cancelled or timed out.'));
    };

    const done = (result) => {
        clearTimers();
        resolvePromise(result);
    };

    function clearTimers() {
        stopped = true;
        clearTimeout(timeoutId);
        clearInterval(intervalId);
    }

    const promise = new Promise((resolve, reject) => {
        resolvePromise = resolve;
        rejectPromise = reject;
        const isPromise = fn instanceof Promise;

        const poll = () => {
            if (stopped) {
                return;
            }

            const pollThis = isPromise ? fn : fn();

            if (isPromise) {
                pollThis
                    .then((resolvedValue) => {
                        if (resolvedValue) {
                            done(resolvedValue);
                        }
                    })
                    .catch(rejectPromise);
            } else {
                if (Boolean(pollThis) || pollThis) {
                    done(pollThis);
                }
            }
        };

        intervalId = setInterval(poll, interval);
        poll(); // Initial call to handle any immediate resolution

        timeoutId = setTimeout(() => {
            if (!stopped) {
                stop();
            }
        }, timeout);
    });

    return { promise, stop };
};




/***/ }),

/***/ "./node_modules/knighttower/packages/utility/dist/esm/ProxyClass.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/knighttower/packages/utility/dist/esm/ProxyClass.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ProxyClass: () => (/* binding */ proxyClass),
/* harmony export */   "default": () => (/* binding */ proxyClass),
/* harmony export */   proxyClass: () => (/* binding */ proxyClass)
/* harmony export */ });
/**
 * Enhances a class with proxy functionality to enforce access and mutation rules for its properties.
 * This approach utilizes a higher-order function to wrap the class with a Proxy.
 */

/**
 * Wraps a class with a Proxy to enforce private, protected, and mutable properties.
 * @param {Function} BaseClass - The class to be wrapped.
 * @returns {Proxy} A proxy-wrapped class enforcing the specified access controls.
 * @usage
 * // Example class to use with proxyClass
    class MyClass {
        constructor() {
            this.publicProp = 'This can be accessed and modified.';
            this.protectedProp = 'This cannot be modified.';
            this.privateProp = 'This cannot be accessed or modified.';
            this.mutableProp = 'This can be modified.';
            this._protected = ['protectedProp'];
            this._private = ['privateProp'];
            this._mutable = ['mutableProp'];
        }
    }

    // Enhanced class with proxyClass
    const ProxyEnhancedMyClass = proxyClass(MyClass);

    // Example usage
    const instance = new ProxyEnhancedMyClass();
    console.log(instance.publicProp); // Accessible
    instance.publicProp = 'New value'; // Modifiable
    console.log(instance.privateProp); // Attempt to access private property: privateProp
    instance.mutableProp = 'Changed'; // Modifiable, even if protected
    console.log(instance.mutableProp);
    delete instance.privateProp;
 */
function proxyClass(BaseClass) {
    return new Proxy(BaseClass, {
        construct(target, args) {
            const instance = new target(...args);
            const _private = new Set(instance._private || []);
            const _protected = new Set([..._private, ...(instance._protected || [])]);
            const _mutable = new Set(instance._mutable || []);

            const canMutate = (prop) => {
                if (_protected.has(prop) && !_mutable.has(prop)) {
                    console.error(`Attempt to modify protected property: ${prop}`);
                    return false;
                }
                if (_private.has(prop) && !_mutable.has(prop)) {
                    console.error(`Attempt to modify private property: ${prop}`);
                    return false;
                }
                return true;
            };

            return new Proxy(instance, {
                get(target, prop, receiver) {
                    if (_private.has(prop)) {
                        console.error('Attempt to access private property:', prop);
                        return undefined; // Or throw an Error
                    }
                    return Reflect.get(target, prop, receiver);
                },
                set(target, prop, value) {
                    if (!canMutate(prop)) {
                        return false; // Or throw an Error
                    }
                    return Reflect.set(target, prop, value);
                },
                deleteProperty(target, prop) {
                    if (!canMutate(prop)) {
                        return false; // Or throw an Error
                    }
                    return Reflect.deleteProperty(target, prop);
                },
                defineProperty(target, prop, descriptor) {
                    if (!canMutate(prop)) {
                        return false; // Or throw an Error
                    }
                    return Reflect.defineProperty(target, prop, descriptor);
                },
                ownKeys(target) {
                    const keys = Reflect.ownKeys(target);
                    return keys.filter((key) => !_private.has(key));
                },
                enumerate(target) {
                    const keys = Reflect.enumerate(target);
                    return keys.filter((key) => !_private.has(key));
                },
                has(target, prop) {
                    return !_private.has(prop) && Reflect.has(target, prop);
                },
                getOwnPropertyDescriptor(target, prop) {
                    if (_private.has(prop)) {
                        return undefined;
                    }
                    return Reflect.getOwnPropertyDescriptor(target, prop);
                },
            });
        },
    });
}




/***/ }),

/***/ "./node_modules/knighttower/packages/utility/dist/esm/ProxyObject.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/knighttower/packages/utility/dist/esm/ProxyObject.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ProxyObject: () => (/* binding */ proxyObject),
/* harmony export */   "default": () => (/* binding */ proxyObject),
/* harmony export */   proxyObject: () => (/* binding */ proxyObject)
/* harmony export */ });
// [2023] [Knighttower] https://github.com/knighttower

/**
 * @module proxyObject
 * Convert to proxy to protect objects
 * Allows to declare _private, _protected and _mutable - all arrays with prop names
 * @example proxyObject({objectProps..., _protected: array(...)})
 * @param {Object} object
 * @return {Proxy}
 * @usage const proxy = proxyObject({objectProps..., _protected: array(...), _private: array(...), _mutable: array(...)})
 * @usage _protected: array(...) -> Cannot be modified
 * @usage _private: array(...) -> Cannot be accessed
 * @usage _mutable: array(...) -> Can be modified
 */
function proxyObject(object) {

    // Initialize property access control sets
    const _private = new Set(object._private || ['_private']);
    const _protected = new Set([..._private, ...(object._protected || [])]);
    const _mutable = new Set(object._mutable || []);

    const canMutate = (prop) => {
        if (_protected.has(prop) && !_mutable.has(prop)) {
            console.error(`Attempt to modify protected property: ${prop}`);
            return false;
        }
        if (_private.has(prop) && !_mutable.has(prop)) {
            console.error(`Attempt to modify private property: ${prop}`);
            return false;
        }
        return true;
    };

    return new Proxy(object, {
        get(target, prop, receiver) {
            if (_private.has(prop)) {
                console.error(`Attempt to access private property: ${prop}`);
                return undefined;
            }
            return Reflect.get(target, prop, receiver);
        },
        set(target, prop, value, receiver) {
            if (!canMutate(prop)) {
                return false;
            }
            return Reflect.set(target, prop, value, receiver);
        },
        deleteProperty(target, prop) {
            if (!canMutate(prop)) {
                return false;
            }
            return Reflect.deleteProperty(target, prop);
        },
        defineProperty(target, prop, descriptor) {
            if (!canMutate(prop)) {
                return false;
            }
            return Reflect.defineProperty(target, prop, descriptor);
        },
        ownKeys(target) {
            return Reflect.ownKeys(target).filter((key) => !_private.has(key));
        },
        enumerate(target) {
            const keys = Reflect.enumerate(target);
            return keys.filter((key) => !_private.has(key));
        },
        has(target, prop) {
            return !_private.has(prop) && Reflect.has(target, prop);
        },
        getOwnPropertyDescriptor(target, prop) {
            if (_private.has(prop)) {
                return undefined;
            }
            return Reflect.getOwnPropertyDescriptor(target, prop);
        },
    });
}




/***/ }),

/***/ "./node_modules/knighttower/packages/utility/dist/esm/UrlHelper.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/knighttower/packages/utility/dist/esm/UrlHelper.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UrlHelper: () => (/* binding */ UrlHelper),
/* harmony export */   "default": () => (/* binding */ UrlHelper),
/* harmony export */   urlHelper: () => (/* binding */ UrlHelper)
/* harmony export */ });
/**
 * URL Object Class with public methods for URL functions and manipulation.
 *
 * @module urlHelper
 */
function UrlHelper(__u) {

    /**
     * Reference to the global window object.
     * @type {Window}
     */
    const win = window;

    /**
     * Reference to the global document object.
     * @type {Document}
     */
    const doc = document;

    /**
     * Get the host value, check if template head has defined this variable.
     * @type {string|boolean}
     */
    const $H = win.$HOST || false;

    /**
     * Get the template value, check if template head has defined this variable.
     * @type {string|boolean}
     */
    const $TMP = win.$TEMPLATE || false;

    /**
     * Server Protocol.
     * @type {string}
     */
    const PROTOCOL = win.location.protocol.replace(':', '');

    /**
     * Hostname.
     * @type {string}
     */
    const HOST = $H || win.location.host;

    /**
     * Template URL.
     * @type {string}
     */
    const TEMPLATE = $TMP || '';

    /**
     * Current Pathname.
     * @type {string}
     */
    const PATH = location.pathname;

    /**
     * Site URL.
     * @type {string}
     */
    const SITE_URL = $H ? $H : `${PROTOCOL}://${HOST}`;

    /**
     * Full URL.
     * @type {string}
     */
    const FULL_URL = $H ? `${$H}${PATH}` : `${PROTOCOL}://${HOST}${PATH}`;

    /**
     * Cached URL parameters.
     * @type {Object|null}
     */
    let cachedURLParams = null;

    /**
     * Parse and return URL parameters.
     *
     * @return {Object} with params, queryString, search, keys, values, and collection.
     * @private
     */
    const parseURLParams = () => {
        if (cachedURLParams) {
            return cachedURLParams;
        }

        const params = new URLSearchParams(win.location.search);
        const vars = {};

        for (const [key, value] of params.entries()) {
            vars[key] = value;
        }

        cachedURLParams = {
            params,
            queryString: params.toString(),
            search: win.location.search,
            keys: Array.from(params.keys()),
            values: Array.from(params.values()),
            collection: vars,
        };

        return cachedURLParams;
    };

    /**
     * Get the current page name (Last part of the URL).
     *
     * @return {string} Current page name.
     */
    __u.getPage = () => {
        const cURL = doc.location.toString().toLowerCase();
        const page = cURL.split('/').pop().split('.')[0];
        return page || 'index'; // assuming 'index' as the default page name
    };

    /**
     * Get the query object info from the current URL.
     *
     * @return {Object} with params, queryString, search, keys, values, and collection.
     */
    __u.getParams = () => {
        return parseURLParams();
    };

    /**
     * Get the query string from the current URL.
     *
     * @return {string} Query string.
     */
    __u.getQuery = () => {
        return parseURLParams().queryString;
    };

    /**
     * Add params to the current query string from the current URL.
     *
     * @param {Object} query - The query object to add.
     * @return {Object} with collection and queryString.
     */
    __u.addToQuery = (query) => {
        const currentQuery = parseURLParams().collection;
        Object.assign(currentQuery, query);
        const qString = Object.entries(currentQuery)
            .map(([key, value]) => `${key}=${value}`)
            .join('&');

        return {
            collection: currentQuery,
            queryString: qString,
        };
    };

    /**
     * Get only the URL hash.
     *
     * @return {string} Current hash.
     */
    __u.getHash = () => win.location.hash.substring(1);

    /**
     * Set the URL hash.
     *
     * @param {string} h - The hash to set.
     */
    __u.setHash = (h) => {
        doc.location.hash = h;
    };

    /**
     * Remove the URL hash.
     */
    __u.deleteHash = () => {
        history.pushState('', doc.title, win.location.pathname);
    };

    /**
     * Go to a specific URL on the same page.
     *
     * @param {string} url - The URL to go to.
     * @return {boolean} Always returns false to prevent browser default behavior.
     */
    __u.goTo = (url) => {
        win.location.href = url;
        return false;
    };

    /**
     * Open a URL in the browser.
     *
     * @param {string} url - The URL to open.
     * @param {string} [name='_blank'] - The name attribute for the new window.
     * @param {string} [params=''] - The window parameters.
     * @return {Window} The window object of the opened URL.
     */
    __u.open = (url, name = '_blank', params = '') => {
        return win.open(url, name, params);
    };

    /**
     * Execute a function if the current URL changes.
     *
     * @param {function} callback - The callback function to execute.
     */
    __u.onChange = (callback) => {
        if (typeof callback === 'function') {
            win.addEventListener('hashchange', callback);
        }
    };

    // Expose constants
    __u.fullUrl = FULL_URL;
    __u.siteUrl = SITE_URL;
    __u.template = TEMPLATE;
    __u.protocol = PROTOCOL;
    __u.host = HOST;
    __u.path = PATH;
    __u.readUrl = doc.URL;
}




/***/ }),

/***/ "./node_modules/knighttower/packages/utility/dist/esm/Utility.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/knighttower/packages/utility/dist/esm/Utility.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Utility: () => (/* binding */ Utility),
/* harmony export */   convertToBool: () => (/* binding */ convertToBool),
/* harmony export */   convertToNumber: () => (/* binding */ convertToNumber),
/* harmony export */   currencyToDecimal: () => (/* binding */ currencyToDecimal),
/* harmony export */   dateFormat: () => (/* binding */ dateFormat),
/* harmony export */   decimalToCurrency: () => (/* binding */ decimalToCurrency),
/* harmony export */   "default": () => (/* binding */ Utility),
/* harmony export */   emptyOrValue: () => (/* binding */ emptyOrValue),
/* harmony export */   formatPhoneNumber: () => (/* binding */ formatPhoneNumber),
/* harmony export */   getDynamicId: () => (/* binding */ getDynamicId),
/* harmony export */   getGoogleMapsAddress: () => (/* binding */ getGoogleMapsAddress),
/* harmony export */   getRandomId: () => (/* binding */ getRandomId),
/* harmony export */   includes: () => (/* binding */ includes),
/* harmony export */   instanceOf: () => (/* binding */ instanceOf),
/* harmony export */   isEmpty: () => (/* binding */ isEmpty),
/* harmony export */   isNumber: () => (/* binding */ isNumber),
/* harmony export */   makeArray: () => (/* binding */ makeArray),
/* harmony export */   openGoogleMapsAddress: () => (/* binding */ openGoogleMapsAddress),
/* harmony export */   randomId: () => (/* binding */ randomId),
/* harmony export */   toCurrency: () => (/* binding */ toCurrency),
/* harmony export */   toDollarString: () => (/* binding */ toDollarString),
/* harmony export */   typeOf: () => (/* binding */ typeOf),
/* harmony export */   uniqueId: () => (/* binding */ uniqueId),
/* harmony export */   utility: () => (/* binding */ Utility),
/* harmony export */   utils: () => (/* binding */ Utility),
/* harmony export */   uuid: () => (/* binding */ uuid),
/* harmony export */   validateEmail: () => (/* binding */ validateEmail),
/* harmony export */   validatePhone: () => (/* binding */ validatePhone)
/* harmony export */ });
// // -----------------------------------------
// /**
//  * @knighttower
//  * @url knighttower.io
//  * @git https://github.com/knighttower/
//  */
// // -----------------------------------------

// -----------------------------
// METHODS
// -----------------------------

/**
 * Convert a value to bool
 * @param {String|Boolean|Int|Number} val
 * @return {Boolean}
 * @usage convertToBool('true') // true
 * @usage convertToBool('false') // false
 * @usage convertToBool('0') // false
 * @usage convertToBool('1') // true
 * @usage convertToBool('') // false
 * @usage convertToBool('true') // true
 * @usage convertToBool('false') // false
 */
function convertToBool(val) {
    switch (typeof val) {
        case 'boolean':
            return val;
        case 'string':
            return val === 'false' || val === '0' ? false : true;
        case 'number':
            return val !== 0;
        default:
            return Boolean(val);
    }
}

/**
 * Converts a given variable to a number if possible.
 * @param {string|number} input - The input variable to convert.
 * @returns {string|number} - The converted number or the original variable.
 * @example convertToNumber(123) // Output: 123 (number)
 * @example convertToNumber(123.45) // Output: 123.45 (number)
 * @example convertToNumber("123") // Output: 123 (number)
 * @example convertToNumber("123.45") // Output: 123.45 (number)
 * @example convertToNumber("abc") // Output: "abc" (original string)
 * @example convertToNumber("123abc") // Output: "123abc" (original string)
 * @example convertToNumber(null) // Output: null (original)
 */
function convertToNumber(input) {
    const isNum = isNumber(input);

    if (isNum !== null) {
        return isNum;
    }
    // Case: String that cannot be converted to a number
    return input;
}

/**
 * Translate dollar amounts to decimal notation
 * @function currencyToDecimal
 * @memberof Utility
 * @param {String|Number} amount
 * @return number
 * @example currencyToDecimal('$123.45') // 123.45
 */
function currencyToDecimal(amount) {
    return Number(amount.replace(/[^0-9.-]+/g, ''));
}

/**
 * Format dates to standard US, with or w/out time
 * @function dateFormat
 * @memberof Utility
 * @param {String} dateTime Raw format 2201-01-01 16:15PM or unix or object
 * @param {Boolean} wTime If set, returns date with time as H:MM A
 * @return string
 * @example dateFormat('2201-01-01 16:15PM') // 01/01/2201
 * @example dateFormat('2201-01-01 16:15PM', true) // 01/01/2201 @ 4:15 PM
 * @example dateFormat('2201-01-01 16:15PM', false) // 01/01/2201
 * @example dateFormat('2201-01-01') // 01/01/2201
 */
function dateFormat(dateTime, wTime) {
    if (!dateTime || isNaN(new Date(dateTime).getTime())) {
        return null;
    }

    const date = new Date(dateTime);

    // Ensuring that the time zone is taken into account.
    const optionsDate = { year: 'numeric', month: '2-digit', day: '2-digit', timeZone: 'UTC' };
    const formattedDate = new Intl.DateTimeFormat('en-US', optionsDate).format(date);

    if (wTime) {
        const optionsTime = { hour: '2-digit', minute: '2-digit', hour12: true, timeZone: 'UTC' };
        const formattedTime = new Intl.DateTimeFormat('en-US', optionsTime).format(date);
        return `${formattedDate} @ ${formattedTime}`;
    }

    return formattedDate;
}

/**
 * Translate decimal notation to dollar amount
 * @function decimalToCurrency
 * @memberof Utility
 * @param {String|Number} amount
 * @return number
 * @example decimalToCurrency(123.45) // 123.45
 * @example decimalToCurrency(2123.46) // 2,123.46
 */
function decimalToCurrency(amount) {
    const formatConfig = {
        minimumFractionDigits: 2,
    };
    return new Intl.NumberFormat('en-GB', formatConfig).format(amount);
}

/**
 * Check if there is a value, if not return null or the default value
 * It can test strings, arrays, objects, numbers, booleans
 * @function emptyOrValue
 * @memberof Utility
 * @param {String|Number} value If the value is not empty, returns it
 * @param {String|Number} _default The default value if empty
 * @return mixed
 * @example emptyOrValue('test', 'default') // 'test'
 * @example emptyOrValue('', 'default') // 'default'
 * @example emptyOrValue('test') // 'test'
 * @example emptyOrValue('') // null
 * @example emptyOrValue(0) // 0
 * @example var hello = ''; emptyOrValue(hello) // Null
 * @example var hello = 'test'; emptyOrValue(hello) // 'test'
 * @example var hello = 'test'; emptyOrValue(hello, 'default') // 'test'
 * @example var hello = ''; emptyOrValue(hello, 'default') // 'default'
 * @example var hello = []; emptyOrValue(hello, 'default') // null
 * @example var hello = {}; emptyOrValue(hello, 'default') // null
 * @example var hello = [...]; emptyOrValue(hello') // [...]
 */
function emptyOrValue(value, _default = null) {
    /**
     * Test sequence:
     * If it is a number 0> : true
     * If is not undefined: true
     * If it is boolean (true|false) prevents going to empty
     * If it is not Empty, [], null, {}, 0, true, false: true
     */

    if (isNumber(value) !== null || typeof value === 'boolean') {
        return value;
    } else if (!isEmpty(value)) {
        return value;
    }

    return _default;
}

/**
 * Format a phone number based on a given template.
 * @param {string} phoneNumber - The phone number to format.
 * @param {string} template - The template to use for formatting.
 * @returns {string} - The formatted phone number.
 * @example console.log(formatPhoneNumber('1234567890', '(000) 000-0000')); // Output: (123) 456-7890
 * @example console.log(formatPhoneNumber('1234567890', '000-000-0000')); // Output: 123-456-7890
 * @example console.log(formatPhoneNumber('123-456-7890', '(000) 000-0000')); // Output: (123) 456-7890
 * @example console.log(formatPhoneNumber('(123) 456-7890', '000-0000-0000')); // Output: 123-4567-890
 */
function formatPhoneNumber(phoneNumber, template) {
    // Remove all non-numeric characters from the phone number
    const cleaned = phoneNumber.replace(/\D/g, '');

    // Verify the length of the cleaned phone number
    if (cleaned.length !== 10) {
        throw new Error('Invalid phone number length');
    }

    // Initialize an array to hold the formatted phone number
    let formatted = [];

    // Initialize a pointer for the cleaned phone number
    let cleanedPointer = 0;

    // Loop through the template and replace placeholders with actual numbers
    for (let i = 0; i < template.length; i++) {
        if (template[i] === '0') {
            formatted.push(cleaned[cleanedPointer]);
            cleanedPointer++;
        } else {
            formatted.push(template[i]);
        }
    }

    return formatted.join('');
}

/**
 * Make sure the the item is an array or convert it to an array
 * @function makeArray
 * @param {String|Array} item
 * @return array
 * @example makeArray('test') // ['test']
 */
const makeArray = (item) => (Array.isArray(item) ? item : [item]);

/**
 * Generate unique ids
 * @function getDynamicId
 * @memberof Utility
 * @return string Format kn__000000__000
 */
function getDynamicId() {
    return 'kn__' + new Date().getTime() + '__' + Math.floor(Math.random() * (999 - 100));
}

/**
 * Alias to getDynamicId
 * @function getRandomId
 * @memberof Utility
 * @return string
 * @example getRandomId() // kn__000000__000
 */
const getRandomId = getDynamicId;
const randomId = getDynamicId;

const uuid = (max = 20) => {
    const rnd = () => Math.random().toString(36).substring(2, 15);
    max = max || 40;
    var str = '';
    for (var i = 0; i < max / 3 + 1; i++) {
        str += rnd();
    }
    return str.substring(0, max);
};
const uniqueId = uuid;

/**
 * Form a valid Google search address
 * @function getGoogleMapsAddress
 * @memberof Utility
 * @param {String|Object} address
 * @return string
 * @example getGoogleMapsAddress('New York') // 'https://maps.google.it/maps?q=New+York'
 * @example getGoogleMapsAddress({ address: 'New York', zip: '10001' }) // 'https://maps.google.it/maps?q=New+York+10001'
 * @example getGoogleMapsAddress({ address: 'New York', city: 'New York', state: 'NY' }) // 'https://maps.google.it/maps?q=New+York+New+York+NY'
 */
function getGoogleMapsAddress(address) {
    if (!address) {
        return false;
    }

    let search = '';

    if (typeOf(address, 'string')) {
        search = address;
    } else {
        const keys = ['address', 'address1', 'city', 'state', 'zip', 'zipcode'];

        search = keys.reduce((acc, key) => {
            const value = Object.keys(address).find((aKey) => aKey.includes(key) && address[aKey]);
            return value ? `${acc} ${address[value]}` : acc;
        }, '');
    }

    search = search.trim().replace(/\s+|,/g, '+');
    return `https://maps.google.it/maps?q=${search}`;
}

/**
 * Check if a value is in a collection (array, string, object)
 * @param {collection} collection - The collection to search in
 * @param {value} value - The value to search for
 * @param {fromIndex} fromIndex - The index to start searching from
 * @return {boolean} - True if the value is in the collection, false otherwise
 */
function includes(collection, value, fromIndex = 0) {
    if (Array.isArray(collection) || typeof collection === 'string') {
        // Use native includes for arrays and strings
        return collection.includes(value, fromIndex);
    }

    if (typeof collection === 'object') {
        // Search in object values
        for (let key in collection) {
            if (collection[key] === value) {
                return true;
            }
        }
    }

    return false;
}

/**
 * Check if a value is empty
 * @function isEmpty
 * @memberof Utility
 * @param {string|array|object|map|set|number|boolean} value
 * @url https://moderndash.io/
 * @return {string}
 */
function isEmpty(value) {
    if (value === null || value === undefined) {
        return true;
    }

    if (typeof value === 'string' || Array.isArray(value)) {
        return value.length === 0;
    }

    if (value instanceof Map || value instanceof Set) {
        return value.size === 0;
    }

    if (ArrayBuffer.isView(value)) {
        return value.byteLength === 0;
    }

    if (typeof value === 'object') {
        return Object.keys(value).length === 0;
    }

    return false;
}

/**
 * Check if is a number or Int, if not return null
 * Integrates both Int and Number, or convert a string number to number to test
 * Note: this is not like Lodash isNumber since this one takes into consideration the 'string number'
 * @function isNumber
 * @memberof Utility
 * @param {String|Number} value
 * @return null|int
 * @example isNumber(123) // true
 * @example isNumber(123.45) // true
 * @example isNumber('123abc') // false
 * @example isNumber('abc') // false
 * @example isNumber('') // false
 * @example isNumber("123") // true
 * @example isNumber("123.45") // true
 */
function isNumber(value) {
    const isType = typeof value;
    switch (value) {
        case null:
        case undefined:
        case '':
            return null;
        case '0':
        case 0:
            return 0;
        default:
            if (isType === 'number' || isType === 'string') {
                if (typeof value === 'number' || !Number.isNaN(Number(value))) {
                    return +value;
                }
            }

            break;
    }

    return null;
}

/**
 * Check the instance of a variable, and get the correct type for it. It also accepts simple comparisons
 * For more advance type checking see https://github.com/knighttower/JsTypeCheck
 * @param {any} input - The variable to check
 * @param {string|instance} test - The types to check against, piped string
 * @return {string|boolean} - The type of the variable or boolean when test is provided
 */
function instanceOf(input, test) {
    let inputType = 'unknown';
    const isValid = typeof input === 'function' || typeof input === 'object';
    if (input === null || !isValid) {
        return false;
    }

    const instanceMapping = [Date, RegExp, Promise, Map, Set, WeakMap, WeakSet, ArrayBuffer, DataView];
    let instTotal = instanceMapping.length;
    while (instTotal--) {
        if (input instanceof instanceMapping[instTotal]) {
            inputType = instanceMapping[instTotal].name;
            break;
        }
    }

    if (test) {
        test = typeof test === 'string' ? test.toLowerCase() : test.name.toLowerCase();
        // In case that the input is a custom instance
        if (inputType === 'unknown') {
            inputType = input.name;
        }
        return test === inputType.toLowerCase();
    }

    return inputType;
}

/**
 * Open a Google Map using a provided address
 * @function openGoogleMapsAddress
 * @memberof Utility
 * @param {String|Object} object - Address information either as a string or as an object
 * @throws {Error} Throws an error if the address is invalid or if it's not a string or object.
 * @return {void}
 * @example openGoogleMapsAddress('New York'); // Opens Google Maps with the address 'New York'
 * @example openGoogleMapsAddress({ address: 'New York', zip: '10001' }); // Opens Google Maps with the address 'New York 10001'
 */
function openGoogleMapsAddress(object) {
    if (!typeOf(object, 'string') || !typeOf(object, 'object')) {
        throw new Error('The input must be a string or an object.');
    }

    const address = getGoogleMapsAddress(object);

    if (!isEmpty(address) || !typeOf(address, 'string')) {
        throw new Error('The address you are trying to open is invalid.');
    }

    return window.open(address, '_blank');
}

/**
 * Alias to getDynamicId
 * @function toCurrency
 * @memberof Utility
 * @param {String|Number} amount
 * @return number
 * @example toCurrency(123.45) // 123.45
 * @example toCurrency(2123.46) // 2,123.46
 */
function toCurrency(amount) {
    return decimalToCurrency(amount);
}

/**
 * Covert to dollar string
 * @function toDollarString
 * @memberof Utility
 * @param {String|Number} amount
 * @return number
 * @example toDollarString(2,000) // 2K
 * @example toDollarString(2,000,000) // 2M
 * @example toDollarString(2,500,000) // 2.5M
 */
function toDollarString(amount) {
    if (typeOf(amount, 'string')) {
        amount = currencyToDecimal(amount);
    }

    if (Math.abs(amount) > 999 && Math.abs(amount) < 999999) {
        return Math.sign(amount) * (Math.abs(amount) / 1000).toFixed(1) + 'K';
    }
    if (Math.abs(amount) > 999999) {
        return Math.sign(amount) * (Math.abs(amount) / 1000000).toFixed(1) + 'M';
    }

    return Math.sign(amount) * Math.abs(amount);
}

/**
 * Check the type of a variable, and get the correct type for it. It also accepts simple comparisons
 * For more advance type checking see https://github.com/knighttower/JsTypeCheck
 * @param {any} input - The variable to check
 * @param {string} test - The types to check against, piped string
 * @return {string|boolean} - The type of the variable
 * @example typeOf('hello', 'string') // returns true
 * @example typeOf('hello', 'number') // returns false
 * @example typeOf('hello', 'string') // returns true
 * @example typeOf('hello') // returns 'string'
 * @example typeOf({}) // returns 'object'
 */
function typeOf(input, test) {
    // Special case for null since it can be treated as an object
    if (input === null) {
        if (test) {
            return test === null || test === 'null' ? true : false;
        }
        return 'null';
    }

    let inputType;

    switch (typeof input) {
        case 'number':
        case 'string':
        case 'boolean':
        case 'undefined':
        case 'bigint':
        case 'symbol':
        case 'function':
            inputType = typeof input;
            break;
        case 'object':
            inputType = Array.isArray(input) ? 'array' : 'object';

            break;
        default:
            inputType = 'unknown';
    }

    if (test) {
        if (test.includes('|')) {
            for (let type of test.split('|')) {
                if (inputType === type) {
                    return type;
                }
            }
            return false;
        }

        return test === inputType;
    }

    return inputType;
}

/**
 * Validate emails
 * @function validateEmail
 * @memberof Utility
 * @param {String} email
 * @return Boolean
 * @example validateEmail('<EMAIL>') // false
 * @example validateEmail('test@test') // false
 * @example validateEmail('test@test.') // false
 * @example validateEmail('test@test.c') // false
 * @example validateEmail('test@test.com') // true
 */
function validateEmail(email) {
    var emailRegex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}$/;
    return emailRegex.test(email);
}

/**
 * Validate a phone number
 * @function validatePhone
 * @memberof Utility
 * @param {String} phone
 * @return void|Toast
 * @example validatePhone('1234567890') // true
 * @example validatePhone('(123) 456-7890') // true
 * @example validatePhone('123-456-7890') // true
 * @example validatePhone('123 456 7890') // false
 * @example validatePhone('123-4567-89') // false
 */
function validatePhone(phone) {
    var phoneRegex = /^\(?(\d{3})\)?[- ]?(\d{3})[- ]?(\d{4})$/;
    return phoneRegex.test(phone);
}

// export default Utility;
const Utility = {
    convertToBool,
    currencyToDecimal,
    convertToNumber,
    dateFormat,
    decimalToCurrency,
    emptyOrValue,
    formatPhoneNumber,
    getDynamicId,
    getGoogleMapsAddress,
    getRandomId,
    includes,
    isEmpty, // from https://moderndash.io/
    isNumber,
    instanceOf,
    openGoogleMapsAddress,
    toCurrency,
    toDollarString,
    typeOf,
    validateEmail,
    validatePhone,
    makeArray,
    uuid,
    uniqueId,
};




/***/ }),

/***/ "./node_modules/knighttower/packages/utility/index.js":
/*!************************************************************!*\
  !*** ./node_modules/knighttower/packages/utility/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DomObserver: () => (/* reexport safe */ _dist_esm_DomObserver_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   ElementHelper: () => (/* reexport safe */ _dist_esm_ElementHelper_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   EventBus: () => (/* reexport safe */ _dist_esm_EventBus_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   PowerHelper: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.PowerHelper),
/* harmony export */   PromisePool: () => (/* reexport safe */ _dist_esm_PromiseQueue_mjs__WEBPACK_IMPORTED_MODULE_4__.PromisePool),
/* harmony export */   PromiseQueue: () => (/* reexport safe */ _dist_esm_PromiseQueue_mjs__WEBPACK_IMPORTED_MODULE_4__.PromiseQueue),
/* harmony export */   ProxyClass: () => (/* reexport safe */ _dist_esm_ProxyClass_mjs__WEBPACK_IMPORTED_MODULE_5__.ProxyClass),
/* harmony export */   ProxyObject: () => (/* reexport safe */ _dist_esm_ProxyObject_mjs__WEBPACK_IMPORTED_MODULE_6__.ProxyObject),
/* harmony export */   UrlHelper: () => (/* reexport safe */ _dist_esm_UrlHelper_mjs__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   Utility: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   _eventBus: () => (/* reexport safe */ _dist_esm_EventBus_mjs__WEBPACK_IMPORTED_MODULE_2__._eventBus),
/* harmony export */   addQuotes: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.addQuotes),
/* harmony export */   cleanStr: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.cleanStr),
/* harmony export */   convertKeysToSymbols: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.convertKeysToSymbols),
/* harmony export */   convertToBool: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.convertToBool),
/* harmony export */   convertToNumber: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.convertToNumber),
/* harmony export */   currencyToDecimal: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.currencyToDecimal),
/* harmony export */   dateFormat: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.dateFormat),
/* harmony export */   decimalToCurrency: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.decimalToCurrency),
/* harmony export */   doPoll: () => (/* reexport safe */ _dist_esm_PromiseQueue_mjs__WEBPACK_IMPORTED_MODULE_4__.doPoll),
/* harmony export */   domObserver: () => (/* reexport safe */ _dist_esm_DomObserver_mjs__WEBPACK_IMPORTED_MODULE_0__.domObserver),
/* harmony export */   elementHelper: () => (/* reexport safe */ _dist_esm_ElementHelper_mjs__WEBPACK_IMPORTED_MODULE_1__.elementHelper),
/* harmony export */   emptyOrValue: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.emptyOrValue),
/* harmony export */   findAndReplaceInArray: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.findAndReplaceInArray),
/* harmony export */   findNested: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.findNested),
/* harmony export */   fixQuotes: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.fixQuotes),
/* harmony export */   formatPhoneNumber: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.formatPhoneNumber),
/* harmony export */   getArrObjFromString: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.getArrObjFromString),
/* harmony export */   getChunks: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.getChunks),
/* harmony export */   getDirectivesFromString: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.getDirectivesFromString),
/* harmony export */   getDynamicId: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.getDynamicId),
/* harmony export */   getGoogleMapsAddress: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.getGoogleMapsAddress),
/* harmony export */   getMatchBlock: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.getMatchBlock),
/* harmony export */   getMatchInBetween: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.getMatchInBetween),
/* harmony export */   getRandomId: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.getRandomId),
/* harmony export */   includes: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.includes),
/* harmony export */   instanceOf: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.instanceOf),
/* harmony export */   isEmpty: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.isEmpty),
/* harmony export */   isNumber: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.isNumber),
/* harmony export */   makeArray: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.makeArray),
/* harmony export */   openGoogleMapsAddress: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.openGoogleMapsAddress),
/* harmony export */   powerHelper: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   promisePool: () => (/* reexport safe */ _dist_esm_PromiseQueue_mjs__WEBPACK_IMPORTED_MODULE_4__.promisePool),
/* harmony export */   promiseQueue: () => (/* reexport safe */ _dist_esm_PromiseQueue_mjs__WEBPACK_IMPORTED_MODULE_4__.promiseQueue),
/* harmony export */   proxyClass: () => (/* reexport safe */ _dist_esm_ProxyClass_mjs__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   proxyObject: () => (/* reexport safe */ _dist_esm_ProxyObject_mjs__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   randomId: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.randomId),
/* harmony export */   removeQuotes: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.removeQuotes),
/* harmony export */   selectElement: () => (/* reexport safe */ _dist_esm_ElementHelper_mjs__WEBPACK_IMPORTED_MODULE_1__.selectElement),
/* harmony export */   setExpString: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.setExpString),
/* harmony export */   setLookUpExp: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.setLookUpExp),
/* harmony export */   setWildCardString: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.setWildCardString),
/* harmony export */   startAndEndWith: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.startAndEndWith),
/* harmony export */   toCurrency: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.toCurrency),
/* harmony export */   toDollarString: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.toDollarString),
/* harmony export */   typeOf: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.typeOf),
/* harmony export */   uniqueId: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.uniqueId),
/* harmony export */   urlHelper: () => (/* reexport safe */ _dist_esm_UrlHelper_mjs__WEBPACK_IMPORTED_MODULE_7__.urlHelper),
/* harmony export */   utility: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.utility),
/* harmony export */   utils: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.utils),
/* harmony export */   uuid: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.uuid),
/* harmony export */   validateEmail: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.validateEmail),
/* harmony export */   validatePhone: () => (/* reexport safe */ _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__.validatePhone),
/* harmony export */   wildCardStringSearch: () => (/* reexport safe */ _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.wildCardStringSearch)
/* harmony export */ });
/* harmony import */ var _dist_esm_DomObserver_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/esm/DomObserver.mjs */ "./node_modules/knighttower/packages/utility/dist/esm/DomObserver.mjs");
/* harmony import */ var _dist_esm_ElementHelper_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dist/esm/ElementHelper.mjs */ "./node_modules/knighttower/packages/utility/dist/esm/ElementHelper.mjs");
/* harmony import */ var _dist_esm_EventBus_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dist/esm/EventBus.mjs */ "./node_modules/knighttower/packages/utility/dist/esm/EventBus.mjs");
/* harmony import */ var _dist_esm_PowerHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dist/esm/PowerHelpers.mjs */ "./node_modules/knighttower/packages/utility/dist/esm/PowerHelpers.mjs");
/* harmony import */ var _dist_esm_PromiseQueue_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dist/esm/PromiseQueue.mjs */ "./node_modules/knighttower/packages/utility/dist/esm/PromiseQueue.mjs");
/* harmony import */ var _dist_esm_ProxyClass_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dist/esm/ProxyClass.mjs */ "./node_modules/knighttower/packages/utility/dist/esm/ProxyClass.mjs");
/* harmony import */ var _dist_esm_ProxyObject_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dist/esm/ProxyObject.mjs */ "./node_modules/knighttower/packages/utility/dist/esm/ProxyObject.mjs");
/* harmony import */ var _dist_esm_UrlHelper_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./dist/esm/UrlHelper.mjs */ "./node_modules/knighttower/packages/utility/dist/esm/UrlHelper.mjs");
/* harmony import */ var _dist_esm_Utility_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./dist/esm/Utility.mjs */ "./node_modules/knighttower/packages/utility/dist/esm/Utility.mjs");
// Single Modules and Aliases from: DomObserver

// Default Module from: DomObserver

// Single Modules and Aliases from: ElementHelper

// Default Module from: ElementHelper

// Single Modules and Aliases from: EventBus

// Default Module from: EventBus

// Single Modules and Aliases from: PowerHelpers

// Default Module from: PowerHelpers

// Single Modules and Aliases from: PromiseQueue

// Single Modules and Aliases from: ProxyClass

// Default Module from: ProxyClass

// Single Modules and Aliases from: ProxyObject

// Default Module from: ProxyObject

// Single Modules and Aliases from: UrlHelper

// Default Module from: UrlHelper

// Single Modules and Aliases from: Utility

// Default Module from: Utility





/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!*****************************!*\
  !*** ./examples/vue/app.js ***!
  \*****************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var Adaptive_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Adaptive.js */ "./src/Adaptive.js");
/* harmony import */ var _hello_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hello.vue */ "./examples/vue/hello.vue");
/* harmony import */ var _compApiSample_vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./compApiSample.vue */ "./examples/vue/compApiSample.vue");
/**
* @author Knighttower
    MIT License

    Copyright (c) [2022] [Knighttower] https://github.com/knighttower

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

var _Vue = Vue,
  createApp = _Vue.createApp;



var app = createApp({});
//Optional | Add custom media query (min px, max px) settings (min max)
Adaptive_js__WEBPACK_IMPORTED_MODULE_0__["default"].addQueryMinMax('kitty', 900, 1400);
// Optional | Add a custom media query expression (it accepts any valid media query)
Adaptive_js__WEBPACK_IMPORTED_MODULE_0__["default"].addQueryExpression('doggy', '(min-width: 900px)');
// Needs to be instaciated right after the app and before the components
// The second parameter (optional, defaults to false) is to be in hybrid mode for Vue and Static JS(DOM),
Adaptive_js__WEBPACK_IMPORTED_MODULE_0__["default"].useVue(app, true);
// Do components and other stuff right after
app.component('hello', _hello_vue__WEBPACK_IMPORTED_MODULE_1__["default"]);
app.component('comp-api-sample', _compApiSample_vue__WEBPACK_IMPORTED_MODULE_2__["default"]);

// Testing the code if there is a delay on load and how the Adaptive would react
setTimeout(function () {
  app.mount('#app');
}, '1');
})();

/******/ })()
;